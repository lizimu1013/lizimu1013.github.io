<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>linux操作系统(整理更新中)</title>
    <url>/2021/03/08/linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E6%95%B4%E7%90%86%E6%9B%B4%E6%96%B0%E4%B8%AD)/</url>
    <content><![CDATA[<h1 id="新坑-笔记持续整理更新中"><a href="#新坑-笔记持续整理更新中" class="headerlink" title="新坑, 笔记持续整理更新中"></a>新坑, 笔记持续整理更新中</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><blockquote>
<p>阿里云云服务器的使用</p>
<p>linux系统的基础操作</p>
<p>linux下文件IO、进程、线程、信号技术的使用</p>
<p>linux内核子系统的运作机制</p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>linux</tag>
        <tag>基础</tag>
        <tag>更新中</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/03/09/test2/</url>
    <content><![CDATA[<p>测试</p>
<h1 id="标题H1"><a href="#标题H1" class="headerlink" title="标题H1"></a>标题H1</h1><h2 id="标题H2"><a href="#标题H2" class="headerlink" title="标题H2"></a>标题H2</h2><h3 id="标题H3"><a href="#标题H3" class="headerlink" title="标题H3"></a>标题H3</h3><h4 id="标题H4"><a href="#标题H4" class="headerlink" title="标题H4"></a>标题H4</h4><h5 id="标题H5"><a href="#标题H5" class="headerlink" title="标题H5"></a>标题H5</h5><h6 id="标题H6"><a href="#标题H6" class="headerlink" title="标题H6"></a>标题H6</h6><h3 id="字符效果和横线等"><a href="#字符效果和横线等" class="headerlink" title="字符效果和横线等"></a>字符效果和横线等</h3><hr>
<p><del>删除线</del><br> <em>斜体字</em><br> <strong>粗体字</strong><br> *<strong>粗斜体*</strong><br> 上标：X2，下标：O2</p>
<blockquote>
<p>即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启</p>
</blockquote>
<p><a href="https://links.jianshu.com/go?to=https://www.baidu.com/">普通链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install marked</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">test</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/594273-dc28ffb88073a3af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/160/format/webp" alt="img"></p>
<p>image</p>
<hr>
<ul>
<li><p>列表1</p>
</li>
<li><p>列表2</p>
</li>
<li><p>列表3</p>
</li>
<li><p>列表1</p>
<ul>
<li>列表4</li>
</ul>
</li>
<li><p>列表2</p>
</li>
<li><p>列表3</p>
</li>
</ul>
<blockquote>
<p>不支持嵌套吗？</p>
</blockquote>
<ul>
<li>列表1</li>
<li>列表2<ul>
<li>列表3</li>
<li>立标</li>
</ul>
</li>
</ul>
<ol>
<li>第一行<br> 1.1. 类表<br> 2.1. libid</li>
<li>第二行</li>
<li>含行</li>
</ol>
<blockquote>
<p>不支持 GFM task list</p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> GFM task list 1</li>
<li><input checked="" disabled="" type="checkbox"> GFM task list 2</li>
<li><input disabled="" type="checkbox"> GFM task list 3<ul>
<li><input disabled="" type="checkbox"> GFM task list 3-1</li>
<li><input disabled="" type="checkbox"> GFM task list 3-2</li>
<li><input disabled="" type="checkbox"> GFM task list 3-3</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> GFM task list 4<ul>
<li><input disabled="" type="checkbox"> GFM task list 4-1</li>
<li><input disabled="" type="checkbox"> GFM task list 4-2</li>
</ul>
</li>
</ul>
<blockquote>
<p>不支持分页符<br> [========]</p>
</blockquote>
<blockquote>
<p>不支持绘制流程图</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 用户登陆</span><br><span class="line">op&#x3D;&gt;operation: 登陆操作</span><br><span class="line">cond&#x3D;&gt;condition: 登陆成功 Yes or No?</span><br><span class="line">e&#x3D;&gt;end: 进入后台</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志</title>
    <url>/2021/03/17/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="Changelog"><a href="#Changelog" class="headerlink" title="Changelog"></a>Changelog</h1><p>文档说明 </p>
<h2 id="1-0-0-003-2021-03-17"><a href="#1-0-0-003-2021-03-17" class="headerlink" title="[1.0.0-003] - 2021-03-17"></a>[1.0.0-003] - 2021-03-17</h2><ul>
<li><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><ul>
<li>github + jsdelivr白嫖图床好像翻车了, 尝试以后逐渐更换成阿里云oss. 真香</li>
</ul>
</li>
</ul>
<h2 id="1-0-0-002-2021-03-11"><a href="#1-0-0-002-2021-03-11" class="headerlink" title="[1.0.0-002] - 2021-03-11"></a>[1.0.0-002] - 2021-03-11</h2><ul>
<li><h3 id="新增-1"><a href="#新增-1" class="headerlink" title="新增"></a>新增</h3><ul>
<li>左下角 音乐播放器</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>平衡二叉排序树-AVL树</title>
    <url>/2021/03/18/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-AVL%E6%A0%91/</url>
    <content><![CDATA[<hr>
<p><a href="https://lizm.xyz/2021/03/08/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%95%B4%E7%90%86%E6%9B%B4%E6%96%B0%E4%B8%AD)/">高级数据结构</a></p>
<hr>
<h1 id="平衡二叉排序树-之-AVL树"><a href="#平衡二叉排序树-之-AVL树" class="headerlink" title="平衡二叉排序树 之 AVL树"></a>平衡二叉排序树 之 AVL树</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><blockquote>
<p>解决二叉排序树查找性能退化的问题</p>
</blockquote>
<p><strong>性质</strong></p>
<ul>
<li><p>具备所有二叉排序树的所有性质</p>
</li>
<li><p>平衡条件 : | H(left) - H(right) |  &lt;=  1 , 左右子树高度差不超过1</p>
</li>
<li><p>重点 : 平衡条件以及平衡调整</p>
</li>
</ul>
<p><strong>优点</strong></p>
<p>由于对每个节点的左右子树的树高做了限制, 所以整棵树<code>不会退化成一个链表</code></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol>
<li><p>高度为H的BS树, 所包含的节点数量在什么范围之内?</p>
<p>H &lt;= size(H) &lt;= 2^H^ - 1</p>
</li>
<li><p>高度为H的AVL树, 所包含的节点数量在什么范围之内?</p>
<p>1.5^H^&lt;= size(H) &lt;= 2^H^ - 1 (大概是1.5)</p>
</li>
</ol>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210318144419891.png" alt="image-20210318144419891"></p>
<p>树高H, 节点数n, H=logn</p>
<p>最差情况下, 查找效率是logn级别的, </p>
<p>AVL树相对于一般的BS树, 提高了效率的下限</p>
<h2 id="左旋和右旋"><a href="#左旋和右旋" class="headerlink" title="左旋和右旋"></a>左旋和右旋</h2><p><strong>左旋</strong></p>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210318154432821.png" alt="image-20210318154432821"></p>
<p>节点A一定小于K3, 并且大于K1, 所以可以作为K1的右子树</p>
<p>K3的左子树变为K1的右子树</p>
<p><strong>右旋</strong></p>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210318155156004.png" alt="image-20210318155156004"></p>
<p>左旋与右旋是一对对称的操作, 可以互相转换</p>
<h2 id="失衡类型"><a href="#失衡类型" class="headerlink" title="失衡类型"></a>失衡类型</h2><p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210318155649458.png" alt="image-20210318155649458"></p>
<p><code>K1表示回溯过程中第一次发现失衡</code>, 即H(K2) = H(K3) + 2</p>
<p>LL : K1左子树K2的左子树A更大一些</p>
<h3 id="LL型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h3><p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210318160059499.png" alt="image-20210318160059499"></p>
<p>原AVL树是平衡的, 新插入一个节点导致了LL型失衡, 那么新插入的节点一定是插入到了A子树中</p>
<p>H(K2) = H(K3) + 2</p>
<p>H(A) = H(B) + 1</p>
<blockquote>
<p>H(A)= H(B) + 1 = maxH(C,D) + 2 </p>
</blockquote>
<p>只要出现LL失衡, 一定是上述关系</p>
<p><strong>如何调整</strong></p>
<blockquote>
<p>抓着失衡的节点K1进行右旋</p>
</blockquote>
<p>RR类型同理, 直接进行左旋</p>
<h3 id="LR型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h3><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210318162727150.png" alt="image-20210318162727150" style="zoom:50%;" />

<p>H(K2) = H(D) + 2</p>
<p>H(K3) = maxH(B,C) + 1</p>
<p>H(K2) = H(K3) + 1</p>
<p>H(K3) = H(A) + 1</p>
<blockquote>
<p>maxH(B,C) = H(D) = H(A)</p>
</blockquote>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210318162636360.png" alt="image-20210318162636360"></p>
<p>**如何调整? **</p>
<blockquote>
<p>先对K1的左子树K2进行左旋, 变成LL型, 再对K1进行右旋</p>
</blockquote>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210318170342837.png" alt="image-20210318170342837"></p>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210318173027713.png" alt="image-20210318173027713"></p>
<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210318172222572.png" alt="image-20210318172222572" style="zoom: 50%;" />

<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: AVL.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define L(n) (n ? n-&gt;lchild : NULL)</span></span><br><span class="line"><span class="comment">//#define R(n) (n ? n-&gt;rchild : NULL)</span></span><br><span class="line"><span class="comment">//#define H(n) (n ? n-&gt;h : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(n) (n-&gt;lchild)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R(n) (n-&gt;rchild)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> H(n) (n-&gt;h)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, h;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;key = <span class="number">0</span>, NIL-&gt;h = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;h = <span class="number">1</span>;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_height</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    root-&gt;h = (H(L(root)) &gt; H(R(root)) ? H(L(root)) : H(R(root))) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;rchild;<span class="comment">//旋转完之后的新的根节点地址</span></span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    update_height(root);</span><br><span class="line">    update_height(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;<span class="comment">//旋转完之后的新的根节点地址</span></span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    update_height(root);</span><br><span class="line">    update_height(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(H(L(root)) - H(R(root))) &lt;= <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;h &gt; root-&gt;rchild-&gt;h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;lchild-&gt;h &lt; root-&gt;lchild-&gt;rchild-&gt;h) &#123;</span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;rchild-&gt;h &lt; root-&gt;rchild-&gt;lchild-&gt;h) &#123;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = insert(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;rchild = insert(root-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">    update_height(root);</span><br><span class="line">    <span class="comment">//return root;//回溯过程</span></span><br><span class="line">    <span class="keyword">return</span> maintain(root);<span class="comment">//返回经过平衡调整以后根节点的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> NIL;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild != NIL ? root-&gt;lchild : root-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(root);<span class="comment">//释放当前节点所占空间</span></span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;key = temp-&gt;key;<span class="comment">//前驱节点的值覆盖当前节点的值</span></span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, key);<span class="comment">//到左子树中删除值为前驱节点的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    update_height(root);</span><br><span class="line">    <span class="keyword">return</span> maintain(root);</span><br><span class="line">    <span class="comment">//return root;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d], %d, %d)\n&quot;</span>,</span><br><span class="line">        root-&gt;key, root-&gt;h,</span><br><span class="line">        root-&gt;lchild-&gt;key,</span><br><span class="line">        root-&gt;rchild-&gt;key</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210318185255638.png" alt="image-20210318185255638" style="zoom:50%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="平衡调整策略"><a href="#平衡调整策略" class="headerlink" title="平衡调整策略"></a>平衡调整策略</h3><ul>
<li>发生在回溯阶段, 第一个失衡节点处</li>
<li>理解平衡调整策略的关键在于 : 分析清楚四种情况下, ABCD四颗子树树高的关系</li>
<li>LL, 大右旋</li>
<li>LR, 先小左旋, 再大右旋</li>
<li>RL, 先小右旋, 再大左旋</li>
<li>RR, 大左旋</li>
</ul>
<h3 id="代码演示总结"><a href="#代码演示总结" class="headerlink" title="代码演示总结"></a>代码演示总结</h3><ul>
<li>插入和删除以后, 注意重新计算树高字段</li>
<li>引入了NIL字段, 代替NULL, NULL不可访问, NIL是一个实际节点, 可访问. (可以不用额外判断是否为空节点)</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>进阶</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>高级数据结构(整理更新中)</title>
    <url>/2021/03/08/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%95%B4%E7%90%86%E6%9B%B4%E6%96%B0%E4%B8%AD)/</url>
    <content><![CDATA[<h1 id="新坑-笔记持续整理更新中"><a href="#新坑-笔记持续整理更新中" class="headerlink" title="新坑, 笔记持续整理更新中"></a>新坑, 笔记持续整理更新中</h1><p><a href="https://lizm.xyz/2021/03/11/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/">排序二叉树</a> </p>
<p><a href="https://lizm.xyz/2021/03/18/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-AVL%E6%A0%91/">平衡二叉树之AVL树</a></p>
<p><a href="https://lizm.xyz/2021/03/24/%E7%BA%A2%E9%BB%91%E6%A0%91RB-Tree/">红黑树</a></p>
<p>排序查找 哈希表数据结构</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>更新中</tag>
        <tag>数据结构</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程与高级系统编程(整理更新中)</title>
    <url>/2021/03/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B(%E6%95%B4%E7%90%86%E6%9B%B4%E6%96%B0%E4%B8%AD)/</url>
    <content><![CDATA[<h1 id="新坑-持续更新中"><a href="#新坑-持续更新中" class="headerlink" title="新坑, 持续更新中"></a>新坑, 持续更新中</h1><h2 id="预计主要内容"><a href="#预计主要内容" class="headerlink" title="预计主要内容"></a>预计主要内容</h2><ol>
<li>熟悉计算机网络常见协议，掌握<code>TCP</code>、<code>UDP</code>等重要协议；</li>
<li>具备独立分布式应用程序的能力；</li>
<li>掌握开发高并发网络服务器的能力；</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>更新中</tag>
        <tag>进阶</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉排序树</title>
    <url>/2021/03/11/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<hr>
<p><a href="https://lizm.xyz/2021/03/08/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%95%B4%E7%90%86%E6%9B%B4%E6%96%B0%E4%B8%AD)/">高级数据结构</a></p>
<hr>
<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210310222636087.png" alt="image-20210310222636087"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>性质</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>二叉排序树, 二叉搜索树</td>
<td>左子树 &lt; 根节点</td>
<td>解决与<code>排名</code>相关的检索需求</td>
</tr>
<tr>
<td></td>
<td>右子树 &gt; 根节点</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>中序遍历</code>的结果, 是一个有序数列</td>
<td></td>
</tr>
</tbody></table>
<p><strong>如何查找一个值x?</strong></p>
<blockquote>
<p>树形结构查找的入口一定是<code>根节点</code>, 因为根节点代表了全集</p>
<p>如果x的值比根节点小, 那么x一定存在于根节点的左子树中;</p>
<p>反之, 如果x的值比根节点大, 那么x一定存在于根节点的右子树中</p>
</blockquote>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p><strong>如何向二叉排序树中插入一个节点10?</strong></p>
<blockquote>
<p>插入的新节点, 一定会作为<code>叶子节点</code></p>
<p>基于二叉树的插入方式<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210310234358209.png" alt="image-20210310234358209" style="zoom:25%;" /></p>
<p>10与根节点20进行比较, 10 &lt; 20, 所以10插入到20节点的左子树中;</p>
<p>10 &lt; 17, 所以10插入到17节点的左子树中;</p>
<p>10 &gt; 3, 所以10插入到3节点的右子树. 又因为3节点没有右子树, 所以10成为了3的右子树</p>
<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210310234711891.png" alt="image-20210310234711891" style="zoom:25%;" />
</blockquote>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><blockquote>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210310235004688.png" alt="image-20210310235004688"></p>
<p><strong>1. 如何删除叶子节点(度为0)?</strong></p>
<p>直接删除</p>
<p><strong>2. 如何删除度为1的节点?</strong></p>
<p>删除3节点, 唯一的子孩子10节点成为了孤儿, 教给其爷爷节点17</p>
<p><strong>3. 如何删除度为2的节点(删除20)?</strong></p>
<p>找到该节点的前驱或者后继, 替换到度为2的节点的位置, 再删除替换后的前驱或者后继, 详见<strong>前驱与后继</strong></p>
<p>然后转化为删除度为0或者度为1的问题</p>
</blockquote>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210311173609069.png" alt="image-20210311173609069" style="zoom: 33%;" />

<blockquote>
<p>10 - 17 - 20 - 28 - 29 - 32 - 30    二叉排序树的中序遍历的结果是<code>有序的</code></p>
<p>左子树(小)   根节点(20)   右子树(大)</p>
</blockquote>
<h2 id="前驱与后继"><a href="#前驱与后继" class="headerlink" title="前驱与后继"></a>前驱与后继</h2><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210311174232571.png" alt="image-20210311174232571" style="zoom:33%;" />

<p>将当前的二叉排序树写成一个有序数列</p>
<blockquote>
<p>17 18 19 20 28 29 30 32</p>
</blockquote>
<p>对于20这个节点, 紧挨着前后两个节点19和28, 分别就是20节点的<code>前驱</code>和<code>后继</code></p>
<blockquote>
<p>前驱是一个节点左子树中的最大值, 后继是右子树中的最小值</p>
<p>19这个节点一定没有右子树, 28节点一定没有左子树, 一定不是度为2的节点</p>
<p>对于一个度为2的节点而言, 它的前驱或者后继一定是度为0或者度为1的节点</p>
</blockquote>
<p><strong>如何删去20这个节点?</strong></p>
<blockquote>
<p>找到该节点的前驱或者后继, 替换到度为2的节点的位置</p>
<p>然后去该节点的左子树或者右子树中, 删除一个多余的前驱或者后继</p>
<p>例 : 图中序列为 </p>
<p>17 18 19 20 28 29 30 32    前驱19替换20后, </p>
<p>17 18 20 19 28 29 30 32    删去20(度为1)</p>
<p>17 18 19 28 29 30 32</p>
</blockquote>
<h2 id="平均查找效率"><a href="#平均查找效率" class="headerlink" title="平均查找效率"></a>平均查找效率</h2><p>节点查找次数的期望值,<br>$$<br>\frac{总次数}{节点数量}<br>$$</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>画出相应的二叉搜索树</strong></p>
<p>[5 9 8 3 2 4 1 7]<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210311181327620.png" alt="image-20210311181327620" style="zoom:15%;" /></p>
<p>[1 2 3 4 5]<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210311181340900.png" alt="image-20210311181340900" style="zoom:15%;" /> 平均查找次数: (1+2+3+4+5=15) / 5 = 3次</p>
<p>[3 2 1 5 4]<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210311181612764.png" alt="image-20210311181612764" style="zoom:15%;" />  平均查找次数: (1+2+2+3+3=11) / 5 = 2.2次</p>
<blockquote>
<p>插入顺序不同, 平均查找次数也不一样</p>
<p>不同的树形结构, 查找效率不同</p>
</blockquote>
<p>LeetCode. 110 </p>
<p>LeetCode. 669</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: binary_search_tree.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;key : 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个节点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入节点的值key, 初始化节点</span></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0表示没找到</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == val) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1表示找到了</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;key) <span class="keyword">return</span> search(root-&gt;lchild, val);<span class="comment">//如果查找的值比根节点小, 就去左子树</span></span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, val);<span class="comment">//反之去右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作,因为有可能会改变根节点的地址, 所以直接返回新的根节点的地址</span></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(key);<span class="comment">//如果根节点不存在, 就建立新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild, key);</span><br><span class="line">    <span class="comment">//插入操作有可能会改变当前节点左子树的根节点地址, 所以要把返回值赋值给左子树</span></span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, key);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="comment">//如果temp有右子树, 就一直往右子树走</span></span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//此时说明当前节点即为待删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//删除度为0的节点</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//删除度为1的节点</span></span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;<span class="comment">//如果lchild不为空, 唯一子孩子就为lchild</span></span><br><span class="line">            <span class="comment">//否则唯一子孩子即为rchild</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除度为2的节点</span></span><br><span class="line">            Node *temp = predecessor(root);<span class="comment">//找到前驱</span></span><br><span class="line">            root-&gt;key = temp-&gt;key;<span class="comment">//与前驱替换</span></span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key);<span class="comment">//问题转化,删除根节点的前驱, 即左子树中值为temp-&gt;key的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d, %d)\n&quot;</span>, KEY(root), KEY(root-&gt;lchild), KEY(root-&gt;rchild));</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d\n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            <span class="comment">//插入删除的时候输出树形结构, 查找时不输出(0为假)</span></span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-------------\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210311204858839.png" alt="image-20210311204858839"></p>
<h1 id="二叉排序树的扩展"><a href="#二叉排序树的扩展" class="headerlink" title="二叉排序树的扩展"></a>二叉排序树的扩展</h1><h2 id="二叉排序树删除的代码优化"><a href="#二叉排序树删除的代码优化" class="headerlink" title="二叉排序树删除的代码优化"></a>二叉排序树删除的代码优化</h2><p>删除操作的时候, 度为0的点和度为1的点可以合并, 不影响代码整体功能</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210312171741948.png" alt="image-20210312171741948"></p>
<p>合并删去</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210312171701679.png" alt="image-20210312171701679"></p>
<h2 id="如何解决排名相关的检索需求"><a href="#如何解决排名相关的检索需求" class="headerlink" title="如何解决排名相关的检索需求"></a>如何解决<code>排名</code>相关的检索需求</h2><p>如果<code>根节点</code>的左子树中有2个节点, 那么<code>根节点</code>的排名是第3位</p>
<blockquote>
<p>要想知道节点的排名, 需要知道其左右节点的个数</p>
<p>需要修改结构定义, 增加size字段, 记录每棵树的节点数量 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: binary_search_tree.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;key : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n) (n ? n-&gt;size : 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个节点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入节点的值key, 初始化节点</span></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;size = <span class="number">1</span>;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata_size</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    root-&gt;size = SIZE(root-&gt;lchild) + SIZE(root-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0表示没找到</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == val) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1表示找到了</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;key) <span class="keyword">return</span> search(root-&gt;lchild, val);<span class="comment">//如果查找的值比根节点小, 就去左子树</span></span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, val);<span class="comment">//反之去右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作,因为有可能会改变根节点的地址, 所以直接返回新的根节点的地址</span></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(key);<span class="comment">//如果根节点不存在, 就建立新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild, key);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, key);</span><br><span class="line">    updata_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="comment">//如果temp有右子树, 就一直往右子树走</span></span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//此时说明当前节点即为待删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//删除度为1或0的节点</span></span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;<span class="comment">//如果lchild不为空, 唯一子孩子就为lchild</span></span><br><span class="line">            <span class="comment">//否则唯一子孩子即为rchild</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除度为2的节点</span></span><br><span class="line">            Node *temp = predecessor(root);<span class="comment">//找到前驱</span></span><br><span class="line">            root-&gt;key = temp-&gt;key;<span class="comment">//与前驱替换</span></span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key);<span class="comment">//问题转化,删除根节点的前驱, 即左子树中值为temp-&gt;key的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updata_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d], %d, %d)\n&quot;</span>, </span><br><span class="line">           KEY(root), SIZE(root),</span><br><span class="line">           KEY(root-&gt;lchild), KEY(root-&gt;rchild));</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d\n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            <span class="comment">//插入删除的时候输出树形结构, 查找时不输出(0为假)</span></span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-------------\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>随机数生成程序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: rand.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 20</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (rand() % <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;0 %d\n&quot;</span>, rand() % <span class="number">15</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;1 %d\n&quot;</span>, rand() % <span class="number">15</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;2 %d\n&quot;</span>, rand() % <span class="number">15</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210312181826525.png" alt="image-20210312181826525"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210312181849717.png" alt="image-20210312181849717"></p>
<p>画出树<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210312181937836.png" alt="image-20210312181937836" style="zoom:15%;" /></p>
<blockquote>
<p>方括号内表示的是当前节点下面的节点数(包含本节点)</p>
</blockquote>
<p><strong>如何判断<code>排名</code>第k位的元素?</strong></p>
<blockquote>
<p>分成三种情况:</p>
<ol>
<li><p>从根节点开始, 如果根节点的左子树中的元素数量LS = k-1, 那么根节点就是找到的结果</p>
</li>
<li><p>如果根节点左子树的元素数量LS &gt;= k, 排名第k的元素在左子树中;</p>
</li>
<li><p>否则, 当LS &lt; k, 在右子树中, 问题转化为在右子树中递归查找search(k-LS-1)</p>
</li>
</ol>
</blockquote>
<p><strong>如何查找排名为第3的值</strong></p>
<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210315210310114.png" alt="image-20210315210310114" style="zoom:33%;" />

<p>根节点2, k = 3, LS = 0, 所以在右子树中查找排名第(3 - 0 - 1) = 2的元素, </p>
<p>跟节点4, k = 2, LS = 0, 所以在节点4的右子树中查找排名第(2 - 0 - 1) = 1的元素, 即6</p>
<p>所以排名为第3的元素的值为6</p>
<blockquote>
<p>分成三种情况的前提 : 需要记录每个子树中节点的数量</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码中加入search-k模块</span></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: binary_search_tree.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Thu 11 Mar 2021 06:46:03 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;key : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n) (n ? n-&gt;size : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(n) (n ? n-&gt;lchild : NULL)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个节点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入节点的值key, 初始化节点</span></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;size = <span class="number">1</span>;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata_size</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    root-&gt;size = SIZE(root-&gt;lchild) + SIZE(root-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0表示没找到</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == val) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1表示找到了</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;key) <span class="keyword">return</span> search(root-&gt;lchild, val);<span class="comment">//如果查找的值比根节点小, 就去左子树</span></span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, val);<span class="comment">//反之去右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (SIZE(L(root)) == k - <span class="number">1</span>) <span class="keyword">return</span> root-&gt;key;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(L(root))) &#123;</span><br><span class="line">        <span class="keyword">return</span> search_k(root-&gt;lchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作,因为有可能会改变根节点的地址, 所以直接返回新的根节点的地址</span></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(key);<span class="comment">//如果根节点不存在, 就建立新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild, key);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, key);</span><br><span class="line">    updata_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="comment">//如果temp有右子树, 就一直往右子树走</span></span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//此时说明当前节点即为待删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//删除度为1或0的节点</span></span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;<span class="comment">//如果lchild不为空, 唯一子孩子就为lchild</span></span><br><span class="line">            <span class="comment">//否则唯一子孩子即为rchild</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除度为2的节点</span></span><br><span class="line">            Node *temp = predecessor(root);<span class="comment">//找到前驱</span></span><br><span class="line">            root-&gt;key = temp-&gt;key;<span class="comment">//与前驱替换</span></span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key);<span class="comment">//问题转化,删除根节点的前驱, 即左子树中值为temp-&gt;key的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updata_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d], %d, %d)\n&quot;</span>, </span><br><span class="line">           KEY(root), SIZE(root),</span><br><span class="line">           KEY(root-&gt;lchild), KEY(root-&gt;rchild));</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d\n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;search k = %d, result : %d\n&quot;</span>,</span><br><span class="line">                       val, search_k(root, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (op) &#123;</span><br><span class="line">            <span class="comment">//插入删除的时候输出树形结构, 查找时不输出(0为假)</span></span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-------------\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210316192337827.png" alt="image-20210316192337827" style="zoom: 50%;" />

<h2 id="解决Top-K问题-如何找到所有小于第k位的元素"><a href="#解决Top-K问题-如何找到所有小于第k位的元素" class="headerlink" title="解决Top-K问题(如何找到所有小于第k位的元素?)"></a>解决Top-K问题(如何找到所有小于第k位的元素?)</h2><p><strong>如何输出前k为的元素?</strong></p>
<ol>
<li>如果根节点就是第k位元素, 就把左子树中的值全部输出出来</li>
<li>如果第k位在左子树中, 那么前k位元素全部在左子树中</li>
<li>如果第k位在右子树中, 那么根节点和左子树中的元素, 都是前k位元素中的值</li>
</ol>
<p>或者使用<code>堆</code></p>
<p>所谓的算法设计及分析能力 : 分类讨论及归纳总结的能力</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY(n) (n ? n-&gt;key : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(n) (n ? n-&gt;size : 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(n) (n ? n-&gt;lchild : NULL)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个节点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入节点的值key, 初始化节点</span></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;size = <span class="number">1</span>;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata_size</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    root-&gt;size = SIZE(root-&gt;lchild) + SIZE(root-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(Node *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回0表示没找到</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == val) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1表示找到了</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;key) <span class="keyword">return</span> search(root-&gt;lchild, val);<span class="comment">//如果查找的值比根节点小, 就去左子树</span></span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;rchild, val);<span class="comment">//反之去右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (SIZE(L(root)) == k - <span class="number">1</span>) <span class="keyword">return</span> root-&gt;key;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(L(root))) &#123;</span><br><span class="line">        <span class="keyword">return</span> search_k(root-&gt;lchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> search_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入操作,因为有可能会改变根节点的地址, 所以直接返回新的根节点的地址</span></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> getNewNode(key);<span class="comment">//如果根节点不存在, 就建立新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild, key);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert(root-&gt;rchild, key);</span><br><span class="line">    updata_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="comment">//如果temp有右子树, 就一直往右子树走</span></span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = erase(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;rchild = erase(root-&gt;rchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//此时说明当前节点即为待删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> || root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//删除度为1或0的节点</span></span><br><span class="line">            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;<span class="comment">//如果lchild不为空, 唯一子孩子就为lchild</span></span><br><span class="line">            <span class="comment">//否则唯一子孩子即为rchild</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除度为2的节点</span></span><br><span class="line">            Node *temp = predecessor(root);<span class="comment">//找到前驱</span></span><br><span class="line">            root-&gt;key = temp-&gt;key;<span class="comment">//与前驱替换</span></span><br><span class="line">            root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key);<span class="comment">//问题转化,删除根节点的前驱, 即左子树中值为temp-&gt;key的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updata_size(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d[%d], %d, %d)\n&quot;</span>, </span><br><span class="line">           KEY(root), SIZE(root),</span><br><span class="line">           KEY(root-&gt;lchild), KEY(root-&gt;rchild));</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_k</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span> || root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= SIZE(L(root))) &#123;</span><br><span class="line">        output_k(root-&gt;lchild, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//说明左子树加根节点都是前k位的元素</span></span><br><span class="line">        output(root-&gt;lchild);</span><br><span class="line">        print(root);</span><br><span class="line">        output_k(root-&gt;rchild, k - SIZE(L(root)) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;search %d, result : %d\n&quot;</span>, val, search(root, val)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;search k = %d, result : %d\n&quot;</span>,</span><br><span class="line">                       val, search_k(root, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: output_k(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span> || op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//插入删除的时候输出树形结构, 查找时不输出(0为假)</span></span><br><span class="line">            output(root);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-------------\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210317150825720.png" alt="image-20210317150825720"></p>
<h2 id="二叉排序树和快速排序的关系"><a href="#二叉排序树和快速排序的关系" class="headerlink" title="二叉排序树和快速排序的关系"></a>二叉排序树和快速排序的关系</h2><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210317152242388.png" alt="image-20210317152242388" style="zoom:50%;" />

<p>把快速排序中的x基准值看作根节点, </p>
<ol>
<li>二叉排序树是快速排序在思维逻辑结构层面用的数据结构</li>
<li>快速排序的时间复杂度和二叉排序树建树时间复杂度之间的关系?</li>
<li>快速选择算法和二叉排序树之间的关系?<ol>
<li>都是求解排名第k位元素的方法</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>进阶</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树-RBTree</title>
    <url>/2021/03/24/%E7%BA%A2%E9%BB%91%E6%A0%91RB-Tree/</url>
    <content><![CDATA[<hr>
<p><a href="https://lizm.xyz/2021/03/08/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%95%B4%E7%90%86%E6%9B%B4%E6%96%B0%E4%B8%AD)/">高级数据结构</a></p>
<hr>
<h2 id="五个条件-重要"><a href="#五个条件-重要" class="headerlink" title="五个条件(重要)"></a>五个条件(重要)</h2><ol>
<li>每个节点<code>非黑即红</code></li>
<li>根节点是<code>黑色</code></li>
<li>叶节点（NIL）是<code>黑色</code></li>
<li>如果⼀个节点是红色，则它的两个子节点都是<code>黑色</code>的 </li>
<li>从根节点出发到所有叶节点路径上，黑色节点数量<code>相同</code></li>
</ol>
<ul>
<li>第4第5条件规定了, 红黑树中, 最长边和最短边的关系是2倍</li>
<li>本质上也是靠<code>树高</code>来控制平衡条件 </li>
<li>红黑树相比于AVL树树高控制条件更加松散, 红黑树在发生节点插入和删除以后, 发生调整的概率, 比AVL树更小</li>
</ul>
<h2 id="调整策略"><a href="#调整策略" class="headerlink" title="调整策略"></a>调整策略</h2><ol>
<li><code>插入</code>调整站在<code>祖父节点</code>看</li>
<li><code>删除</code>调整站在<code>父节点</code>看</li>
<li>插入调整, 主要是为了解决<code>双红</code>情况</li>
<li>插入和删除的情况处理一共有五种</li>
<li>把每一种情况, 想象成一棵大的红黑树中的局部子树</li>
<li>局部调整的时候, 为了不影响全局, 调整前后的路径上黑色节点数量相同</li>
</ol>
<h2 id="插入调整的情况"><a href="#插入调整的情况" class="headerlink" title="插入调整的情况"></a>插入调整的情况</h2><blockquote>
<p>插入黑色节点, <code>必然</code>会发生调整. (改变了每个路径上的黑色节点数量)</p>
<p>插入红色节点, <code>可能</code>会发生调整. (只有插入到红色节点下面才会发生调整)</p>
</blockquote>
<h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h3><p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210319174254380.png" alt="image-20210319174254380"></p>
<blockquote>
<p>发生冲突时, 叔叔节点为<code>红色</code>的时候, 修改三元组小帽子, 改成红-黑-黑</p>
<p>处理方法 : 节点1和20修改成<code>黑色</code>, 节点15修改成<code>红色</code><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210320052912394.png" alt="image-20210320052912394" style="zoom:25%;" /></p>
</blockquote>
<ul>
<li>站在<code>祖父节点</code>15向下看, 节点20和新插入的节点x发生冲突</li>
<li>调整前后, 每条路径上黑色节点数量不变, 对其他红黑树的部分不影响</li>
</ul>
<h3 id="情况二-又分四个小情况"><a href="#情况二-又分四个小情况" class="headerlink" title="情况二(又分四个小情况)"></a>情况二(又分四个小情况)</h3><p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210320053125647.png" alt="image-20210320053125647"></p>
<blockquote>
<p>叔叔节点为<code>黑色</code>的时候,参考AVL树的失衡情况, 分成LL,LR,RL,RR, 先参考AVL树的旋转调整策略, 然后再修改三元组的颜色, 有两种调整策略: 红色上浮, 红色下沉</p>
<p>处理方法 : 先大右(左)旋, 20调整为红色, 15调整为黑色(或者把10调整为黑色)</p>
</blockquote>
<ul>
<li>冲突发生在左子树, 并且左子树的左子树为红色, 称为LL类型失衡</li>
<li>右旋, 不影响每棵树上黑色节点的数量</li>
<li>蓝色框表示, 若发生LL失衡, 则颜色确定的点</li>
<li>若发生LR失衡, 先把父子树小左旋, 再把祖父子树大右旋, 再调整颜色 </li>
</ul>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210320180357885.png" alt="image-20210320180357885"></p>
<h2 id="插入的代码演示"><a href="#插入的代码演示" class="headerlink" title="插入的代码演示"></a>插入的代码演示</h2><p>优化</p>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321114012105.png" alt="image-20210321114012105" style="zoom: 40%;" /><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321120451418.png" alt="image-20210321120451418" style="zoom:45%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> color; <span class="comment">// 0 red, 1 black, 2 double black</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;key = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;color = <span class="number">1</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;color = <span class="number">0</span>;<span class="comment">//新插入的节点为红色</span></span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">has_red_child</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;lchild-&gt;color == <span class="number">0</span> || root-&gt;rchild-&gt;color == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;rchild;<span class="comment">//指向旋转以后的根节点地址</span></span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;<span class="comment">//指向旋转以后的根节点地址</span></span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!has_red_child(root)) <span class="keyword">return</span> root;<span class="comment">//判断是否有红色子孩子</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//利用flag来判断是否存在双红冲突的情况</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; root-&gt;rchild-&gt;color == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">goto</span> insert_end;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;lchild)) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;rchild)) flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span> root;<span class="comment">//没有发生冲突, 直接return</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//冲突发生在左子树中, 第一个字母是L</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;rchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//说明需要先进行小左旋</span></span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">insert_end:</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;</span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;<span class="comment">//红色上浮, 改成红黑黑</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__insert(Node *root, <span class="keyword">int</span> key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = __insert(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;rchild = __insert(root-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return root;</span></span><br><span class="line">    <span class="keyword">return</span> insert_maintain(root);<span class="comment">//在插入节点的回溯过程中进行插入调整</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//封装一层</span></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    root = __insert(root, key);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d| %d, %d, %d)\n&quot;</span>,</span><br><span class="line">          root-&gt;color, root-&gt;key,</span><br><span class="line">          root-&gt;lchild-&gt;key,</span><br><span class="line">          root-&gt;rchild-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321120400656.png" alt="image-20210321120400656"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结 :"></a>总结 :</h3><ol>
<li>插入调整, 发生在递归的回溯阶段</li>
<li>插入调整代码中, 使用goto语句, 8行代码, 变为4行</li>
<li>处理根节点一定是黑色, 通过代码封装, <em>insert -&gt; __insert</em></li>
</ol>
<h2 id="删除调整的前提"><a href="#删除调整的前提" class="headerlink" title="删除调整的前提"></a>删除调整的前提</h2><ol>
<li>删除红色节点, 不会对红黑树的平衡产生影响</li>
<li>度为1的黑色节点, 唯一子孩子, 一定是红色</li>
<li>删除度为1的黑色节点, 不会产生删除调整</li>
<li>删除度为0的黑色节点, 会产生一个双重黑的NIL节点</li>
<li>删除调整, 就是为了干掉双重黑</li>
<li>删除调整站在父节点往下看</li>
</ol>
<blockquote>
<p>不用调整, 直接删除</p>
</blockquote>
<p>删除黑色节点才会导致删除调整</p>
<h3 id="删除度为1的黑色节点"><a href="#删除度为1的黑色节点" class="headerlink" title="删除度为1的黑色节点"></a>删除度为1的黑色节点</h3><p>思考 : 黑色节点x的唯一子孩子一定是红色节点吗?</p>
<p>是的, 因为节点x没有左孩子, 如果右孩子也是黑色节点, 那么就违反了每条子树黑色节点数量相同的原则</p>
<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321131006200.png" alt="image-20210321131006200" style="zoom:25%;" />

<p>删除x节点后如何调整?</p>
<blockquote>
<p>将唯一子孩子的红色节点上移, 并且改成<code>黑色</code></p>
</blockquote>
<h3 id="删除度为2的节点"><a href="#删除度为2的节点" class="headerlink" title="删除度为2的节点"></a>删除度为2的节点</h3><blockquote>
<p>红黑树本质上是二叉排序树, 转化为删除度为1或0的情况</p>
</blockquote>
<h3 id="删除度为0的黑色节点"><a href="#删除度为0的黑色节点" class="headerlink" title="删除度为0的黑色节点"></a>删除度为0的黑色节点</h3><h4 id="删除节点会发生什么"><a href="#删除节点会发生什么" class="headerlink" title="删除节点会发生什么?"></a>删除节点会发生什么?</h4><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321142750287.png" alt="image-20210321142750287" style="zoom:25%;" />

<p>当把黑色节点x删除, 取而代之的是一个新的节点NIL’<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321143051395.png" alt="image-20210321143051395" style="zoom:25%;" /></p>
<p>假如NIL节点有意义, 此时画出其他NIL节点<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321143201165.png" alt="image-20210321143201165" style="zoom:25%;" /></p>
<p>此时发现不平衡了, 其他路径3个黑色节点, 所以新的NIL需要标记为<code>双重黑</code><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321143303198.png" alt="image-20210321143303198" style="zoom:25%;" /></p>
<p>双黑节点NIL算一个节点, 但是计<code>两次</code>黑色</p>
<p>删除调整就是为了解决<code>双黑</code>的情况</p>
<h4 id="情况1-双重黑节点的兄弟是黑色-并且兄弟的两个子孩子也是黑色"><a href="#情况1-双重黑节点的兄弟是黑色-并且兄弟的两个子孩子也是黑色" class="headerlink" title="情况1:双重黑节点的兄弟是黑色, 并且兄弟的两个子孩子也是黑色"></a>情况1:双重黑节点的兄弟是黑色, 并且兄弟的两个子孩子也是黑色</h4><p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321143658153.png" alt="image-20210321143658153"></p>
<p>站在<code>父节点</code>43发现了双黑节点95</p>
<p>(95双黑有可能是56向上传递的结果)</p>
<blockquote>
<p>调整: 父节点加一重黑色, 父节点的两个子节点–双黑与兄弟节点分别减一重黑</p>
<p>(双重黑向上传递)</p>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321145157408.png" alt="image-20210321145157408"></p>
</blockquote>
<h4 id="情况2-RL-双黑节点的兄弟节点是黑色-但是兄弟节点下面的左节点是红色"><a href="#情况2-RL-双黑节点的兄弟节点是黑色-但是兄弟节点下面的左节点是红色" class="headerlink" title="情况2: RL 双黑节点的兄弟节点是黑色, 但是兄弟节点下面的左节点是红色"></a>情况2: RL 双黑节点的兄弟节点是黑色, 但是兄弟节点下面的左节点是红色</h4><p>如果85是红色, 则一定是<code>RR类型</code></p>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321145638136.png" alt="image-20210321145638136"></p>
<blockquote>
<p>先小右旋, 对调新根与原根的颜色, 转成情况3, 在大左旋, 改色</p>
<p>LR同理</p>
</blockquote>
<p>对于72进行<code>小右旋</code>, 变为RR类型</p>
<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210322141037411.png" alt="image-20210322141037411" style="zoom:50%;" />

<p>蓝框为颜色确定的节点, 73, 42节点颜色不确定, 因为也有可能没有</p>
<p>旋转之前每条路径两个黑色节点, 所以旋转之后需要确保也是两个黑色节点</p>
<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210322142611027.png" alt="image-20210322142611027" style="zoom:25%;" />

<p>51改为黑色, 此时51-48这条子树两个黑色节点;</p>
<p>64和85颜色确定, 所以72可以改为红色, 此时51-72-64(85)也变为两个黑色节点</p>
<p>此时转变为情况3   RL - &gt;RR</p>
<h4 id="情况3-RR-双黑节点的兄弟节点在右侧-并且兄弟节点的右子树为红色"><a href="#情况3-RR-双黑节点的兄弟节点在右侧-并且兄弟节点的右子树为红色" class="headerlink" title="情况3: RR 双黑节点的兄弟节点在右侧, 并且兄弟节点的右子树为红色"></a>情况3: RR 双黑节点的兄弟节点在右侧, 并且兄弟节点的右子树为红色</h4><p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321150126325.png" alt="image-20210321150126325"></p>
<blockquote>
<p>左旋, 新根改为原根的颜色, 将新根的两个子节点, 改为黑色</p>
<p>LL同理</p>
</blockquote>
<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321163012126.png" alt="image-20210321163012126" style="zoom:50%;" />

<p>**分析 : **</p>
<p>确保调整后局部黑色节点数量<code>保持不变</code></p>
<p>对38节点进行左旋之后, 图中蓝框的节点为颜色确定的节点</p>
<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210321165304864.png" alt="image-20210321165304864" style="zoom: 33%;" />

<p>38和48的颜色不确定, 假定38节点为红色如图, </p>
<p>48号节点颜色不确定, 所以38号节点颜色一定改为黑色, </p>
<p><del>此时51-38这条路径多了一个黑色节点, 所以51肯定改为红色.(但38节点也有可能是黑色, 改完之后少了一个黑节点)</del></p>
<p>51节点的颜色一定改为<code>原根节点</code>的颜色(38节点)</p>
<p>此时51-72这条路少了个黑色节点, 所以72节点改为黑色</p>
<h4 id="情况4-双黑节点的兄弟节点是红色"><a href="#情况4-双黑节点的兄弟节点是红色" class="headerlink" title="情况4 : 双黑节点的兄弟节点是红色"></a>情况4 : 双黑节点的兄弟节点是红色</h4><blockquote>
<p>尽量让双黑的红色兄弟节点成为根节点(左旋), 然后交换旋转后根节点和左孩子的颜色, 转化为情况123</p>
</blockquote>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210322144720739.png" alt="image-20210322144720739"></p>
<p>旋转后, 左子树三个黑色节点, 右子树两个黑色节点, 进行颜色修改</p>
<p>删除调整是站在父节点往下看, 所以调整要站在旋转后根节点的左孩子往下看</p>
<p>旋转后, 双黑节点的兄弟节点一定是黑色, 转变为情况123</p>
<h3 id="完整的代码演示"><a href="#完整的代码演示" class="headerlink" title="完整的代码演示"></a>完整的代码演示</h3><blockquote>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210322170524618.png" alt="image-20210322170524618"></p>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210322184949710.png" alt="image-20210322184949710"></p>
<p>这两行代码不等价, 因为root-&gt;lchild-&gt;rchild(例中的-5节点)有可能是NIL节点, 而某些情况下NIL节点的属性为双黑, NIL-&gt;color = 2.</p>
<p>所以LR/RL类型判断的时候, 不能判断LL子树是否为黑色, LL子树有可能是NIL节点, 在某些特殊情况下, 读到的颜色可能是双重黑, 取而代之的判断方法是[LL子树不是红色]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: red_black_tree.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: Lizimu</span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> color; <span class="comment">// 0 red, 1 black, 2 double black</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">Node __NIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL (&amp;__NIL)</span></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_NIL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NIL-&gt;key = <span class="number">0</span>;</span><br><span class="line">    NIL-&gt;color = <span class="number">1</span>;</span><br><span class="line">    NIL-&gt;lchild = NIL-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    p-&gt;color = <span class="number">0</span>;<span class="comment">//新插入的节点为红色</span></span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = NIL;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">has_red_child</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;lchild-&gt;color == <span class="number">0</span> || root-&gt;rchild-&gt;color == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">left_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;rchild;<span class="comment">//指向旋转以后的根节点地址</span></span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">right_rotate</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;<span class="comment">//指向旋转以后的根节点地址</span></span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">insert_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!has_red_child(root)) <span class="keyword">return</span> root;<span class="comment">//判断是否有红色子孩子</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//利用flag来判断是否存在双红冲突的情况</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; root-&gt;rchild-&gt;color == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">goto</span> insert_end;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;lchild)) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild-&gt;color == <span class="number">0</span> &amp;&amp; has_red_child(root-&gt;rchild)) flag = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span> root;<span class="comment">//没有发生冲突, 直接return</span></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//冲突发生在左子树中, 第一个字母是L</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;rchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//说明需要先进行小左旋</span></span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = right_rotate(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">insert_end:</span><br><span class="line">    root-&gt;color = <span class="number">0</span>;</span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;<span class="comment">//红色上浮, 改成红黑黑</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__insert(Node *root, <span class="keyword">int</span> key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> getNewNode(key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;key == key) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = __insert(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;rchild = __insert(root-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return root;</span></span><br><span class="line">    <span class="keyword">return</span> insert_maintain(root);<span class="comment">//在插入节点的回溯过程中进行插入调整</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//封装一层</span></span><br><span class="line"><span class="function">Node *<span class="title">insert</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    root = __insert(root, key);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">predecessor</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    Node *temp = root-&gt;lchild;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;rchild != NIL) temp = temp-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase_maintain</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color != <span class="number">2</span> &amp;&amp; root-&gt;rchild-&gt;color != <span class="number">2</span>) <span class="keyword">return</span> root;<span class="comment">//表示都不是双重黑, 不用调整</span></span><br><span class="line">    <span class="comment">//找到双重黑节点, 先判断父节点下面有无红色节点, 如果有, 说明双黑节点的兄弟节点是红色</span></span><br><span class="line">    <span class="keyword">if</span> (has_red_child(root)) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//利用flag递归向下处理, 记录旋转方向</span></span><br><span class="line">        root-&gt;color = <span class="number">0</span>;<span class="comment">//原根节点改为红色</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">0</span>) &#123;</span><br><span class="line">            root = right_rotate(root); flag = <span class="number">1</span>;<span class="comment">//flag = 1表示右旋</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = left_rotate(root); flag = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;color = <span class="number">1</span>;<span class="comment">//新的根节点改为黑色</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) root-&gt;rchild = erase_maintain(root-&gt;rchild);</span><br><span class="line">        <span class="keyword">else</span> root-&gt;lchild = erase_maintain(root-&gt;lchild);</span><br><span class="line">        <span class="keyword">return</span> root;<span class="comment">//处理完兄弟节点是红色的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((root-&gt;lchild-&gt;color == <span class="number">2</span> &amp;&amp; !has_red_child(root-&gt;rchild)) ||</span><br><span class="line">        (root-&gt;rchild-&gt;color == <span class="number">2</span> &amp;&amp; !has_red_child(root-&gt;lchild))) &#123;</span><br><span class="line">            root-&gt;lchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">            root-&gt;rchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">            root-&gt;color += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> root;<span class="comment">//处理情况1, 双黑节点的兄弟为黑, 并且两个孩子也都为黑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理情况2/3, 双黑节点的兄弟为黑色, 并且有红色的子孩子</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild-&gt;color == <span class="number">2</span>) &#123;</span><br><span class="line">        root-&gt;lchild-&gt;color -= <span class="number">1</span>;   <span class="comment">//解决双黑, (顺序无讲究)</span></span><br><span class="line">        <span class="comment">//先判断是否需要进行小右旋, 即判断是否是RL情况</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild-&gt;rchild-&gt;color != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//只能这样判断,因为root-&gt;rchild-&gt;rchild有可能是NIL, 某些情况下NIL是双黑NIL-&gt;color=2</span></span><br><span class="line">            <span class="comment">//即当root-&gt;rchild-&gt;rchild不为红色节点时, 肯定为RL情况,</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//不能去判断root-&gt;rchild-&gt;lchild是否为红色来判断是否是RL, </span></span><br><span class="line">            <span class="comment">//因为如果root-&gt;rchild-&gt;rchild为红色, 那不管root-&gt;rchild-lchild是什么颜色,一定是RR情况</span></span><br><span class="line">            root-&gt;rchild-&gt;color = <span class="number">0</span>;</span><br><span class="line">            root-&gt;rchild = right_rotate(root-&gt;rchild);</span><br><span class="line">            root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = left_rotate(root);<span class="comment">//不管是RL还是RR, 一定会有一个大左旋</span></span><br><span class="line">        root-&gt;color = root-&gt;lchild-&gt;color;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;rchild-&gt;color -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild-&gt;lchild-&gt;color != <span class="number">0</span>) &#123;</span><br><span class="line">            root-&gt;lchild-&gt;color = <span class="number">0</span>;<span class="comment">//LR, 先进行小左旋</span></span><br><span class="line">            root-&gt;lchild = left_rotate(root-&gt;lchild);</span><br><span class="line">            root-&gt;lchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root = right_rotate(root);<span class="comment">//右侧双黑, 一定会大右旋</span></span><br><span class="line">        root-&gt;color = root-&gt;rchild-&gt;color;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *__erase(Node *root, <span class="keyword">int</span> key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> NIL;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;lchild = __erase(root-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key) &#123;</span><br><span class="line">        root-&gt;rchild = __erase(root-&gt;rchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//正是要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;</span><br><span class="line">            Node *temp = root-&gt;lchild != NIL ? root-&gt;lchild : root-&gt;rchild;<span class="comment">//找到唯一子孩子</span></span><br><span class="line">            temp-&gt;color += root-&gt;color;<span class="comment">//如果是红色0, 不影响</span></span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;<span class="comment">//删除度为1 / 0的情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node *temp = predecessor(root);</span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line">            root-&gt;lchild == __erase(root-&gt;lchild, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> erase_maintain(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">erase</span><span class="params">(Node *root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    root = __erase(root, key);</span><br><span class="line">    root-&gt;color = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    clear(root-&gt;lchild);</span><br><span class="line">    clear(root-&gt;rchild);</span><br><span class="line">    clear(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d| %d, %d, %d)\n&quot;</span>,</span><br><span class="line">          root-&gt;color, root-&gt;key,</span><br><span class="line">          root-&gt;lchild-&gt;key,</span><br><span class="line">          root-&gt;rchild-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == NIL) <span class="keyword">return</span> ;</span><br><span class="line">    print(root);</span><br><span class="line">    output(root-&gt;lchild);</span><br><span class="line">    output(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op, val;</span><br><span class="line">    Node *root = NIL;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;val)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: root = insert(root, val); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: root = erase(root, val); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(root);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210322155744704.png" alt="image-20210322155744704" style="zoom:25%;" /><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210322155801248.png" alt="image-20210322155801248" style="zoom:25%;" /><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210322160055170.png" alt="image-20210322160055170" style="zoom:25%;" /></p>
<p><strong>删除节点3,会发生什么?</strong></p>
<p> NIL标记为双重黑</p>
<p>站在节点2, 右子树双黑, 左子树黑色, 情况1</p>
<p>NIL减一重黑, 节点1变为红色, 根节点2加一重黑, 变为双重黑, 又因为节点2为根节点, 最后会强制变为黑色</p>
<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210322164030726.png" alt="image-20210322164030726" style="zoom:25%;" />

<p><strong>插入-5, 此时再删除节点3, 会发生什么过程?</strong></p>
<ul>
<li>发生LL类型失衡<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210322164536317.png" alt="image-20210322164536317" style="zoom:25%;" />, 需要进行<code>大右旋</code>, 然后新根改为原根节点的颜色, 两个子孩子改为黑色</li>
</ul>
<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210323210932883.png" alt="image-20210323210932883" style="zoom:50%;" />

<p><strong>插入-4节点, 再删除2</strong></p>
<p><img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210323220148938.png" alt="image-20210323220148938"></p>
<img src="https://mkdimg.oss-cn-shanghai.aliyuncs.com/image-20210323220339190.png" alt="image-20210323220339190" style="zoom: 50%;" />]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>进阶</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构(完结)</title>
    <url>/2021/03/10/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%AE%8C%E7%BB%93)/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>结构定义+结构操作</p>
<p>定义一种性质,并且维护这种性质的结构就叫数据结构.</p>
<h2 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h2><blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201225100351405.png" alt="image-20201225100351405"></p>
</blockquote>
<h2 id="realloc-malloc-和-canlloc的区别"><a href="#realloc-malloc-和-canlloc的区别" class="headerlink" title="realloc malloc 和 canlloc的区别"></a>realloc malloc 和 canlloc的区别</h2><blockquote>
<p>三个函数的申明分别是:<br>void* realloc(void* ptr, unsigned newsize);<br>void* malloc(unsigned size);<br>void* calloc(size_t numElements, size_t sizeOfElement);<br>都在stdlib.h函数库内</p>
<p>它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL</p>
<p>malloc用于申请一段新的地址,参数size为需要内存空间的长度,如:<br>char* p;<br>p=(char*)malloc(20);</p>
<p>calloc与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数,如:<br>char* p;<br>p=(char*)calloc(20,sizeof(char));<br>这个例子与上一个效果相同</p>
<p>realloc是给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度real</p>
<p>realloc如果申请成功,会拷贝原数据的,并且进行清空</p>
<p>如:<br>char* p;<br>p=(char*)malloc(sizeof(char)<em>20);<br>p=(char</em>)realloc(p,sizeof(char)*40);</p>
<p>注意，这里的空间长度都是以字节为单位。</p>
<p>C语言的标准内存分配函数：malloc，calloc，realloc，free等。<br>malloc与calloc的区别为1块与n块的区别：<br>malloc调用形式为(类型*)malloc(size)：在内存的动态存储区中分配一块长度为“size”字节的连续区域，返回该区域的首地址。<br>calloc调用形式为(类型*)calloc(n，size)：在内存的动态存储区中分配n块长度为“size”字节的连续区域，返回首地址。<br>realloc调用形式为(类型*)realloc(*ptr，size)：将ptr内存大小增大到size。</p>
<p>free的调用形式为free(void*ptr)：释放ptr所指向的一块内存空间。<br>C++中为new/delete函数。</p>
</blockquote>
<h1 id="线性表基础"><a href="#线性表基础" class="headerlink" title="线性表基础"></a>线性表基础</h1><h2 id="顺序表的构造、插入、扩容"><a href="#顺序表的构造、插入、扩容" class="headerlink" title="顺序表的构造、插入、扩容"></a>顺序表的构造、插入、扩容</h2><p>首先我们要学习的是插入操作，如果顺序表是空的，我们需要往顺序表中插入元素后才能进行其它的操作。</p>
<p>顺序表插入操作需要实现的函数如下：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">insert(loc, value)</td>
<td align="center">将 value 插入到顺序表中下标为loc的位置</td>
</tr>
</tbody></table>
<p>顺序表插入操作的实现方法如下：</p>
<ol>
<li>判断插入位置是否合法。</li>
<li>判断顺序表是否已满。</li>
<li>将目标位置及之后的元素后移一位。</li>
<li>将待插入的元素值插入到目标位置。</li>
</ol>
<p>在新元素要插入到顺序表中时，如果顺序表已经满了，我们就需要利用顺序表的扩容操作来为它开辟一块更大的内存空间。</p>
<p>顺序表扩容操作需要实现的函数如下：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">expand()</td>
<td align="center">扩大顺序表的容量</td>
</tr>
</tbody></table>
<p>顺序表扩容操作的实现方法如下：</p>
<ol>
<li>将原来的元素存储到临时存储空间。</li>
<li>扩大原来的存储空间。</li>
<li>将临时存储空间里的数据元素复制到新的存储空间里。</li>
<li>释放临时的存储空间。</li>
</ol>
<p>==需要先把内容复制到临时存储空间中，所以时间复杂度为O(n)==</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><blockquote>
<p>每次扩容，都是将容量修改为之前的2倍；</p>
<p>扩容时，要重新开辟一块空间，并且将原有的数据拷贝进去，再讲原有的空间删除</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">data = <span class="keyword">new</span> Type[size];  <span class="comment">//新开辟一个空间</span></span><br><span class="line"><span class="keyword">delete</span>[] old_data;   <span class="comment">//删除原有的空间</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>malloc</p>
<p>calloc   在堆区申请空间后并清空为0</p>
<p>realloc   重新申请空间，如果申请不到，会返回0，造成地址泄露</p>
<p>都返回新申请空间的首地址单元</p>
</blockquote>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210127113143785.png" alt="image-20210127113143785"></p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><blockquote>
<p>1、找到链表中需要插入的位置</p>
<p>2、令待插入结点的next指针指向待插入位置</p>
<p>3、令插入位置之前的结点的next指针指向待插入结点</p>
</blockquote>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><blockquote>
<p>output()   输出整个链表</p>
<p>1、定义一个用于遍历的变量；</p>
<p>2、输入遍历变量所在结点的值，并且更新变量的值为下一个结点；</p>
<p>3、重复操作，直到遍历完所有节点</p>
</blockquote>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>》。</p>
<h2 id="链表的原地反转"><a href="#链表的原地反转" class="headerlink" title="链表的原地反转"></a>链表的原地反转</h2><blockquote>
<p>原地头插法 O（1）</p>
<p>见代码reverse</p>
</blockquote>
<h2 id="如何实现双向链表-单向循环链表"><a href="#如何实现双向链表-单向循环链表" class="headerlink" title="如何实现双向链表  单向循环链表"></a>如何实现双向链表  单向循环链表</h2><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210209113030605.png" alt="image-20210209113030605"></p>
<h2 id="双指针-快慢指针"><a href="#双指针-快慢指针" class="headerlink" title="双指针,快慢指针"></a>双指针,快慢指针</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210210145600840.png" alt="image-20210210145600840"></p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210217194603961.png" alt="image-20210217194603961"></p>
<p>注意: null空节点无法添加前驱,所以删除以及插入的时候需要注意</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210217202334285.png" alt="image-20210217202334285"></p>
<p>插入时, 在0个节点处插入,前驱无法添加</p>
<p>所以当是空地址时,不需要添加前驱:   添加特判</p>
</blockquote>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote>
<p>先进先出FIFO</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210217212941159.png" alt="image-20210217212941159"></p>
<p>需要一片连续的存储空间来当==队列==的容器</p>
<p>出队: 队首元素 head + 1</p>
<p>入队: tail + 1, tail后移一位,新的元素就插入在新的tail指针处</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210217214029293.png" alt="image-20210217214029293"></p>
</blockquote>
<h2 id="队列-假溢出"><a href="#队列-假溢出" class="headerlink" title="队列-假溢出"></a>队列-假溢出</h2><blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210217214628778.png" alt="image-20210217214628778"></p>
<p>无法插入第10个元素,但实际上队列并没有满. 前面还有三个空位置</p>
<p>如何解决? 将tail指针移到队伍最前面</p>
<p>​        取模运算: (tail + 1 ) % length</p>
</blockquote>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><blockquote>
<p>针对假溢出问题产生的新的队列</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210217215052844.png" alt="image-20210217215052844"></p>
<p>如何判断循环队列已经满?如何判空?</p>
<p>​        增加额外字段count(因为tail不一定&gt;head)</p>
</blockquote>
<h2 id="队列的代码实现"><a href="#队列的代码实现" class="headerlink" title="队列的代码实现"></a>队列的代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 4.queue.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Wed 17 Feb 2021 10:07:19 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;<span class="comment">//一片连续的存储空间</span></span><br><span class="line">    <span class="keyword">int</span> head, tail;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue *q = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    q-&gt;length = n;</span><br><span class="line">    q-&gt;head = q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;head == q-&gt;tail;<span class="comment">//如果对手指针和队尾指针重合,即为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *q, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;tail == q-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//判断队列满</span></span><br><span class="line">    q-&gt;data[q-&gt;tail++] = val;</span><br><span class="line">    <span class="comment">//q-&gt;tail += 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;head += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Queue : [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = q-&gt;head, j = <span class="number">0</span>; i &lt; q-&gt;tail; i++, j++) &#123;</span><br><span class="line">        <span class="function">j &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 20</span></span><br><span class="line">    Queue *q = init(MAX_OP);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, val;</span><br><span class="line">        op = rand() % <span class="number">4</span>;</span><br><span class="line">        val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the queue = %d\n&quot;</span>, val, push(q, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!empty(q)) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;pop %d from the queue = &quot;</span>, front(q));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pop(q));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(q), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210221110834325.png" alt="image-20210221110834325"></p>
<h2 id="循环队列的实现"><a href="#循环队列的实现" class="headerlink" title="循环队列的实现"></a>循环队列的实现</h2><blockquote>
<p>上述2.中的代码会出现假溢出的问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210221111002936.png" alt="image-20210221111002936"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 4.queue.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Wed 17 Feb 2021 10:07:19 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;<span class="comment">//一片连续的存储空间</span></span><br><span class="line">    <span class="keyword">int</span> head, tail, count;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue *q = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    q-&gt;length = n;</span><br><span class="line">    q-&gt;head = q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;count == <span class="number">0</span>;<span class="comment">//通过count判空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *q, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;count == q-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//判断队列满</span></span><br><span class="line">    q-&gt;data[q-&gt;tail++] = val;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;tail == q-&gt;length) q-&gt;tail = <span class="number">0</span>;<span class="comment">//实现循环</span></span><br><span class="line">    <span class="comment">//q-&gt;tail += 1;</span></span><br><span class="line">    q-&gt;count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;head += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;head == q-&gt;length) q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Queue : [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = q-&gt;head, j = <span class="number">0</span>; j &lt; q-&gt;count; j++) &#123;</span><br><span class="line">        <span class="function">j &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q-&gt;data[(i+j) % q-&gt;length]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 20</span></span><br><span class="line">    Queue *q = init(MAX_OP);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, val;</span><br><span class="line">        op = rand() % <span class="number">4</span>;</span><br><span class="line">        val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the queue = %d\n&quot;</span>, val, push(q, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!empty(q)) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;pop %d from the queue = &quot;</span>, front(q));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pop(q));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(q), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环队列的扩容"><a href="#循环队列的扩容" class="headerlink" title="循环队列的扩容"></a>循环队列的扩容</h2><h3 id="使用realloc扩容-会出现问题"><a href="#使用realloc扩容-会出现问题" class="headerlink" title="使用realloc扩容,会出现问题"></a>使用realloc扩容,会出现问题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 4.queue.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Wed 17 Feb 2021 10:07:19 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR(a,b) <span class="meta-string">&quot;\033[&quot;</span> #b <span class="meta-string">&quot;m&quot;</span> a <span class="meta-string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN(a) COLOR(a, 32)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;<span class="comment">//一片连续的存储空间</span></span><br><span class="line">    <span class="keyword">int</span> head, tail, count;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Queue *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Queue *q = (Queue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    q-&gt;length = n;</span><br><span class="line">    q-&gt;head = q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;count == <span class="number">0</span>;<span class="comment">//通过count判空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[q-&gt;head];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = q-&gt;length;<span class="comment">//等于原来的容量</span></span><br><span class="line">    <span class="keyword">int</span> *temp;<span class="comment">//临时记录扩容返回的地址</span></span><br><span class="line">    <span class="keyword">while</span> (extr_size) &#123;</span><br><span class="line">        temp = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(q-&gt;data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (q-&gt;length + extr_size));</span><br><span class="line">        <span class="keyword">if</span> (temp) <span class="keyword">break</span>;</span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>;<span class="comment">// 到了这一行,说明扩容失败, 除以2  适当降低要求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//说明扩容失败</span></span><br><span class="line">    q-&gt;data = temp;<span class="comment">//到这一行说明扩容成功</span></span><br><span class="line">    q-&gt;length += extr_size;</span><br><span class="line">    <span class="built_in">printf</span>(GREEN(<span class="string">&quot;expand successfully! the new size = %d\n&quot;</span>), q-&gt;length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Queue *q, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;count == q-&gt;length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!expand(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="comment">//判断队列满</span></span><br><span class="line">    q-&gt;data[q-&gt;tail++] = val;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;tail == q-&gt;length) q-&gt;tail = <span class="number">0</span>;<span class="comment">//实现循环</span></span><br><span class="line">    <span class="comment">//q-&gt;tail += 1;</span></span><br><span class="line">    q-&gt;count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;head += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;head == q-&gt;length) q-&gt;head = <span class="number">0</span>;</span><br><span class="line">    q-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Queue : [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = q-&gt;head, j = <span class="number">0</span>; j &lt; q-&gt;count; j++) &#123;</span><br><span class="line">        <span class="function">j &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, q-&gt;data[(i+j) % q-&gt;length]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Queue *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 30</span></span><br><span class="line">    Queue *q = init(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, val;</span><br><span class="line">        op = rand() % <span class="number">4</span>;</span><br><span class="line">        val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the queue = %d\n&quot;</span>, val, push(q, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!empty(q)) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;pop %d from the queue = &quot;</span>, front(q));</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pop(q));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(q), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210222142452748.png" alt="image-20210222142452748"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210222142816522.png" alt="image-20210222142816522"></p>
<blockquote>
<p>队列中间会出现很多0,</p>
<p>realloc拷贝值的时候,会按照存储数据的值拷贝  所以循环队列有可能会出现问题</p>
</blockquote>
<h3 id="使用malloc进行扩容操作"><a href="#使用malloc进行扩容操作" class="headerlink" title="使用malloc进行扩容操作"></a>使用malloc进行扩容操作</h3><blockquote>
<p>需要手动进行值的拷贝</p>
</blockquote>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="结构定义与结构操作"><a href="#结构定义与结构操作" class="headerlink" title="结构定义与结构操作"></a>结构定义与结构操作</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210222152626082.png" alt="image-20210222152626082"></p>
<blockquote>
<p>top 栈顶指针: 记录整个栈最上面元素的位置</p>
<p>出栈 :   栈顶指针向下走一步,指向新的元素  栈顶指针-1即可</p>
<p>栈可以解决==完全包含问题==</p>
<p>系统栈也是栈, 但是默认大小只有8Mb</p>
<p>练习题</p>
<p>oj 263 265 266 267 268</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210222164448945.png" alt="image-20210222164448945"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210222164227033.png" alt="image-20210222164227033"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210222152833883.png" alt="image-20210222152833883"></p>
<p>入栈: 栈顶指针top+1,然后将新元素插入到当前top指针的位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210222155658404.png" alt="image-20210222155658404"></p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 5.stack.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Mon 22 Feb 2021 04:48:35 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> size, top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack *<span class="title">init_stack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Stack *s = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    s-&gt;size = n;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;<span class="comment">//初始化时候,下标为-1,因为栈从0开始</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> extr_size = s-&gt;size;</span><br><span class="line">    <span class="keyword">int</span> *temp;</span><br><span class="line">    <span class="comment">/*while (extr_size) &#123;</span></span><br><span class="line"><span class="comment">        temp = (int *)malloc(sizeof(int) * (s-&gt;size + extr_size));</span></span><br><span class="line"><span class="comment">        if (temp) break;</span></span><br><span class="line"><span class="comment">        extr_size&gt;&gt;=1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if (temp == NULL) return 0;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; s-&gt;size; i++) &#123;</span></span><br><span class="line"><span class="comment">        temp[i] = s-&gt;data[i];    </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    free(s-&gt;data);</span></span><br><span class="line"><span class="comment">    s-&gt;data = temp;</span></span><br><span class="line"><span class="comment">    s-&gt;size = s-&gt;size + extr_size;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (extr_size) &#123;</span><br><span class="line">        temp = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(s-&gt;data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (s-&gt;size + extr_size));</span><br><span class="line">        <span class="keyword">if</span> (temp) <span class="keyword">break</span>;</span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;data = temp;<span class="comment">//别忘了更新新的数据地址</span></span><br><span class="line">    s-&gt;size += extr_size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;successfully expand. the new size is %d\n&quot;</span>, s-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//最后也别忘了</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Stack *s, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == s-&gt;size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!expand(s)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//只有扩容失败,才返回0;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s-&gt;top += 1;</span></span><br><span class="line">    <span class="comment">//s-&gt;data[s-&gt;top] = val;</span></span><br><span class="line">    s-&gt;data[++(s-&gt;top)] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(s)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//栈为空,也无法出栈</span></span><br><span class="line">    s-&gt;top -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack : [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s-&gt;top; i++) &#123;</span><br><span class="line">        <span class="function">i &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, s-&gt;data[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 40</span></span><br><span class="line">    Stack *s = init_stack(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, val;</span><br><span class="line">        op = rand() % <span class="number">4</span>;</span><br><span class="line">        val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the stack = %d\n&quot;</span>, val, push(s, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pop %d from the Stack = &quot;</span>, top(s));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pop(s));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(s), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 6.LinkStack.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Mon 22 Feb 2021 06:23:09 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> &#123;</span></span><br><span class="line">    StackNode *top;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; LinkStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(StackNode *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StackNode *<span class="title">init_node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    StackNode *p = (StackNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkStack *<span class="title">init_stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkStack *l = (LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">    l-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    l-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(LinkStack *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l-&gt;top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack_top</span><span class="params">(LinkStack *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (empty(l)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> l-&gt;top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(LinkStack *l, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    StackNode *node = init_node(val);</span><br><span class="line">    <span class="comment">//l-&gt;top-&gt;next = node;</span></span><br><span class="line">    node-&gt;next = l-&gt;top;</span><br><span class="line"></span><br><span class="line">    l-&gt;top = node;</span><br><span class="line">    l-&gt;length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(LinkStack *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(l)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    StackNode *p = l-&gt;top;</span><br><span class="line">    l-&gt;top = p-&gt;next;</span><br><span class="line">    clear_node(p);</span><br><span class="line">    l-&gt;length -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(LinkStack *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LinkStack(%d) : [&quot;</span>, l-&gt;length);</span><br><span class="line">    <span class="keyword">for</span> (StackNode *p = l-&gt;top; p; p = p-&gt;next) &#123;</span><br><span class="line">        p != l-&gt;top &amp;&amp; <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);<span class="comment">//当p不等于l-&gt;top时, </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(StackNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(LinkStack *l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    StackNode *p = l-&gt;top, *q;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        clear_node(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(l);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 20</span></span><br><span class="line">    LinkStack *s = init_stack();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> op, val;</span><br><span class="line">        op = rand() % <span class="number">4</span>;</span><br><span class="line">        val = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;push %d to the LinkStack = %d\n&quot;</span>, val, push(s, val));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;pop %d from the LinkStack = &quot;</span>, Stack_top(s));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pop(s));</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        output(s), <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210222203937260.png" alt="image-20210222203937260"></p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的含义：节点和边"><a href="#树的含义：节点和边" class="headerlink" title="树的含义：节点和边"></a>树的含义：节点和边</h2><blockquote>
<p>全集是子节点的并集</p>
<p>树也可以解决具有完全包含关系的问题</p>
<p>树的遍历需要借助栈</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208133839997.png" alt="image-20210208133839997"></p>
<h2 id="树的结构定义"><a href="#树的结构定义" class="headerlink" title="树的结构定义"></a>树的结构定义</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208134255954.png" alt="image-20210208134255954"></p>
<blockquote>
<p>链表向树的转化：树比链表==多了==几个next指针</p>
</blockquote>
<h2 id="树的深度，高度和度"><a href="#树的深度，高度和度" class="headerlink" title="树的深度，高度和度"></a>树的深度，高度和度</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208134530989.png" alt="image-20210208134530989"></p>
<blockquote>
<p>度：当前节点底下有几个子节点</p>
</blockquote>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="==二叉树=="></a>==二叉树==</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208135308774.png" alt="image-20210208135308774"><br>二叉树能将一个不确定的n叉树转化成二叉树的表现形式</p>
<h3 id="如何将一个n叉树转化为二叉树？"><a href="#如何将一个n叉树转化为二叉树？" class="headerlink" title="如何将一个n叉树转化为二叉树？"></a>如何将一个n叉树转化为二叉树？</h3><blockquote>
<p>==“左孩子右兄弟”表示法==</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208135638504.png" alt="image-20210208135638504"></p>
<p>![image-20210222225522151](<a href="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210222225522151.pn">https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210222225522151.pn</a> g)</p>
<p>n0 = n2 + 1;</p>
</blockquote>
<h3 id="二叉树-遍历"><a href="#二叉树-遍历" class="headerlink" title="二叉树-遍历"></a>二叉树-遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208140352091.png" alt="image-20210208140352091"></p>
<blockquote>
<p>前序遍历：1–2-4-5–3-6</p>
<p>中序遍历：4-2-5–1–3-6</p>
<p>后序遍历：4-5-2–6-3–1</p>
</blockquote>
<h3 id="二叉树的中国表示与国际表示"><a href="#二叉树的中国表示与国际表示" class="headerlink" title="二叉树的中国表示与国际表示"></a>二叉树的中国表示与国际表示</h3><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208141202075.png" alt="image-20210208141202075"  />

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208141239762.png" alt="image-20210208141239762"></p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208141354404.png" alt="image-20210208141354404"></p>
<h2 id="二叉树的-广义表"><a href="#二叉树的-广义表" class="headerlink" title="二叉树的==广义表=="></a>二叉树的==广义表==</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208141802044.png" alt="image-20210208141802044"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208142035429.png" alt="image-20210208142035429"></p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210208142133972.png" alt="image-20210208142133972"></p>
<h2 id="二叉排序树-二叉查找树"><a href="#二叉排序树-二叉查找树" class="headerlink" title="二叉排序树(二叉查找树)"></a>二叉排序树(二叉查找树)</h2><blockquote>
<p>对于任何一个根节点, 当前根节点的值要大于左子树的值,小于右子树的值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 7.binary_tree.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Tue 23 Feb 2021 12:08:31 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">getNewTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tree *tree = (Tree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入完一个数后,返回根节点的地址</span></span><br><span class="line"><span class="function">Node *<span class="title">insert_node</span><span class="params">(Node *root, <span class="keyword">int</span> val,  <span class="keyword">int</span> *flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getNewNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data &gt; val) root-&gt;lchild = insert_node(root-&gt;lchild, val, flag);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = insert_node(root-&gt;rchild, val, flag);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Tree *tree, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//定义一个标记量, 因为并不是每次插入都能成功</span></span><br><span class="line">    tree-&gt;root = insert_node(tree-&gt;root, val, &amp;flag);</span><br><span class="line">    tree-&gt;length += flag;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    pre_order_node(root-&gt;lchild);</span><br><span class="line">    pre_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pre_order : &quot;</span>);</span><br><span class="line">    pre_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    in_order_node(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    in_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;<span class="comment">//中序遍历, 先遍历左子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in_order : &quot;</span>);</span><br><span class="line">    in_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    post_order_node(root-&gt;lchild);</span><br><span class="line">    post_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> ;<span class="comment">//后序遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;post_order : &quot;</span>);</span><br><span class="line">    post_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">    output_node(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    output_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tree(%d) : &quot;</span>, tree-&gt;length);</span><br><span class="line">    output_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear_node(node-&gt;lchild);</span><br><span class="line">    clear_node(node-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear_node(tree-&gt;root);<span class="comment">//调用递归,沿着根节点向下回收</span></span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    Tree *tree = getNewTree();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        insert(tree, val);</span><br><span class="line">        output(tree);<span class="comment">//以广义表的形式输出;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    pre_order(tree);</span><br><span class="line">    in_order(tree);</span><br><span class="line">    post_order(tree);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210223144458618.png" alt="image-20210223144458618"></p>
<blockquote>
<p>对于排序二叉树而言,中序遍历是从小到大有序排列的 </p>
</blockquote>
<h2 id="广义表转二叉树-利用栈"><a href="#广义表转二叉树-利用栈" class="headerlink" title="广义表转二叉树(利用栈)"></a>广义表转二叉树(利用栈)</h2><blockquote>
<p>遇到 ( , ＋1操作, 遇到 ) , -1操作</p>
<p>使用flag标记逗号</p>
<p>​    当遇到( , 将上一个点入栈 </p>
<p>​    加下来如果不是,也不是括号,则将B封装成一个节点</p>
<p>​    当遇到, 标记一下, 下一个遇到的元素是上一个元素的右孩子</p>
<p>​    当遇到一个), 建立关系,弹出栈顶元素</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 8.table_to_tree.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Tue 23 Feb 2021 04:55:07 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    Node *root;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    Node **data;<span class="comment">//栈中存放的是node *(地址);</span></span><br><span class="line">    <span class="keyword">int</span> top, size;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">getNewNode</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;data = val;</span><br><span class="line">    p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree *<span class="title">getNewTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tree *tree = (Tree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    tree-&gt;root = <span class="literal">NULL</span>;</span><br><span class="line">    tree-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack *<span class="title">init_stack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Stack *s = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">    s-&gt;data = (Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node *) * n);</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    s-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">top</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(Stack *s, Node *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == s-&gt;size - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;data[++(s-&gt;top)] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    s-&gt;top -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_stack</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear_node(root-&gt;lchild);</span><br><span class="line">    clear_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">free</span>(root);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_tree</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    clear_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">free</span>(tree);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    pre_order_node(root-&gt;lchild);</span><br><span class="line">    pre_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pre_order(%d) : &quot;</span>, tree-&gt;length);</span><br><span class="line">    pre_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    in_order_node(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    in_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in_order(%d) : &quot;</span>, tree-&gt;length);</span><br><span class="line">    in_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_node</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    post_order_node(root-&gt;lchild);</span><br><span class="line">    post_order_node(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order</span><span class="params">(Tree *tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;post_order(%d) : &quot;</span>, tree-&gt;length);</span><br><span class="line">    post_order_node(tree-&gt;root);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> *node_num)</span> </span>&#123;</span><br><span class="line">    Stack *s = init_stack(<span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    Node *temp = <span class="literal">NULL</span>, *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (str[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: &#123;</span><br><span class="line">                push(s, temp);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: &#123;</span><br><span class="line">                p = top(s);</span><br><span class="line">                pop(s);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>: &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="comment">//说明遇到需要构建节点的元素 </span></span><br><span class="line">                temp = getNewNode(str[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!empty(s) &amp;&amp; flag == <span class="number">0</span>) &#123;</span><br><span class="line">                top(s)-&gt;lchild = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!empty(s) &amp;&amp; flag == <span class="number">1</span>) &#123;</span><br><span class="line">                top(s)-&gt;rchild = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            ++(*node_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        ++str;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    clear_stack(s);</span><br><span class="line">    <span class="keyword">if</span> (temp &amp;&amp; !p) p = temp;<span class="comment">//如果temp不为空,并且p为空//即只有一个元素的广义表</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> node_num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, str);</span><br><span class="line">    getchar();</span><br><span class="line">    Tree *tree = getNewTree();</span><br><span class="line">    tree-&gt;root = build(str, &amp;node_num);<span class="comment">//将node_num作为传出参数;</span></span><br><span class="line">    tree-&gt;length = node_num;</span><br><span class="line">    pre_order(tree);</span><br><span class="line">    in_order(tree);</span><br><span class="line">    post_order(tree);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210223180754188.png" alt="image-20210223180754188"></p>
<h1 id="排序与查找"><a href="#排序与查找" class="headerlink" title="排序与查找"></a>排序与查找</h1><h2 id="稳定排序-插入-冒泡-归并"><a href="#稳定排序-插入-冒泡-归并" class="headerlink" title="稳定排序: 插入 冒泡 归并"></a>稳定排序: 插入 冒泡 归并</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 9.stable_sort.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Tue 23 Feb 2021 09:46:01 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(arr, n, func, args...) &#123;\</span></span><br><span class="line">    <span class="keyword">int</span> *num = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);\</span><br><span class="line">    <span class="built_in">memcpy</span>(num, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s= &quot;</span>, <span class="meta">#func);\</span></span><br><span class="line">    func(args);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    <span class="built_in">free</span>(num);\</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">void</span> insert_sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; num[j] &lt; num[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(num[j], num[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> bubble_sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">1</span>;<span class="comment">//用times来进行优化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; times; i++) &#123;</span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i; j++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (num[j] &gt; num[j + 1]) &#123;</span></span><br><span class="line"><span class="comment">                swap(num[j], num[j + 1]);</span></span><br><span class="line"><span class="comment">            &#125;减少缩进,增加代码可读性*/</span></span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt;= num[j + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            swap(num[j], num[j + <span class="number">1</span>]);</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用递归实现分治递归</span></span><br><span class="line"><span class="keyword">void</span> merge_sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="comment">//从l到r这个位置进行归并排序</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//即当前区间内存在两个以内的元素,可以排序</span></span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span> &amp;&amp; num[r] &lt; num[l]) &#123;</span><br><span class="line">            <span class="comment">//说明区间就两个元素,并且后面比前面小</span></span><br><span class="line">            swap(num[r], num[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始二路归并 nlogn</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(num, l, mid);</span><br><span class="line">    merge_sort(num, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//mid左右两边已经是有序的了</span></span><br><span class="line">    <span class="comment">//开始复制到temp数组里面</span></span><br><span class="line">    <span class="keyword">int</span> *temp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (r - l + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= mid || p2 &lt;= r) &#123;</span><br><span class="line">        <span class="comment">//说明左右两端数组至少有一个是还有元素的</span></span><br><span class="line">        <span class="keyword">if</span> (p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) &#123;</span><br><span class="line">            temp[k++] = num[p1++];<span class="comment">//说明p1的值小一点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = num[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行拷贝操作,将temp拷贝到num+l位置下</span></span><br><span class="line">    <span class="built_in">memcpy</span>(num + l, temp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (r - l + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> randint(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">while</span> (n--) arr[n] = rand() % <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> output(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        i &amp;&amp; <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_N 20</span></span><br><span class="line">    <span class="keyword">int</span> arr[MAX_N];</span><br><span class="line">    randint(arr, MAX_N);</span><br><span class="line">    TEST(arr, MAX_N, insert_sort, num, MAX_N);</span><br><span class="line">    TEST(arr, MAX_N, bubble_sort, num, MAX_N);</span><br><span class="line">    TEST(arr, MAX_N, merge_sort, num, <span class="number">0</span>, MAX_N - <span class="number">1</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_N</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210223203751593.png" alt="image-20210223203751593"></p>
<blockquote>
<p>时间复杂度: O(n^2^)   </p>
</blockquote>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210223205631444.png" alt="image-20210223205631444"></p>
<blockquote>
<p>时间复杂度: O(n^2^)</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210223210449130.png" alt="image-20210223210449130"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210223221922110.png" alt="image-20210223221922110"></p>
<blockquote>
<p>减少缩进,增加代码可读性</p>
</blockquote>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote>
<h2 id="核心思想：分治"><a href="#核心思想：分治" class="headerlink" title="核心思想：分治"></a>核心思想：分治</h2><p>时间复杂度：nlogn</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210223213403927.png" alt="image-20210223213403927"></p>
<p>m1+m2+n1+n2 = m + n  = k;</p>
<p>一共有logk层</p>
<p>两个指针p1和p2, 谁小谁就先拷贝到原队列中, 然后指针++</p>
<p>每一层都操作了k个元素, 一共有logk层, 所以时间复杂度为 O(nlogn)</p>
<p>可以采用递归      </p>
</blockquote>
<blockquote>
<p>归并排序是外部排序: 假如有8G的数据,但是内存只有2G,这时候可以利用归并排序,将数据分为4份, 分别是2G, 最后再分别进行拷贝</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210224135229614.png" alt="image-20210224135229614"></p>
<h2 id="………………………………………"><a href="#………………………………………" class="headerlink" title="……………………………………….."></a>………………………………………..</h2><h2 id="不稳定排序-选择-快速排序"><a href="#不稳定排序-选择-快速排序" class="headerlink" title="不稳定排序: 选择 快速排序"></a>不稳定排序: 选择 快速排序</h2><blockquote>
<p>内部排序: 需要将待排序一次性加载到内存中</p>
<p>外部排序: 与内部排序相反(归并排序)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 10.unstable_sort.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Wed 24 Feb 2021 02:44:43 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(arr, n, func, args...) &#123;\</span></span><br><span class="line">    <span class="keyword">int</span> *num = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);\</span><br><span class="line">    <span class="built_in">memcpy</span>(num, arr, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s= &quot;</span>, <span class="meta">#func);\</span></span><br><span class="line">    func(args);\</span><br><span class="line">    output(num, n);\</span><br><span class="line">    <span class="built_in">free</span>(num);\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> select_sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[ind] &gt; num[j]) ind = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(num[i], num[ind]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*void quick_sort(int *num, int l, int r) &#123;</span></span><br><span class="line"><span class="comment">    //对于num数组.从l到r之间的元素进行排序</span></span><br><span class="line"><span class="comment">    if (l &gt; r) return ;//递归的边界条件</span></span><br><span class="line"><span class="comment">    int x = l, y = r, z = num[x];//z为基准值</span></span><br><span class="line"><span class="comment">    while (x &lt; y) &#123;</span></span><br><span class="line"><span class="comment">        while (x &lt; y &amp;&amp; num[y] &gt; z) y--;//找到第一个小于基准值的值</span></span><br><span class="line"><span class="comment">        if (x &lt; y) num[x++] = num[y];</span></span><br><span class="line"><span class="comment">        while (x &lt; y &amp;&amp; num[x] &lt; z) x++;</span></span><br><span class="line"><span class="comment">        if (x &lt; y) num[y--] = num[x];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    num[x] = z;//此时头尾指针重合,放置基准值</span></span><br><span class="line"><span class="comment">    quick_sort(num, l, x - 1);//分别从l到基准值再分别进行快速排序</span></span><br><span class="line"><span class="comment">    quick_sort(num, x + 1, r);</span></span><br><span class="line"><span class="comment">    return ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//用单边递归对快排进行优化</span></span><br><span class="line"><span class="keyword">void</span> quick_sort(<span class="keyword">int</span> *num, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = l, y = r, z = num[(l + r) &gt;&gt; <span class="number">1</span>];<span class="comment">//基准值可以使用任何一个值</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num[x] &lt; z) x++;</span><br><span class="line">            <span class="keyword">while</span> (num[y] &gt; z) y--;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= y) &#123;</span><br><span class="line">                swap(num[x], num[y]);</span><br><span class="line">                x++, y--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x &lt;= y);</span><br><span class="line">        quick_sort(num, l, y);<span class="comment">//对左侧快排 单边递归</span></span><br><span class="line">        l = x;<span class="comment">//右侧循环</span></span><br><span class="line">    &#125;<span class="comment">//单边递归进行优化</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> randint(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">while</span> (n--) arr[n] = rand() % <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> output(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        i &amp;&amp; <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_N 20</span></span><br><span class="line">    <span class="keyword">int</span> arr[MAX_N];</span><br><span class="line">    randint(arr, MAX_N);</span><br><span class="line">    TEST(arr, MAX_N, select_sort, num, MAX_N);</span><br><span class="line">    TEST(arr, MAX_N, quick_sort, num, <span class="number">0</span>,MAX_N - <span class="number">1</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_N</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210224141850387.png" alt="image-20210224141850387"></p>
<blockquote>
<p>第一次交换: 3 与 10 进行交换</p>
<p>交换之后, 已排序区元素数 + 1, 待排序区元素数 - 1;</p>
</blockquote>
<blockquote>
<p>选择/冒泡/插入排序的时间复杂度都是O(n^2^);</p>
<p>选择排序更节省一点时间, 因为每一轮交换的次数只有一次</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210224152300963.png" alt="image-20210224152300963"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote>
<p>时间复杂度 O(nlogn)</p>
<p>但很有可能退化成O(n^2^);</p>
</blockquote>
<blockquote>
<p>以待排序区间的第一个值作为基准值</p>
<p>先去移动尾指针, 从后往前找, 找到第一个&lt;=基准值的值, </p>
<p>进行一次partition排序后, 数据会基本有序: 基准值前面的值都&lt;=基准值, 基准值后面的值都&gt;= 基准值</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210224153503926.png" alt="image-20210224153503926"></p>
<blockquote>
<p>对快排进行优化, 无监督的快排</p>
<ol>
<li>单边递归</li>
<li>基准值的优化, 可以使用任意值</li>
<li>有监督 &gt; 无监督<ol>
<li>取消监督是否x&lt;y : while改成do while</li>
</ol>
</li>
</ol>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210224154551268.png" alt="image-20210224154551268"></p>
<h1 id="查找算法与哈希表"><a href="#查找算法与哈希表" class="headerlink" title="查找算法与哈希表"></a>查找算法与哈希表</h1><h2 id="二分查找与三分查找"><a href="#二分查找与三分查找" class="headerlink" title="二分查找与三分查找"></a>二分查找与三分查找</h2><blockquote>
<p>二分查找 时间复杂度 O(logn)</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210224163211539.png" alt="image-20210224163211539"></p>
<h2 id="二分查找的特殊情况"><a href="#二分查找的特殊情况" class="headerlink" title="二分查找的特殊情况"></a>二分查找的特殊情况</h2><blockquote>
<p>111111111000000000000000找最后一个1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(L ! = R) &#123;</span><br><span class="line"> 	<span class="keyword">int</span> mid = (L + R + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//避免死循环</span></span><br><span class="line"> 	<span class="keyword">if</span> (n[mid] == <span class="number">1</span>) &#123;</span><br><span class="line">        L = mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	R = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<blockquote>
<p>000000000001111111找第一个1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (L != R) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n[mid] == <span class="number">0</span>) &#123;</span><br><span class="line">        L = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        R = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>如果全是00000000000, 可以设置一个虚拟位 -1</p>
<p>这样最后l和r都会指向-1</p>
</blockquote>
<h2 id="二分查找的代码演示"><a href="#二分查找的代码演示" class="headerlink" title="二分查找的代码演示"></a>二分查找的代码演示</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 11.binary_search.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Wed 24 Feb 2021 05:22:26 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(func) &#123;\</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = %d\n&quot;</span>, <span class="meta">#func, func);\</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> binary_search(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; x) head = mid +  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//111110000000</span></span><br><span class="line"><span class="keyword">int</span> binary_search1(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">-1</span>, tail = n - <span class="number">1</span>, mid;<span class="comment">//head指向虚拟位</span></span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        mid = (head + tail + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == x) head  = mid;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head == <span class="number">-1</span> ? <span class="number">-1</span> : head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//000000001111</span></span><br><span class="line"><span class="keyword">int</span> binary_search2(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = n, mid;<span class="comment">//tail指向虚拟位</span></span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == x) tail = mid;</span><br><span class="line">        <span class="keyword">else</span> head = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head == n ? <span class="number">-1</span> :head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">int</span> arr1[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr2[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> arr3[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    P(binary_search(arr1, <span class="number">10</span>, <span class="number">7</span>));</span><br><span class="line">    P(binary_search1(arr2, <span class="number">10</span>, <span class="number">1</span>));</span><br><span class="line">    P(binary_search2(arr3, <span class="number">10</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210224214028726.png" alt="image-20210224214028726"></p>
<h2 id="三分查找"><a href="#三分查找" class="headerlink" title="三分查找"></a>三分查找</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210224171640374.png" alt="image-20210224171640374"></p>
<blockquote>
<p>解决凹凸函数的极值点的问题</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210224172042866.png" alt="image-20210224172042866"></p>
<h2 id="………………………………………-1"><a href="#………………………………………-1" class="headerlink" title="……………………………………….."></a>………………………………………..</h2><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210224215740958.png" alt="image-20210224215740958"></p>
<blockquote>
<p>数组: 的下标一定是一个整型值, 通过下标访问的内容可以是任意类型.(整形到任意类型的映射)    O(1)</p>
<p>哈希表(哈希结构) : </p>
<p>==哈希函数==: 将任意类型映射成一个整型值, 这样就可以通过数组的方式进行存储与访问</p>
<p>==冲突处理==: 解决映射时候产生的冲突问题, 哈希结构中的冲突不可避免, 只要是哈希结构就一定会产生冲突</p>
<ol>
<li>拉链法: 建立一个链表</li>
<li>开放定值法: 7的位置冲突, 往后找有没有空着的位置, 找到位置8(效率低)<ol>
<li>二次探测法</li>
</ol>
</li>
<li>再哈希法: 如果冲突  使用第二个哈希函数</li>
<li>建立公共溢出区</li>
</ol>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225000104737.png" alt="image-20210225000104737"></p>
<blockquote>
<p>将16存入位置7, 此时如果再存入7, 会产生冲突, 此时采用开放定值法, 将7存入位置8</p>
<p>查找时, 先看查找到的值是不是需要的值, 如果不是, 说明之前是冲突的, 根据相应的冲突处理探测下一个位置是否是需要的值</p>
</blockquote>
<h2 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h2><blockquote>
<p>哈希函数 : BKDR</p>
<p>冲突处理: 拉链法</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 12.hash_table.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Thu 25 Feb 2021 03:00:06 PM CST</span></span><br><span class="line"><span class="comment">//字符串的哈希结构************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line">    Node **data;<span class="comment">//数据区存入的是Node *</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">init_node</span><span class="params">(<span class="keyword">char</span> *str, Node *head)</span> </span>&#123;</span><br><span class="line">    Node *p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    p-&gt;str = strdup(str);<span class="comment">//原封拷贝一份str, 并将地址传给节点的str</span></span><br><span class="line">    <span class="comment">//当用完开辟之后的str后, 会自动释放</span></span><br><span class="line">    p-&gt;next = head;<span class="comment">//采用头插法</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125; <span class="comment">//初始化链表节点</span></span><br><span class="line"></span><br><span class="line"><span class="function">HashTable *<span class="title">init_hashtable</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    HashTable *h = (HashTable *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    h-&gt;size = (n &lt;&lt; <span class="number">1</span>);<span class="comment">//初始化hash表的size容量 利用率50%</span></span><br><span class="line">    h-&gt;data = (Node **)<span class="built_in">calloc</span>(h-&gt;size, <span class="keyword">sizeof</span>(Node *));<span class="comment">//hash表的每一个元素是链表第一个节点的首地址</span></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seed = <span class="number">31</span>, hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) hash = hash * seed + str[i];</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="number">0x7fffffff</span>;<span class="comment">//将有可能为负数的hash映射成正数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(HashTable *h, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(str);</span><br><span class="line">    <span class="keyword">int</span> ind = hash % h-&gt;size;<span class="comment">//原hash区间是整个整形</span></span><br><span class="line">    h-&gt;data[ind] = init_node(str, h-&gt;data[ind]);<span class="comment">//封装成链表的节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(HashTable *h, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = BKDRHash(str);</span><br><span class="line">    <span class="keyword">int</span> ind = hash % h-&gt;size;</span><br><span class="line">    Node *p = h-&gt;data[ind];<span class="comment">//ind位置上第一个链表节点的位置</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; <span class="built_in">strcmp</span>(p-&gt;str, str)) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_node</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Node *p = node, *q;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p-&gt;str);<span class="comment">//和strdup配合使用</span></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(HashTable *h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h-&gt;size; i++) &#123;</span><br><span class="line">        clear_node(h-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(h-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(h);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> op;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line">    <span class="keyword">char</span> str[MAX_N + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    HashTable *h = init_hashtable(MAX_N);</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;op, str)) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;insert %s to HashTable\n&quot;</span>, str);</span><br><span class="line">                insert(h, str);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;search %s from the HashTable result = %d\n&quot;</span>, str, search(h, str));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_N</span></span><br><span class="line">    clear(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="课后习题-1"><a href="#课后习题-1" class="headerlink" title="课后习题"></a>课后习题</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225162558008.png" alt="image-20210225162558008"></p>
<h1 id="堆与优先队列-本质都是一种结构"><a href="#堆与优先队列-本质都是一种结构" class="headerlink" title="堆与优先队列(本质都是一种结构)"></a>堆与优先队列(本质都是一种结构)</h1><h2 id="完全二叉树-1"><a href="#完全二叉树-1" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225163134687.png" alt="image-20210225163134687"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225163146964.png" alt="image-20210225163146964"></p>
<blockquote>
<p>用一个数组存储完全二叉树</p>
</blockquote>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225163354156.png" alt="image-20210225163354156"></p>
<blockquote>
<p>数据结构的本质: 定义一种性质, 并且维护这种性质的结构</p>
<p>堆的本质 : 完全二叉树   堆不等同于二叉排序树</p>
<p>大顶堆 : 根节点的值大于左右两个子节点的值</p>
<p>小顶堆 : 根节点的值永远比左右孩子小 </p>
</blockquote>
<h2 id="堆的插入-尾部插入调整-O-logN"><a href="#堆的插入-尾部插入调整-O-logN" class="headerlink" title="堆的插入-尾部插入调整  O(logN)"></a>堆的插入-尾部插入调整  O(logN)</h2><blockquote>
<p>插入结束之后, 需要进行调整, 维护 堆 的性质</p>
<p>从堆尾, 自下向上进行调整</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225164310276.png" alt="image-20210225164310276"></p>
<p>13插入后, 13 比 根节点 大, 但因为这是大顶堆, 所以需要进行调整</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225165413496.png" alt="image-20210225165413496"></p>
<p>13 和 7 进行交换</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225165600240.png" alt="image-20210225165600240"></p>
<p>13 和 11 进行交换</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225165630933.png" alt="image-20210225165630933"></p>
<p>13 在和 12 进行交换, 作为堆的根节点</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225170210771.png" alt="image-20210225170210771"></p>
<p>数组插入并调整的时间复杂度 O(N)</p>
<p>堆的插入并调整时间复杂度O(logN)</p>
<p>N个元素, 那就是Nlog(N)</p>
</blockquote>
<h2 id="堆的删除-头部弹出调整"><a href="#堆的删除-头部弹出调整" class="headerlink" title="堆的删除-头部弹出调整"></a>堆的删除-头部弹出调整</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225184507265.png" alt="image-20210225184507265"></p>
<blockquote>
<p>二叉树的根节点弹出后就没了, 需要重新选择一个新的根节点</p>
<p>从堆的最后一个位置拿一个值, 当做堆顶元素</p>
<p>需要维护堆的平衡 : 从堆顶向下进行调整</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225194158144.png" alt="image-20210225194158144"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225194456241.png" alt="image-20210225194456241"></p>
<blockquote>
<p>7的右孩子11大于7本身, 所以进行互换</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225194548523.png" alt="image-20210225194548523"></p>
<h2 id="堆排序-O-NlogN-与-优先队列"><a href="#堆排序-O-NlogN-与-优先队列" class="headerlink" title="堆排序 O(NlogN)   与  优先队列"></a>堆排序 O(NlogN)   与  优先队列</h2><blockquote>
<p>堆顶元素肯定为最大值 / 最小值</p>
<p>头部弹出之后, 经过调整, 新的堆顶元素仍然是最大值</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225195647947.png" alt="image-20210225195647947"></p>
<blockquote>
<ol>
<li>将堆顶元素与堆尾元素交换(数组的头元素放到数组最后)</li>
<li>堆的length - 1, 对于剩下的元素用堆的平衡进行调整, 这是堆顶元素为剩下元素的最大值</li>
<li>重复操作 经过n-1轮 </li>
</ol>
</blockquote>
<blockquote>
<p>从小到大排序 : 大顶堆</p>
<p>从大到小排序 : 小顶堆</p>
</blockquote>
<blockquote>
<p>为什么又叫优先队列?</p>
<p>删除: 从堆顶弹出 ; 插入: 从堆尾插入      性质类似于队列queue</p>
<p>而且每次从头部弹出的元素, 肯定是最大值 / 最小值(优先)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225200409084.png" alt="image-20210225200409084"></p>
<p>所以堆的实现可以利用二叉树 或者 队列</p>
</blockquote>
<h2 id="课后习题-2"><a href="#课后习题-2" class="headerlink" title="课后习题"></a>课后习题</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225200607429.png" alt="image-20210225200607429"></p>
<h2 id="大顶堆-优先队列-的代码演示"><a href="#大顶堆-优先队列-的代码演示" class="headerlink" title="大顶堆 / 优先队列 的代码演示"></a>大顶堆 / 优先队列 的代码演示</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 13.priority_queue.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Thu 25 Feb 2021 08:17:53 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">priority_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">int</span> cnt, size;</span><br><span class="line">&#125; <span class="built_in">priority_queue</span>;<span class="comment">//实现大顶堆</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">priority_queue</span> *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span> *q = (<span class="built_in">priority_queue</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">priority_queue</span>));</span><br><span class="line">    q-&gt;data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));<span class="comment">//根节点编号为1,0号空着, 才能有某些性质</span></span><br><span class="line">    q-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    q-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;cnt == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;data[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="built_in">priority_queue</span> *q, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;cnt == q-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//q-&gt;cnt += 1;</span></span><br><span class="line">    q-&gt;data[++(q-&gt;cnt)] = val;</span><br><span class="line">    <span class="keyword">int</span> ind = q-&gt;cnt;<span class="comment">//当任意一个三元组不发生调整, 则已经平衡</span></span><br><span class="line">    <span class="keyword">while</span> (ind &gt;&gt; <span class="number">1</span> &amp;&amp; q-&gt;data[ind] &gt; q-&gt;data[ind &gt;&gt; <span class="number">1</span>]) &#123;<span class="comment">//ind&gt;&gt;1除2即为ind的根节点</span></span><br><span class="line">        swap(q-&gt;data[ind], q-&gt;data[ind &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">        ind &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (empty(q)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;data[<span class="number">1</span>] = q-&gt;data[q-&gt;cnt];<span class="comment">//覆盖原来的堆顶元素</span></span><br><span class="line">    q-&gt;cnt -= <span class="number">1</span>;<span class="comment">//下面开始自上向下进行调整</span></span><br><span class="line">    <span class="keyword">int</span> ind = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ind &lt;&lt; <span class="number">1</span>) &lt;= q-&gt;cnt) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = ind, l = ind &lt;&lt; <span class="number">1</span>, r = ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;<span class="comment">//按位或, 在最后一位加上1</span></span><br><span class="line">        <span class="keyword">if</span> (q-&gt;data[l] &gt; q-&gt;data[temp]) temp = l;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= q-&gt;cnt &amp;&amp; q-&gt;data[r] &gt; q-&gt;data[temp]) temp = r;</span><br><span class="line">        <span class="keyword">if</span> (temp == ind) <span class="keyword">break</span>;</span><br><span class="line">        swap(q-&gt;data[ind], q-&gt;data[temp]);</span><br><span class="line">        ind = temp;</span><br><span class="line">    &#125;<span class="comment">//当堆还有元素时</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="built_in">priority_queue</span> *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_OP 20</span></span><br><span class="line">    <span class="built_in">priority_queue</span> *q = init(MAX_OP);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = rand() % <span class="number">100</span>;</span><br><span class="line">        push(q, val);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;insert %d to the priority_queue!\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OP; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, top(q));</span><br><span class="line">        pop(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_OP</span></span><br><span class="line">    clear(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225213604709.png" alt="image-20210225213604709"></p>
<h2 id="线性建堆-法-O-N"><a href="#线性建堆-法-O-N" class="headerlink" title="线性建堆 法  O(N)"></a>线性建堆 法  O(N)</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210225215215461.png" alt="image-20210225215215461"></p>
<blockquote>
<p>可求得 假如有n层堆, 那在建立过程中总的调整次数为上面划横线的地方</p>
<p>度为0的节点个数 : 2^n^个</p>
<p>度为2的节点个数 : 2^n^ - 1个</p>
<p>叶子节点(最后一行节点)占了总结点数的一半还多一个</p>
<p>可以利用n*2^n^的值对整个调整的次数进行估算 </p>
</blockquote>
<blockquote>
<p>全部节点个数N ≈ 2 * 2^n^ ;   &gt; 算出n=logN / 2  代入 n * 2^n^ ;</p>
<p>总调整次数(NlogN-1) / 2</p>
</blockquote>
<blockquote>
<p>线性建堆法  每个节点调整的次数    (错位相减法)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210226181824311.png" alt="image-20210226181824311"></p>
</blockquote>
<blockquote>
<p> 总的节点的最多调整次数为  2^n+2^-2n-4</p>
<p>自上向下调整</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210226182303117.png" alt="image-20210226182303117"></p>
<p>最后一层节点个数  2^n+1^</p>
<p>总节点 : N≈ 2^n+2^ ; </p>
<p>所以N≈ 2^n+2^个节点调整次数为2^n+2^-2n-4      O(N)级别的调整时间复杂度</p>
</blockquote>
<blockquote>
<p>自下向上调整法</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210228204033473.png" alt="image-20210228204033473"></p>
</blockquote>
<h2 id="堆排序-O-NlogN-大顶堆排序"><a href="#堆排序-O-NlogN-大顶堆排序" class="headerlink" title="堆排序  O(NlogN)  大顶堆排序"></a>堆排序  O(NlogN)  大顶堆排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 14.heap_sort.cpp  </span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Sun 28 Feb 2021 04:50:35 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downUpdata</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((ind &lt;&lt; <span class="number">1</span>) &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = ind, l = ind &lt;&lt; <span class="number">1</span>, r = ind &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[l] &gt; arr[temp]) temp = l;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) temp = r;</span><br><span class="line">        <span class="keyword">if</span> (temp == ind) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr[ind], arr[temp]);</span><br><span class="line">        ind = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    arr -= <span class="number">1</span>;<span class="comment">//堆顶元素从1开始存 (arr[1]中存堆顶元素) arr[0]访问到的地址现在需要arr[1]进行访问</span></span><br><span class="line">    <span class="comment">//从倒数第二层, 自上向下进行调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n &gt;&gt; <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        downUpdata(arr, n, i);<span class="comment">//删除元素也是向下进行调整, 从第i层开始调整</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(arr[i], arr[<span class="number">1</span>]);<span class="comment">//堆尾与堆顶元素交换</span></span><br><span class="line">        downUpdata(arr, i - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_N 20</span></span><br><span class="line">    <span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (MAX_N + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_N; i++) &#123;</span><br><span class="line">        arr[i] = rand() % <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    output(arr, MAX_N);</span><br><span class="line">    heap_sort(arr, MAX_N);</span><br><span class="line">    output(arr, MAX_N);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_N</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210228172458321.png" alt="image-20210228172458321"></p>
<h1 id="森林与并查集"><a href="#森林与并查集" class="headerlink" title="森林与并查集"></a>森林与并查集</h1><h2 id="连通性问题"><a href="#连通性问题" class="headerlink" title="连通性问题"></a>连通性问题</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210228205944967.png" alt="image-20210228205944967"></p>
<blockquote>
<p>即使不主动将8和9连同, 8和9就已经是联通关系了</p>
<p>集就是集合  判断两个数是否在一个集合中</p>
<p>森林与并查集本质是相同的</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210228210556933.png" alt="image-20210228210556933"></p>
<p>quick-find判断是否连通,直接看颜色是否一样</p>
</blockquote>
<blockquote>
<p>并查集: 将两个集合合并, 并且判断两个元素是否在同一个集合中</p>
</blockquote>
<blockquote>
<p>一棵树的根节点就是这棵树的全集</p>
</blockquote>
<h2 id="quick-find算法"><a href="#quick-find算法" class="headerlink" title="quick-find算法"></a>quick-find算法</h2><blockquote>
<p>合并操作的时间复杂度 : O(n)</p>
<p>连通判断 / 查找 的时间复杂度 : O(1)</p>
</blockquote>
<blockquote>
<p>==合并操作== : 借助数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210303185434348.png" alt="image-20210303185434348"></p>
<ol>
<li><p>先将数组每个元素都存成自己的数</p>
</li>
<li><p>将前面的元素的颜色 改成 后面的一个元素的颜色(实际中无所谓), 将4号的颜色改成3号的颜色</p>
</li>
<li><p>将所有颜色标记为3的颜色都改成8这个元素的颜色</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210303192959830.png" alt="image-20210303192959830"></p>
</li>
<li><p>每次合并, 都要遍历一遍数组</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210303193230854.png" alt="image-20210303193230854"></p>
</li>
</ol>
</blockquote>
<blockquote>
<p>quick-find算法的优缺点 : </p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210303193452437.png" alt="image-20210303193452437"></p>
</blockquote>
<h2 id="quick-union算法-快速合并"><a href="#quick-union算法-快速合并" class="headerlink" title="quick-union算法(快速合并)"></a>quick-union算法(快速合并)</h2><blockquote>
<p>核心思路 : 找代表元素</p>
<ol>
<li><p>最开始每个元素的代表元素都是自己</p>
</li>
<li><p>4号元素与8号连通 : 4号元素所在集合的代表元素与8号元素所在集合的代表元素进行连通</p>
</li>
<li><p>默认还是将前面的集合改成后面的集合</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210303202744988.png" alt="image-20210303202744988"></p>
</li>
</ol>
</blockquote>
<h2 id="随堂小练习"><a href="#随堂小练习" class="headerlink" title="随堂小练习"></a>随堂小练习</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210303202913565.png" alt="image-20210303202913565"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210303205707437.png" alt="image-20210303205707437"></p>
<blockquote>
<p>quick-union中, 最后一步, 1 和 5 连接 : 1的代表元素是2, 不是本身; 2的代表元素是4, 4的代表元素还是4, 是本身; 所以将 4 的代表元素改成5</p>
</blockquote>
<h2 id="quick-union算法总结"><a href="#quick-union算法总结" class="headerlink" title="quick-union算法总结"></a>quick-union算法总结</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210303210800872.png" alt="image-20210303210800872"></p>
<blockquote>
<p>连通 与 合并 的最坏情况都为 O(n)      即当退化成为了一个链表的情况下</p>
<p>优化后 两个操作的时间复杂度 都为O(logN) , 即最好的情况</p>
<p>前面的元素成为后面的元素的一个子节点</p>
</blockquote>
<blockquote>
<p>==为什么会产生 退化 ?==</p>
<p>见上面的问题思考; </p>
<p>==如何解决退化?==</p>
<p>按照节点数量和树的高度都能解决退化问题, 将时间复杂度稳定在logN, 但是按照==树的节点数==进行合并效率更高. 与==树高==没有关系理由见下</p>
</blockquote>
<blockquote>
<p>假设有两棵树, </p>
<p>E<del>AB</del>以A树作为子树, 相当于A挂在B树的下面, 那么B树所有的节点查找次数都会多一次, 增量是LA</p>
<p>(下图第一个蓝框应该是LA)</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210303234059667.png" alt="image-20210303234059667"></p>
<p>E<del>AB</del>表示以平均查找次数, LA表示A树的所有查找次数, A表示A的所有节点个数</p>
<p>AB哪个数节点少, 就作为子树, 那么平均查找次数会少一点</p>
</blockquote>
<h2 id="weighted-quick-union算法"><a href="#weighted-quick-union算法" class="headerlink" title="weighted-quick-union算法"></a>weighted-quick-union算法</h2><blockquote>
<p>根据上述的分析, 基于quick-union算法的优化</p>
<p>按秩合并  :  谁的根节点多, 谁就当做根节点</p>
<p>合并与查找的时间复杂度都为O(logN)</p>
</blockquote>
<h2 id="随堂练习2"><a href="#随堂练习2" class="headerlink" title="随堂练习2"></a>随堂练习2</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210304131606510.png" alt="image-20210304131606510"></p>
<h2 id="weighted-quick-union-with-path-compression路径压缩"><a href="#weighted-quick-union-with-path-compression路径压缩" class="headerlink" title="weighted-quick-union-with-path-compression路径压缩"></a>weighted-quick-union-with-path-compression路径压缩</h2><blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210304131627095.png" alt="image-20210304131627095"></p>
<p>weighted-quck-union  趋于扁平化</p>
<p>可以继续进行优化==(路径压缩)==. 0号节点鹤立鸡群;</p>
<p>0号节点的代表元素是1还是0无所谓. 所以可以将0号节点直接挂在3号节点下面</p>
<p>合并与查找的时间复杂度都趋于O(1)</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210304131956657.png" alt="image-20210304131956657"></p>
<h2 id="leetcode习题"><a href="#leetcode习题" class="headerlink" title="leetcode习题"></a>leetcode习题</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210304132507481.png" alt="image-20210304132507481"></p>
<h2 id="代码演示-2"><a href="#代码演示-2" class="headerlink" title="代码演示"></a>代码演示</h2><h3 id="quick-find……-656ms"><a href="#quick-find……-656ms" class="headerlink" title="quick-find……..656ms"></a>quick-find……..656ms</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 15.quick_find.cpp  搭配海贼oj-71</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Thu 04 Mar 2021 01:28:38 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *color;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125; UnionSet;</span><br><span class="line"></span><br><span class="line"><span class="function">UnionSet *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    UnionSet *u = (UnionSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(UnionSet));</span><br><span class="line">    u-&gt;color = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    u-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        u-&gt;color[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(UnionSet *u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u-&gt;color[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(UnionSet *u, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (find(u, a) == find(u, b)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> color_a = u-&gt;color[a];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= u-&gt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;color[i] - color_a) <span class="keyword">continue</span>;<span class="comment">// (u-&gt;color[i] != color_A)</span></span><br><span class="line">        u-&gt;color[i] = u-&gt;color[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(UnionSet *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(u-&gt;color);</span><br><span class="line">    <span class="built_in">free</span>(u);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    UnionSet *u = init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: merge(u, b, c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, find(u, b) == find(u, c) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear(u);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210304142810330.png" alt="image-20210304142810330"></p>
<h3 id="quick-union………-1916ms"><a href="#quick-union………-1916ms" class="headerlink" title="quick-union……….1916ms"></a>quick-union……….1916ms</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 16.quick_union.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Thu 04 Mar 2021 01:28:38 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *father;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125; UnionSet;</span><br><span class="line"></span><br><span class="line"><span class="function">UnionSet *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    UnionSet *u = (UnionSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(UnionSet));</span><br><span class="line">    u-&gt;father = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    u-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        u-&gt;father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(UnionSet *u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;father[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> find(u, u-&gt;father[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(UnionSet *u, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(u, a), fb = find(u, b);<span class="comment">//找到a,b的代表元素</span></span><br><span class="line">    <span class="keyword">if</span> (fa == fb) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    u-&gt;father[fa] = fb;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(UnionSet *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(u-&gt;father);</span><br><span class="line">    <span class="built_in">free</span>(u);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    UnionSet *u = init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: merge(u, b, c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, find(u, b) == find(u, c) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear(u);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间长, 说明产生了退化</p>
</blockquote>
<h3 id="weighted-quick-union………-132ms"><a href="#weighted-quick-union………-132ms" class="headerlink" title="weighted-quick-union………..132ms"></a>weighted-quick-union………..132ms</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 16.quick_union.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Thu 04 Mar 2021 01:28:38 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *father;</span><br><span class="line">    <span class="keyword">int</span> *size;<span class="comment">//利用size进行按秩合并</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125; UnionSet;</span><br><span class="line"></span><br><span class="line"><span class="function">UnionSet *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    UnionSet *u = (UnionSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(UnionSet));</span><br><span class="line">    u-&gt;father = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    u-&gt;size = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    u-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        u-&gt;father[i] = i;</span><br><span class="line">        u-&gt;size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(UnionSet *u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;father[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> find(u, u-&gt;father[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(UnionSet *u, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(u, a), fb = find(u, b);<span class="comment">//找到a,b的代表元素</span></span><br><span class="line">    <span class="keyword">if</span> (fa == fb) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;size[fa] &lt; u-&gt;size[fb]) swap(fa, fb);<span class="comment">//fa永远记录节点个数最大的值</span></span><br><span class="line">    u-&gt;father[fb] = fa;<span class="comment">//fb当做fa的子树</span></span><br><span class="line">    u-&gt;size[fa] += u-&gt;size[fb];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(UnionSet *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(u-&gt;father);</span><br><span class="line">    <span class="built_in">free</span>(u-&gt;size);</span><br><span class="line">    <span class="built_in">free</span>(u);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    UnionSet *u = init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: merge(u, b, c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, find(u, b) == find(u, c) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear(u);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210304145625085.png" alt="image-20210304145625085"></p>
<blockquote>
<p>只需要这样改</p>
</blockquote>
<h3 id="实际中-可以上来就进行路径压缩操作-不需要按秩合并优化-时间差不多-但节约一半的空间大小"><a href="#实际中-可以上来就进行路径压缩操作-不需要按秩合并优化-时间差不多-但节约一半的空间大小" class="headerlink" title="实际中, 可以上来就进行路径压缩操作, 不需要按秩合并优化; 时间差不多, 但节约一半的空间大小"></a>实际中, 可以上来就进行路径压缩操作, 不需要按秩合并优化; 时间差不多, 但节约一半的空间大小</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: 17.quick_union_直接进行路径压缩.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Thu 04 Mar 2021 01:28:38 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;\</span></span><br><span class="line">    __typeof(a) __temp = a;\</span><br><span class="line">    a = b; b = __temp;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnionSet</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *father;</span><br><span class="line">    <span class="comment">//int *size;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125; UnionSet;</span><br><span class="line"></span><br><span class="line"><span class="function">UnionSet *<span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    UnionSet *u = (UnionSet *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(UnionSet));</span><br><span class="line">    u-&gt;father = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//u-&gt;size = (int *)malloc(sizeof(int) * (n + 1));</span></span><br><span class="line">    u-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        u-&gt;father[i] = i;</span><br><span class="line">        <span class="comment">//u-&gt;size[i] = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(UnionSet *u, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u-&gt;father[x] = (u-&gt;father[x] == x ? x : find(u, u-&gt;father[x]));<span class="comment">//代码合并</span></span><br><span class="line">    <span class="comment">/*if (u-&gt;father[x] == x) return x;</span></span><br><span class="line"><span class="comment">    //return find(u, u-&gt;father[x]);</span></span><br><span class="line"><span class="comment">    return u-&gt;father[x] = find(u, u-&gt;father[x]);//路径压缩*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(UnionSet *u, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = find(u, a), fb = find(u, b);<span class="comment">//找到a,b的代表元素</span></span><br><span class="line">    <span class="keyword">if</span> (fa == fb) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//if (u-&gt;size[fa] &lt; u-&gt;size[fb]) swap(fa, fb);//fa永远记录节点个数最大的值</span></span><br><span class="line">    u-&gt;father[fb] = fa;<span class="comment">//fb当做fa的子树</span></span><br><span class="line">    <span class="comment">//u-&gt;size[fa] += u-&gt;size[fb];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(UnionSet *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(u-&gt;father);</span><br><span class="line">    <span class="comment">//free(u-&gt;size);</span></span><br><span class="line">    <span class="built_in">free</span>(u);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    UnionSet *u = init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: merge(u, b, c); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, find(u, b) == find(u, c) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clear(u);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>数据结构</tag>
        <tag>完结</tag>
      </tags>
  </entry>
  <entry>
    <title>算法1(完结)</title>
    <url>/2021/03/10/%E7%AE%97%E6%B3%95%E4%B8%8A(%E5%AE%8C%E7%BB%93)/</url>
    <content><![CDATA[<h1 id="语法入门"><a href="#语法入门" class="headerlink" title="语法入门"></a>语法入门</h1><h2 id="如何读入带空格的字符串"><a href="#如何读入带空格的字符串" class="headerlink" title="如何读入带空格的字符串"></a>如何读入带空格的字符串</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]s&quot;</span>, str);</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure>

<h2 id="如何随机一个数组"><a href="#如何随机一个数组" class="headerlink" title="如何随机一个数组"></a>如何随机一个数组</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210224133608325.png" alt="image-20210224133608325"></p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><blockquote>
<p>对于int 类型数组排序：</p>
<ul>
<li>假如有一个数组，int num [100], 值为0~（n-1）；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(num, num + n);<span class="comment">//从小到大， num[0] - num[n-1]排序</span></span><br></pre></td></tr></table></figure>

<p>对于int 来说，不需要传参数，可以直接比较大小；但是对于自定义类型排序，需要自己传入排序方法；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line">node n[<span class="number">105</span>];<span class="comment">//n[0]到n[m-1]排序</span></span><br><span class="line"></span><br><span class="line">sort(n, n + m, cmp)<span class="comment">//从n排到n+m，用cmp方法排序compare</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;<span class="comment">//a表示前面的元素，b后面的元素，表示他们的相对关系</span></span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;<span class="comment">//排好序后，a的x大于b的x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote>
<p>==朴素的二分查找==</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201122225128404.png" alt="image-20201122225128404"></p>
<ul>
<li>一个大数组，左边界和右边界左右边界求mid</li>
<li>查看mid的值是否符合要求，假如mid小于所要查找的值，则连同mid以及mid左侧的值全部淘汰，左指针设到mid+1处。</li>
</ul>
</blockquote>
<h2 id="string类的用法"><a href="#string类的用法" class="headerlink" title="string类的用法"></a>string类的用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;//string是一个类</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;<span class="comment">//建立一个shring对象，存入大整数</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//表示删掉几位数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str &gt;&gt; n;<span class="comment">//输入大整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//循环n次，每次删掉一个数</span></span><br><span class="line">        <span class="keyword">int</span> ind = str.size() - <span class="number">1</span>;<span class="comment">//默认索引为字符串长度-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str.size() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[j] &gt; str[j + <span class="number">1</span>]) &#123;<span class="comment">//不满足前小后大</span></span><br><span class="line">                ind = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str.replace(ind, <span class="number">1</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//string类中的替换函数：位置ind，长度1，替换成“ ”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;<span class="comment">//判断是否有前导0</span></span><br><span class="line">        <span class="keyword">if</span> (str[i] != <span class="string">&#x27;0&#x27;</span>) &#123;<span class="comment">//不是字符0，</span></span><br><span class="line">            f = <span class="number">1</span>;<span class="comment">//0_flag置为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="编码能力提升"><a href="#编码能力提升" class="headerlink" title="编码能力提升"></a>编码能力提升</h1><h2 id="欧拉-15（路径问题）"><a href="#欧拉-15（路径问题）" class="headerlink" title="欧拉-15（路径问题）"></a>欧拉-15（路径问题）</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/BCZdXO1c5j6pYns.png" alt="image-20201120232952008"></p>
<p>解题思路：</p>
<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/FGNoh4alM5BpV8P.png" alt="image-20201120233228199" style="zoom: 50%;" />

<blockquote>
<p>对于每个点，有不同的方案数；</p>
<p>为了避免越界，从（1 ，1）点开始存；</p>
</blockquote>
<p>方法一：递归法</p>
<blockquote>
<p>某一点的方案数 = 左边的方案数 + 上面的方案数</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/KlIHOxmVUYL7RgG.png" alt="image-20201121100534114"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">25</span>][<span class="number">25</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//递推数组（多加5）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">21</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">21</span>; j++) &#123;<span class="comment">//20 * 20格子右下角为21</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;<span class="comment">//需要初始化最左上角为（1,1）</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">21</span>][<span class="number">21</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：数学方法</p>
<blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/5cieGBa9WbPIwpg.png" alt="image-20201121100827494"></p>
<p>左上走到右下一共路径数为 4；</p>
<p>往下走2步，往右走2步；</p>
<p>从4步里选出两步往下走: （4 * 3） / （2 * 1）</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/Czv2WTj7o3gSsqG.png" alt="image-20201121101122820"></p>
</blockquote>
<p>C^20^ <del>40</del></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">40</span>, j = <span class="number">1</span>; i &gt; <span class="number">20</span>; i--, j++) &#123;</span><br><span class="line">        ans *= i;</span><br><span class="line">        ans /= j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h2 id="欧拉-18-数学三角形：数塔问题"><a href="#欧拉-18-数学三角形：数塔问题" class="headerlink" title="欧拉-18 (数学三角形：数塔问题)"></a>欧拉-18 (数学三角形：数塔问题)</h2><p><img src="https://i.loli.net/2020/11/21/rsBIcmXyDGLhU6A.png" alt="image-20201121103921258"></p>
<blockquote>
<p>求从下面展示的三角形顶端出发到达底部，所能够得到的最大路径和：</p>
</blockquote>
<p>方法一：从上往下</p>
<blockquote>
<p>(x-1,y-1)   (x-1,y)</p>
<p>(x,y)</p>
<p>从哪一个路径下来，取决于上面两个数谁大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure>

<center class="half">
<img src="C:\Users\59719\AppData\Roaming\Typora\typora-user-images\image-20201121105011571.png" width="300"/>
<img src="C:\Users\59719\AppData\Roaming\Typora\typora-user-images\image-20201121110847314.png" width="300"/>
</center>


<p>对于某个点，只能从左上方或正上面过来，并且取决于两者的最大值；</p>
<p>遍历一遍最后一排，取一个最大值。</p>
<p>可以在最外面加一层0，避免特殊判断；</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">20</span>][<span class="number">20</span>], ans[<span class="number">20</span>][<span class="number">20</span>];<span class="comment">//num为元数据，ans为计算和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//从（1,1）开始从，外圈为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i][j];<span class="comment">//输入数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;<span class="comment">//从左上方和正上方求和</span></span><br><span class="line">            ans[i][j] = max(ans[i - <span class="number">1</span>][j - <span class="number">1</span>], ans[i - <span class="number">1</span>][j]) + num[i][j];<span class="comment">//num[i][j]为自己的值</span></span><br><span class="line">            fin = max(fin, ans[i][j]);<span class="comment">//不断更新答案</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/21/e8VBEJCQ7zkHUhR.png" alt="image-20201121112714074"></p>
<p>方法二：从下往上算</p>
<blockquote>
<p><img src="https://i.loli.net/2020/11/21/wJCOt4Sl3oUWGxT.png" alt="image-20201121111142255"></p>
<p>上面一个代码只能是正下和右下代码过来；</p>
<p>算到最后，最上面的就是答案。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">20</span>][<span class="number">20</span>], ans[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            ans[i][j] = max(ans[i + <span class="number">1</span>][j], ans[i + <span class="number">1</span>][j + <span class="number">1</span>]) + num[i][j];<span class="comment">//正下方和右下方过来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//最后求得的结果即为答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="oj-590-数塔狂想曲"><a href="#oj-590-数塔狂想曲" class="headerlink" title="oj-590 (数塔狂想曲)"></a>oj-590 (数塔狂想曲)</h2><p>求最长路径和</p>
<p><img src="https://i.loli.net/2020/11/21/hzZnXqi1Nejbdx7.png" alt="image-20201121114908854"></p>
<p>解题思路</p>
<p><img src="https://i.loli.net/2020/11/22/RqEWkgxelyBm3TH.png" alt="image-20201121115622100"></p>
<blockquote>
<p>每次只搬掉一个点：搬掉（2,2），结果为17；搬掉（5,4），结果为22；搬掉（1,1），无法走，输出-1；</p>
<p>最暴力办法是每次重新跑一遍，但会很耗时；</p>
</blockquote>
<p>方法一：上下结合</p>
<p>结合==从上到下==和==从下到上==</p>
<ul>
<li>对于每一行来说，都有一个最大路径</li>
<li>结合红色（从上往下所有路径和）和绿色表格，能求出某个点的最大路径<ul>
<li><img src="https://i.loli.net/2020/11/21/iTaWjEQAVqxUoIr.png" alt="image-20201121131508077"><ul>
<li>经过黑框点，18 + 8 - 4 = 22（-4是因为经过了两次）</li>
</ul>
</li>
</ul>
</li>
<li>再记录一个次大的点（假如最大的点被ban了，取次大点的值）</li>
<li>对于每一行，只需判断是否ban掉的值为最大值；是则输出次大值，否则输出最大值</li>
</ul>
<p>==从下往上最大路径为8，从下往上最大路径为18，但同时，4那个点加了两次，所以需要删去一个==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;//scanf需要，避免超时</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//up to down | down to up</span></span><br><span class="line"><span class="comment">//num存的原始的数</span></span><br><span class="line"><span class="comment">//ans 为经过每个点，最大路径和（不需要）</span></span><br><span class="line"><span class="comment">//mmax 0记录最大值的那个点的坐标，第二行1记录次大值</span></span><br><span class="line"><span class="comment">//n表示n行</span></span><br><span class="line"><span class="keyword">int</span> n, m, num[<span class="number">1005</span>][<span class="number">1005</span>], utd[<span class="number">1005</span>][<span class="number">1005</span>], dtu[<span class="number">1005</span>][<span class="number">1005</span>], ans[<span class="number">1005</span>][<span class="number">1005</span>], mmax[<span class="number">1005</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            utd[i][j] = max(utd[i - <span class="number">1</span>][j - <span class="number">1</span>], utd[i - <span class="number">1</span>][j]) + num[i][j];</span><br><span class="line">        &#125;<span class="comment">//从上往下求答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            dtu[i][j] = max(dtu[i + <span class="number">1</span>][j], dtu[i + <span class="number">1</span>][j + <span class="number">1</span>]) + num[i][j];</span><br><span class="line">        &#125;<span class="comment">//从下往上求答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="comment">//求出ans</span></span><br><span class="line">            ans[i][j] = utd[i][j] + dtu[i][j] - num[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于每行来说，求出最大值与次大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> m2 = <span class="number">0</span>, m1 = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i][j] &gt; m1) &#123;<span class="comment">//判断是否为最大值</span></span><br><span class="line">                m2 = m1;<span class="comment">//次大值赋值为最大值</span></span><br><span class="line">                m1 = ans[i][j];</span><br><span class="line">                cnt = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m2 &lt; ans[i][j]) &#123;</span><br><span class="line">                m2 = ans[i][j];<span class="comment">//否则如果 更新m2，避免漏掉（如果第一个点为最大值，则次大值永远无法更新）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mmax[i][<span class="number">0</span>] = cnt;<span class="comment">//对于第i行的0表示下标，1表示次大值</span></span><br><span class="line">        mmax[i][<span class="number">1</span>] = m2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; b == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="comment">//搬掉最上点，才输出-1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mmax[a][<span class="number">0</span>] == b) &#123;<span class="comment">//ban掉最大值，输出次大值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mmax[a][<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则正常输出最大值；</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dtu[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/21/p3il7tronjTPmMV.png" alt="image-20201121134640675"></p>
<h2 id="欧拉-22-姓名得分"><a href="#欧拉-22-姓名得分" class="headerlink" title="欧拉-22 (姓名得分)"></a>欧拉-22 (姓名得分)</h2><p><img src="https://i.loli.net/2020/11/21/k1cOwRMgmbo5JAV.png" alt="image-20201121134413039"></p>
<p>解题思路：</p>
<p><img src="https://i.loli.net/2020/11/21/k9mM8UZyEuAORNW.png" alt="image-20201121140159496"></p>
<p>==暴力破解==</p>
<p>==难点：==数据处理，执行替换<img src="https://i.loli.net/2020/11/21/mQTbFCnuqk6Ks1I.png" alt="image-20201121140250829"></p>
<blockquote>
<p>将“，”替换成空格     /g表示全文替换；</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	&gt; File Name: euler22.cpp</span><br><span class="line">	&gt; Author: </span><br><span class="line">	&gt; Mail: </span><br><span class="line">	&gt; Created Time: Sat <span class="number">21</span> Nov <span class="number">2020</span> <span class="number">01</span>:<span class="number">53</span>:<span class="number">29</span> PM CST</span><br><span class="line"> ************************************************************************/</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;<span class="comment">//表示最终字符串有多少个</span></span><br><span class="line">    <span class="built_in">string</span> name[<span class="number">6005</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; name[n]) &#123;</span><br><span class="line">        n++;<span class="comment">//循环读入，知道数据读完</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(name, name + n);<span class="comment">//从name开始排到name+n这个位置，从小到大</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//遍历字符串数组</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; name[i].size(); j++) &#123;<span class="comment">//到第i个字符串的大小为止</span></span><br><span class="line">            t += name[i][j] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;<span class="comment">//从1开始算，不是从0开始算</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans += t * (i + <span class="number">1</span>);<span class="comment">//乘上对应的系数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/21/nkmE47dRQbz1rxl.png" alt="image-20201121140119220"></p>
<h2 id="欧拉-32（数字位数计算）"><a href="#欧拉-32（数字位数计算）" class="headerlink" title="欧拉-32（数字位数计算）"></a>欧拉-32（数字位数计算）</h2><p><img src="https://i.loli.net/2020/11/21/67UAKhBwzFGxYCT.png" alt="image-20201121142757991"></p>
<p>解题思路：           ==暴力枚举==</p>
<blockquote>
<ul>
<li><p>是否为9位数</p>
<ul>
<li>避免重复运算：枚举时候第一个数字比第二个数字要大；</li>
<li>第一个数字范围：1-100（超过100的话，101 * 102大于五位数了，不只9位数了）</li>
<li>第二个数字范围：第一个数字长度a + 第二个数字长度b + 结果长度c &gt; 9 的时候停止<ul>
<li>只有==9的时候需要判断是否为全数字</li>
</ul>
</li>
</ul>
</li>
<li><p>是否为全数字</p>
<ul>
<li>定义一个数组 int num[10] ; 数的每一位拆开放在数组的对应位置里面，如果有个位置已经放入了数字，则不是全数字</li>
</ul>
</li>
<li><p>987 + 129 放入数组中，num[7] = 1, num [8] = 1, num[9] = 1; num [9] = 1,重复了，所以不是全数字。</p>
</li>
<li><p>只计算一次乘积</p>
</li>
<li><p>定义一个去重数组 int mark[10000],如果乘积出现过，标记为1.如果发现乘积运算过，则跳过</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>==如何确定一个数的位数：==</p>
<p>log <del>10</del>^123^ = 2.***</p>
<p>对于2.***：先下取整，再 +1；（不是上取整，因为log<del>10</del>^100^=2, 上下取整都为2）</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">	&gt; File Name: euler32.cpp</span></span><br><span class="line"><span class="comment">	&gt; Author: </span></span><br><span class="line"><span class="comment">	&gt; Mail: </span></span><br><span class="line"><span class="comment">	&gt; Created Time: Sat 21 Nov 2020 02:51:52 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;//数学库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//判断一个数字有几位</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">floor</span>(<span class="built_in">log10</span>(x)) + <span class="number">1</span>;<span class="comment">//对于x取以10为底的对数，并向下取整；</span></span><br><span class="line">    <span class="comment">//floor 返回值为double类型，强转为int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> *num)</span> </span>&#123;<span class="comment">//x为第二个传入的是数组；判断是否重复</span></span><br><span class="line">    <span class="keyword">while</span> (x) &#123;<span class="comment">//把数字的每一位拿出来放到对应的位置离</span></span><br><span class="line">        <span class="keyword">if</span> (num[x % <span class="number">10</span>] == <span class="number">1</span>) &#123;<span class="comment">//最后一位</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num[x % <span class="number">10</span>] = <span class="number">1</span>;<span class="comment">//置0</span></span><br><span class="line">        x /= <span class="number">10</span>;<span class="comment">//缩位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;<span class="comment">//判断是否为全数字</span></span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (check(a, num) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (check(b, num) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (check(c, num) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//真的是全数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, mark[<span class="number">10005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;<span class="comment">//枚举第一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; <span class="number">1</span>; j++) &#123;<span class="comment">//第二个数</span></span><br><span class="line">            <span class="keyword">int</span> a = digit(i), b = digit(j), c = digit(i * j);</span><br><span class="line">            <span class="keyword">if</span> (a + b + c == <span class="number">9</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (func(i, j, i * j)) &#123;<span class="comment">//判断是否为全数字</span></span><br><span class="line">                    <span class="keyword">if</span> (mark[i * j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        mark[i * j] = <span class="number">1</span>;<span class="comment">//只有新的答案才被标记</span></span><br><span class="line">                        ans += i * j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; i * j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a + b + c &gt; <span class="number">9</span>) &#123;<span class="comment">//分为大于和小于，小于不需要操作</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/22/UV3qE8RNSWbAPJr.png" alt="image-20201121163233089"></p>
<h2 id="欧拉-33（十字相乘）"><a href="#欧拉-33（十字相乘）" class="headerlink" title="欧拉-33（十字相乘）"></a>欧拉-33（十字相乘）</h2><p><img src="https://i.loli.net/2020/11/22/VMDPWLkFg64KEu2.png" alt="image-20201121163705180"></p>
<p>解题思路：</p>
<blockquote>
<p>从11-99 枚举分子；从i+1 - 99枚举分母；</p>
<p><img src="https://i.loli.net/2020/11/22/PWQ8du9g4VpjioE.png" alt="image-20201121164206764"></p>
<p>共有四种结果；分别枚举出来，运用十字相乘法判断约分后与原分数是否相等。</p>
<p>难点：如何用辗转相除法进行约分</p>
</blockquote>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//传入分子和分母</span></span><br><span class="line">    <span class="keyword">int</span> x1 = a / <span class="number">10</span>, x2 = a % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y1 = b / <span class="number">10</span>, y2 = b % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (!x1 || !x2 || !y1 || !y2) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//有零为平凡值，不成立</span></span><br><span class="line">    <span class="keyword">if</span> (x1 == y1 &amp;&amp; a * y2 == b * x2) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//十字相乘，判断是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (x1 == y2 &amp;&amp; a * y1 == b * x2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x2 == y1 &amp;&amp; a * y2 == b * x1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x2 == y2 &amp;&amp; a * y1 == b * x1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果都不成立，返回0；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b);<span class="comment">//辗转相除法 求公倍数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;<span class="comment">//答案的分子和分母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">11</span>; i &lt; <span class="number">100</span>; i++) &#123;<span class="comment">//枚举分子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">100</span>; j++) &#123;<span class="comment">//枚举分母</span></span><br><span class="line">            <span class="keyword">if</span> (check(i, j)) &#123;<span class="comment">//符合题意，是一个特殊的分数</span></span><br><span class="line">                a *= i;</span><br><span class="line">                b *= j;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = gcd(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b / c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/11/22/jFotVuHiXNmcRfI.png" alt="image-20201121165254289"></p>
<h2 id="欧拉-36-（双进制回文数）"><a href="#欧拉-36-（双进制回文数）" class="headerlink" title="欧拉-36 （双进制回文数）"></a>欧拉-36 （双进制回文数）</h2><p><img src="https://i.loli.net/2020/11/22/UoFkPsBx9WhYL6r.png" alt="image-20201121165448537"></p>
<p>解题思路</p>
<blockquote>
<p><img src="https://i.loli.net/2020/11/22/hRVUAS28yEfCcJD.png" alt="image-20201121165535535"></p>
<p>输入时候有前导0的时候也会正常输入。</p>
</blockquote>
<blockquote>
<p>十进制回文数如何判断？见欧拉-2</p>
<p><img src="https://i.loli.net/2020/11/21/T8AEc9xyk5viwZs.png" alt="image-20201121165924090"></p>
<ul>
<li><p>t即为翻转后的数字，并且判断与原数是否相等，相等即为回文数。（蓝色方框处与十进制有关）</p>
</li>
<li><p>所以当10 == 2 的时候，即为以二进制进行翻转。</p>
</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//n进制下，x是否为回文数</span></span><br><span class="line">    <span class="keyword">int</span> raw = x, t = <span class="number">0</span>;<span class="comment">//记录原始的x，和翻转后的结果t</span></span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        t = t * n + x % n;</span><br><span class="line">        x /= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t == raw;<span class="comment">//判断t是否等于原来的数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(i, <span class="number">10</span>) &amp;&amp; check(i, <span class="number">2</span>)) &#123;</span><br><span class="line">            ans += i;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉-30（各位数字的五次幂）"><a href="#欧拉-30（各位数字的五次幂）" class="headerlink" title="欧拉-30（各位数字的五次幂）"></a>欧拉-30（各位数字的五次幂）</h2><p><img src="https://i.loli.net/2020/11/21/27OAkcNDCjomwG9.png" alt="image-20201121224331866"></p>
<p>解题思路</p>
<blockquote>
<p>==难点==：枚举的上限，到哪个数结束。</p>
<ul>
<li>设x为枚举的位数<ul>
<li>9^5^ * x 为能得到的最大阶乘和。</li>
<li>原数最大为10^x^</li>
</ul>
</li>
<li>9^5^ * x = 10^x^  求得x = 5.xxx</li>
<li>所以枚举到所有6位数结束即可（枚举的上界，x = 7肯定超过最大值了）</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            t *= i;<span class="comment">//乘4次，求五次方</span></span><br><span class="line">        &#125;</span><br><span class="line">        num[i] = t;<span class="comment">//num[1-9]存入对应数字的5次方</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> raw = x, t = <span class="number">0</span>;<span class="comment">//保存原数字/ t存储拿出来的值的五次方的和</span></span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        t += num[x % <span class="number">10</span>];</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> raw == t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">1000000</span>; i++) &#123;<span class="comment">//个位数不认</span></span><br><span class="line">        <span class="keyword">if</span> (check(i)) &#123;</span><br><span class="line">            ans += i;<span class="comment">//加到答案中并且打印出来看看</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉-34（各位数字的阶乘）"><a href="#欧拉-34（各位数字的阶乘）" class="headerlink" title="欧拉-34（各位数字的阶乘）"></a>欧拉-34（各位数字的阶乘）</h2><p>解题思路</p>
<p><img src="https://i.loli.net/2020/11/22/sghWcZ4drlpfuGa.png" alt="image-20201122105411880"></p>
<blockquote>
<ul>
<li>==难点==：上限是多少:设x为上限的位数, 解方程==9! * x = 10^x^== <ul>
<li>x = 6.xxxxx  向下取整并且 + 1;</li>
<li>所以枚举的位数上限为7</li>
<li>代码类似于[欧拉-30](# 8. 欧拉-30（各位数字的五次幂）)</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="二分专题"><a href="#二分专题" class="headerlink" title="二分专题"></a>二分专题</h1><h2 id="oj-380-大统领投票（sort排序）"><a href="#oj-380-大统领投票（sort排序）" class="headerlink" title="oj-380. 大统领投票（sort排序）"></a>oj-380. 大统领投票（sort排序）</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/56UkzQmu2JAgIDi.png" alt="image-20201122110227459"></p>
<p>解题思路</p>
<blockquote>
<p>做一个排序</p>
<ul>
<li>练习使用==[sort](# sort)==;</li>
<li>输出编号, 必须编号与票数一起排序,需要用到==struct==, 将编号与票数结合在一个结构体内;</li>
<li>票数很大, 需要用到==字符串==读入: string读入,并且可以直接比较大小;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>谁长谁大;</li>
<li>一样长,则比较字典序（因为是字符串，而且只有数字）</li>
</ul>
</blockquote>
<blockquote>
<p>如何理解==排序方法cmp==函数</p>
<ul>
<li><p>传入两个参数a, b, 分别表示排完序后前元素和后元素的相对位置关系;</p>
</li>
<li><p>想让a和b满足什么条件, 就return什么条件</p>
</li>
<li><p>```c++<br>return a.s.size() &gt; b.s.size();//按照长度排序, 前面的元素a的长度大于后面的元素b的长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">代码</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;&#x2F;&#x2F;引进string类的头文件</span><br><span class="line">#include &lt;algorithm&gt;&#x2F;&#x2F;sort在算法库里，需要引进来</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">   int num;&#x2F;&#x2F;编号</span><br><span class="line">   string s;&#x2F;&#x2F;票数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">node p[105];&#x2F;&#x2F;结构体数组</span><br><span class="line"></span><br><span class="line">bool cmp(node a, node b) &#123;&#x2F;&#x2F;相当于a和b排好序后,a是前面的那个元素,b是后面的那个元素&#x2F;&#x2F;node &amp;a, node &amp;b传引用的意思</span><br><span class="line">   if (a.s.size() &#x3D;&#x3D; b.s.size()) &#123;</span><br><span class="line">       return a.s &gt; b.s;&#x2F;&#x2F;如果长度一样,按照字典序来排序，前面的大于后面</span><br><span class="line">   &#125;</span><br><span class="line">   return a.s.size() &gt; b.s.size();&#x2F;&#x2F;先按照长度来排序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">       cin &gt;&gt; p[i].s;&#x2F;&#x2F;读入票数,存入结构体的票数中</span><br><span class="line">       p[i].num &#x3D; i;&#x2F;&#x2F;编号置为i</span><br><span class="line">   &#125;</span><br><span class="line">   sort(p + 1, p + n + 1, cmp);&#x2F;&#x2F;从1开始输入的，所以要+1；  起始位置   结束为止   排序方法cmp</span><br><span class="line">   cout &lt;&lt; p[1].num &lt;&lt; endl &lt;&lt; p[1].s &lt;&lt; endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p><img src="https://i.loli.net/2020/11/22/zfNF4S1pT8cVRgG.png" alt="image-20201122113741020"></p>
<h2 id="oj-381-谁拿了最大奖学金"><a href="#oj-381-谁拿了最大奖学金" class="headerlink" title="oj-381. 谁拿了最大奖学金"></a>oj-381. 谁拿了最大奖学金</h2><p>解题思路</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201122143836112.png" alt="image-20201122143836112"></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span><span class="comment">//结构体表示每个同学</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> num, avg, cla, paper, m;<span class="comment">//m奖学金 num编号 </span></span><br><span class="line">    <span class="keyword">char</span> off, west;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(person a, person b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.m == b.m) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.num &lt; b.num;<span class="comment">//如果奖学金相同，按照编号进行排序；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.m &gt; b.m<span class="comment">//排在前面的奖学金大于后面的奖学金</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans;<span class="comment">//n学生数量，ans总的奖学金数量</span></span><br><span class="line">person stu[<span class="number">105</span>];<span class="comment">//学生数组，最多100人；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//求获得了多少奖学金</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (stu[x].avg &gt; <span class="number">80</span> &amp;&amp; stu[x].paper &gt;= <span class="number">1</span>) t += <span class="number">8000</span>;</span><br><span class="line">    <span class="keyword">if</span> (stu[x].avg &gt; <span class="number">85</span> &amp;&amp; stu[x].cla &gt; <span class="number">80</span>) t += <span class="number">4000</span>;</span><br><span class="line">    <span class="keyword">if</span> (stu[x].avg &gt; <span class="number">90</span>) t += <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">if</span> (stu[x].avg &gt; <span class="number">85</span> &amp;&amp; stu[x].west == <span class="string">&#x27;Y&#x27;</span>) t += <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">if</span> (stu[x].cla &gt; <span class="number">80</span> &amp;&amp; stu[x].off == <span class="string">&#x27;Y&#x27;</span>) t += <span class="number">850</span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; stu[i].name &gt;&gt; stu[i].avg &gt;&gt; stu[i].cla &gt;&gt; stu[i].off &gt;&gt; stu[i].west &gt;&gt; stu[i].paper;</span><br><span class="line">        stu[i].num = i;<span class="comment">//给上编号</span></span><br><span class="line">        stu[i].m = func(i);</span><br><span class="line">        ans += stu[i].m;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(stu, stu + n, cmp);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu[<span class="number">0</span>].name &lt;&lt; <span class="built_in">endl</span> &lt;&lt; stu[<span class="number">0</span>].m &lt;&lt; <span class="built_in">endl</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201122172922700.png" alt="image-20201122172922700"></p>
<h2 id="oj-386-吃瓜群众（朴素二分）"><a href="#oj-386-吃瓜群众（朴素二分）" class="headerlink" title="oj-386. 吃瓜群众（朴素二分）"></a>oj-386. 吃瓜群众（朴素二分）</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201122164531234.png"></p>
<p>解题思路</p>
<blockquote>
<p><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">==二分查找法（点击跳转）==</a></p>
<ul>
<li>对于想要的瓜的数量，进行排序，</li>
<li>再进行二分查找，看是否有一个对应的一组瓜数量是一致的；</li>
<li>有，输出编号，没有，输出0</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, num;<span class="comment">//编号与瓜的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">node wm[<span class="number">100005</span>];<span class="comment">//西瓜的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num &lt; b.num;<span class="comment">//从小到大，按照瓜的数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; wm[i].num;<span class="comment">//第i组西瓜的数量</span></span><br><span class="line">        wm[i].cnt = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(wm, wm + n, cmp);<span class="comment">//从西瓜开始排到西瓜+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t, f = <span class="number">0</span>, l = <span class="number">0</span>, r = n - <span class="number">1</span>;<span class="comment">//二分查找的左区间和右区间</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (t == wm[mid].num) &#123;</span><br><span class="line">                f = wm[mid].cnt;<span class="comment">//瓜的编号，而不是数组所在的位置</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; wm[mid].num) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201122223932588.png" alt="image-20201122223932588"></p>
<h2 id="oj-387-吃瓜群众升级版（二分查找的特殊情况）"><a href="#oj-387-吃瓜群众升级版（二分查找的特殊情况）" class="headerlink" title="oj-387. 吃瓜群众升级版（二分查找的特殊情况）"></a>oj-387. 吃瓜群众升级版（二分查找的特殊情况）</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201122224200859.png" alt="image-20201122224200859"></p>
<p>解题思路</p>
<blockquote>
<p>与386不同，不需要找正好相等的瓜数，只需要找大于等于的数</p>
<ul>
<li>如何理解输出0: <ul>
<li>方案1. 特判：输入的西瓜是否大于最大的一堆瓜的数量</li>
<li>方案2. 建立虚拟瓜堆，特别大，大于输入的数据，并且置为0；假如找不到，就找到虚拟的瓜，并且输出0；</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="二分查找的特殊情况"><a href="#二分查找的特殊情况" class="headerlink" title="==二分查找的特殊情况=="></a>==二分查找的特殊情况==</h2><h3 id="第一种特殊情况：前面一堆0，后面一堆1，找第一个1"><a href="#第一种特殊情况：前面一堆0，后面一堆1，找第一个1" class="headerlink" title="==第一种特殊情况：前面一堆0，后面一堆1，找第一个1=="></a>==第一种特殊情况：前面一堆0，后面一堆1，找第一个1==</h3><blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201123115404116.png" alt="image-20201123115404116"></p>
<ul>
<li>假设西瓜堆为 1 3 9 12 17；第一个群众想吃7个瓜。1 3 不符合，编号初始化为0；9 12 17符合，编号初始化为1；<ul>
<li>题意抽象为找第一个1的编号为多少。</li>
</ul>
</li>
<li>前面一堆0，后面一堆1，如何找第一个1的套路：（二分查找的特殊情况）<ul>
<li>动态调整边界</li>
<li>二分条件变化：当 左 不等于 右，就一直二分</li>
<li><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201123132140424.png" alt="image-20201123132140424"></li>
<li>与==朴素二分==的区别：<ul>
<li>1.条件不一样；</li>
<li>2.R = mid（不是mid-1）；假如正好mid指向1的话，R= mid = 1，即正好mid是我们想要的最终答案，这时候，假如mid - 1就会错过这个答案了。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201123144446542.png" alt="image-20201123144446542"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="第二种情况：前面一堆1，后面一堆0，找最后一个1；"><a href="#第二种情况：前面一堆1，后面一堆0，找最后一个1；" class="headerlink" title="第二种情况：前面一堆1，后面一堆0，找最后一个1；"></a>第二种情况：前面一堆1，后面一堆0，找最后一个1；</h3><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201123151615239.png" alt="image-20201123151615239"></p>
<blockquote>
<ul>
<li><p>假如mid指向1，动左指针；动到哪里取决于mid是否可能是答案。假如为1，mid有可能是答案，所以mid区间不能删，左指针不能删</p>
</li>
<li><p>mid指向0，动右指针，0一定不是答案，所以可以mid - 1；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(L ! = R) &#123;</span><br><span class="line">  <span class="keyword">int</span> mid = (L + R + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//避免死循环</span></span><br><span class="line">  <span class="keyword">if</span> (n[mid] == <span class="number">1</span>) &#123;</span><br><span class="line">    L = mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    R = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>为什么mid = （L+R+1）/ 2:</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201123152846769.png" alt="image-20201123152846769" style="zoom:33%;" /></li>
<li>在（L+R）/2的情况下，所求mid指向左指针，为1，右指针指向0，此时L=mid。还是指向1，会无限循环；</li>
<li>让mid  = （L+R+1）/ 2， 此时mid会指向右指针，为0，此时R= mid-1，即与左指针重合，返回结果。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201123151703256.png" alt="image-20201123151703256"></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, num;</span><br><span class="line">&#125;;<span class="comment">//定义西瓜的自定义结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num &lt; b.num;<span class="comment">//直接写排序函数，从小到大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">node wm[<span class="number">100005</span>];<span class="comment">//最多10w个西瓜数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; wm[i].num;<span class="comment">//循环输入西瓜的数量</span></span><br><span class="line">        wm[i].cnt = i + <span class="number">1</span>;<span class="comment">//每组西瓜给编号，从1开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    wm[n].cnt = <span class="number">0</span>;</span><br><span class="line">    wm[n].num = <span class="number">2100000000</span>;<span class="comment">//建立虚拟瓜堆</span></span><br><span class="line">    sort(wm, wm + n + <span class="number">1</span>, cmp);<span class="comment">//排序的时候包含虚拟瓜堆，+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t, l = <span class="number">0</span>, r = n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (wm[mid].num &gt;= t) &#123;<span class="comment">//套路中1那边的</span></span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//0那边的</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; wm[l].cnt &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//左右随便输出哪一个都行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leecode-278-第一个错误的版本"><a href="#Leecode-278-第一个错误的版本" class="headerlink" title="Leecode-278. 第一个错误的版本"></a>Leecode-278. 第一个错误的版本</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201123160925875.png" alt="image-20201123160925875"></p>
<p>解题思路</p>
<blockquote>
<p>二分的特殊情况：没有bug为0，出bug为1，找到第一个1</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201123161355874.png" alt="image-20201123161355874"></p>
</blockquote>
<p>代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201123162324325.png" alt="image-20201123162324325"></p>
<h2 id="oj-390-原木切割（二分答案）"><a href="#oj-390-原木切割（二分答案）" class="headerlink" title="oj-390. 原木切割（二分答案）"></a>oj-390. 原木切割（二分答案）</h2><p>解题思路</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201123163125475.png" alt="image-20201123163125475"></p>
<blockquote>
<ul>
<li>长度为5时，能切成8段；长度为6时，能切出6段；所以5是能切出8段的最大答案</li>
<li>最短切1，最大切木头里最长的木头的长度。</li>
<li>假定最大长度为mid，遍历带入，算出能切出多少段（假如8段）；再根据段数与题意要求段数进行调整左右指针；</li>
<li>5能切8段，符合；6能切6段，不符合；</li>
<li>题意转化为<a href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9A%E5%89%8D%E9%9D%A2%E4%B8%80%E5%A0%860%EF%BC%8C%E5%90%8E%E9%9D%A2%E4%B8%80%E5%A0%861%EF%BC%8C%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA1%EF%BC%9B">前面一堆1，后面一堆0，求最后一个1</a>；<ul>
<li>Mid = (L + R +1) / 2</li>
</ul>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201124172454185.png" alt="image-20201124172454185"><ul>
<li>切长度为4， 可以切10段，显然属于套路中1那边，此时调整左指针L= mid；</li>
<li>否则，R = mid - 1；</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>为什么叫二分答案？</p>
<p>因为是根据mid求出能砍木头的段数，然后根据段数来调整左右指针。绕了一圈。</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, num[<span class="number">100005</span>], lr;<span class="comment">//n个木头，m表示切出多少段。num原木长度的大数组//lr右界，即所有原木中最长的原木的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;<span class="comment">//传入一个长度，根据mid求出能切除多少段</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//遍历原木的长度</span></span><br><span class="line">        s += num[i] / len;<span class="comment">//整数除以整数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        lr = max(lr, num[i]);<span class="comment">//输入完数据更新lr</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = lr;<span class="comment">//定义完开始二分</span></span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> s = func(mid);<span class="comment">//求出长度为mid时候能切出多少段</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= m) &#123;<span class="comment">//根据多少段求出是套路中的那堆1还是0</span></span><br><span class="line">            l = mid;<span class="comment">//是那堆1，调整左指针</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201124190459201.png" alt="image-20201124190459201"></p>
<h2 id="oj-389-暴躁的程序猿"><a href="#oj-389-暴躁的程序猿" class="headerlink" title="oj-389. 暴躁的程序猿"></a>oj-389. 暴躁的程序猿</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201124200913283.png" alt="image-20201124200913283"></p>
<p>解题思路</p>
<blockquote>
<ul>
<li>①②③表示放的三个人的位置，①②距离为1，②③距离为7</li>
<li>最近的距离为1，太近了容易打起来。</li>
</ul>
<p>这也是一道二分答案题，根据分出来的位置间的 ==最大距离==调整指针</p>
<ul>
<li>距离下界L可以赋值为1，距离上界为最大与最小距离只差；</li>
<li>如何调整左右指针？<ul>
<li>求出临时距离mid；</li>
<li>根据mid求出可以安排的人数；</li>
<li>求出的安排人数与应该安排人数进行比较：距离1，可以安排5人；距离2，可以安排3人；所以左边533，能安排下的都是1；右边22安排不下，为0；特殊情况：11100，找最后一个1；<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201124202228898.png" alt="image-20201124202228898"></li>
</ul>
</li>
<li>难点: 如何根据临时距离求出安排人数：扫一遍工位</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, num[<span class="number">100005</span>], tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;<span class="comment">//传入距离d</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>, last = num[<span class="number">0</span>];<span class="comment">//为了让人越多越好，起始位置肯定要安排上人，s=1；</span></span><br><span class="line">    <span class="comment">//last记录上一个安排人的位置,最开始那个人安排在num【0】</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">//遍历一遍num数组，0已经安排人，从1开始</span></span><br><span class="line">        <span class="keyword">if</span> (num[i] - last &gt;= d) &#123;<span class="comment">//判断，上一次在last位置，这一次在num[i]，</span></span><br><span class="line">            <span class="comment">//可否安排</span></span><br><span class="line">            s++;<span class="comment">//可放人的位置数量+1</span></span><br><span class="line">            last = num[i];<span class="comment">//更新记录上一次放人位置last</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//遍历完之后，s存入最多可以放人的个数</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];<span class="comment">//循环输入工位的编号</span></span><br><span class="line">        tr = max(tr, num[i]);<span class="comment">//更新上界</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(num, num + n);<span class="comment">//对数据进行排序，从num开始排到num+n；默认排序就好</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = tr;</span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;<span class="comment">//开始二分</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> s = func(mid);<span class="comment">//抽象成函数求出能够安排多少人</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= m) &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>主函数输入数据，并且统计一下上边界，排序保证遍历工位时候是有序的</li>
<li>开始二分</li>
<li>二分答案：根据临时距离，求出可以安排人数；根据可以安排人数多少，调整左右指针</li>
<li>初始化时，安排一个人在0，保证人最多</li>
<li>运用套路，一串1111000， 找最后一个1</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201124212335378.png" alt="image-20201124212335378"></p>
<blockquote>
<p>输出答案为3</p>
</blockquote>
<h2 id="oj-393-切绳子（小数二分）"><a href="#oj-393-切绳子（小数二分）" class="headerlink" title="oj-393. 切绳子（小数二分）"></a>oj-393. 切绳子（小数二分）</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201124212631067.png" alt="image-20201124212631067"></p>
<p>解题思路</p>
<blockquote>
<p>与上一题不同，这一题求==小数的二分==</p>
<p>难点：小数二分与整数二分的区别</p>
<ul>
<li>前面11110000，找最后一个1</li>
<li>循环判断条件不同：不是判断是否相等，而是判断是否大于预设精度</li>
<li>调整指针也不需要+1 或 -1 </li>
<li>要求保留后2位 》保留后四位；以及如何直接舍弃2位后的小数点</li>
</ul>
</blockquote>
<blockquote>
<p>如何==直接舍掉2位后的小数==？printf会四舍五入。12.12345</p>
<ul>
<li>方法一：先乘再除<ul>
<li>12.12345 * 100 = 1212.345</li>
<li>（int）1212.345 &gt; 1212</li>
<li>1212 / 100.0 &gt; 12.12 </li>
</ul>
</li>
<li>方法二：减去0.005后再四舍五入<ul>
<li>12.12345 - 0.005 = 12.11845</li>
<li>四舍五入printf (“”%.2f”)：12.12</li>
</ul>
</li>
<li>方法三：</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;//需要使用printf</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;<span class="comment">//总共绳子的数量， 要切成多少段</span></span><br><span class="line"><span class="keyword">double</span> num[<span class="number">10005</span>], tr;<span class="comment">//存入绳子长度， 最大绳子的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> len)</span> </span>&#123;<span class="comment">//只有涉及到绳子长度的才是double类型</span></span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s += num[i] / len;<span class="comment">//小数除以小数，为小数，再加入整数中，小数部分自动舍去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        tr = max(tr, num[i]);<span class="comment">//更新最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = tr;<span class="comment">//定义左右边界，开始二分</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">0.00001</span>) &#123;<span class="comment">//保留4位</span></span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">//因为是小数，不需要+1/-1</span></span><br><span class="line">        <span class="keyword">int</span> s = func(mid);</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= m) &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, (<span class="keyword">int</span>)(l * <span class="number">100</span>) / <span class="number">100.0</span>);<span class="comment">//乘上100后强转为int后 再除100.0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-82-伐木"><a href="#Oj-82-伐木" class="headerlink" title="Oj-82. 伐木"></a>Oj-82. 伐木</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201125145922820.png" alt="image-20201125145922820"></p>
<p>解题思路</p>
<blockquote>
<p>假如高度设为13，可以切下来总长度为（7+4+2）13；</p>
<p>假如高度设为14， 那么切下来为6 3 1 0，总共长度为10；题目要求的是9；</p>
<p>假如高度设为15，总长度为7</p>
<p>所以是个1110000，找最后一个1的二分答案题</p>
<ul>
<li>寻找上界和下界<ul>
<li>下界为要去切除树木的临时长度0:把树都切了；上界为最高树的高度20；</li>
</ul>
</li>
<li>根据临时长度求出可以切树木段数的总数，然后再根据总数调整左右指针</li>
</ul>
<p>长度很长，用long long存储数据，避免溢出。</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, num[<span class="number">1000005</span>], tr;<span class="comment">//n表示木头根叔，m表示要切出来的根数，num存木头长度，最多有100w，</span></span><br><span class="line"><span class="comment">//tr上界为最长木头的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;<span class="comment">//传入一个参数，表示高度</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//开始切木头</span></span><br><span class="line">        <span class="keyword">if</span> (h &lt; num[i]) &#123;<span class="comment">//所切的高度必须小于树木的高度</span></span><br><span class="line">            s += num[i] - h;<span class="comment">//切出来的长度累加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bin_search</span><span class="params">()</span> </span>&#123;<span class="comment">//通过函数进行二分答案</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = tr;<span class="comment">//左右边界</span></span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((<span class="keyword">long</span> <span class="keyword">long</span>)l + r + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//防止l+r溢出，先进行强转</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s = func(mid);<span class="comment">//有可能切出超过int范围</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= m) &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        tr = max(tr, num[i]);<span class="comment">//得到最长木头的值作为上界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bin_search() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//将二分抽象为一个函数，并且输出函数的返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-391-数列分段"><a href="#Oj-391-数列分段" class="headerlink" title="Oj-391. 数列分段"></a>Oj-391. 数列分段</h2><blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201125163009561.png" alt="image-20201125163009561"></p>
</blockquote>
<p>解题思路</p>
<blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201125163052521.png" alt="image-20201125163052521"></p>
<ul>
<li>分成三段：4 - 11 - 1 最大为11；6 - 6 - 4 最大为6；每段的最大值最小，所以为6 </li>
<li>二分答案：分每段的和<ul>
<li>假如最大和为5，可以分成5段：不行</li>
<li>==假如最大和为6，可以分成三段；6 - 4 - 6==</li>
<li>假如最大和为7，可以分成三段：6 - 4 - 6</li>
<li>8 三段；</li>
<li>9 三段；</li>
<li>10 两段；</li>
</ul>
</li>
<li>00001111，找第一个1的特殊情况</li>
<li>左界：n个数分成n段，其中最大的那一段就是每段长度和的最小值 L = min(num[i])</li>
<li>上界：n个数分成1段，求段数和 R = sum(num[i]);</li>
<li>func（）函数注意为什么分成三种情况，不要绕晕了</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m, num[<span class="number">100005</span>], tl, tr;<span class="comment">//n表示数字多少，m表示要分成几段</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">func</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;<span class="comment">//根据x求出能把数列分成多少段</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>, now = <span class="number">0</span>;<span class="comment">//定义段和当前和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//表遍历一遍数列</span></span><br><span class="line">        <span class="keyword">if</span> (now + num[i] == x) &#123;<span class="comment">//所有数的和加上当前 等于 x，说明数列加到这正好是一段</span></span><br><span class="line">            cnt++;</span><br><span class="line">            now = <span class="number">0</span>;<span class="comment">//全新的开始</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (now + num[i] &gt; x) &#123;<span class="comment">//说明上一段应该在之前一段结束</span></span><br><span class="line">            cnt++;</span><br><span class="line">            now = num[i];<span class="comment">//更新新一段的值为起点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            now += num[i];<span class="comment">//还是同一段，直接加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now) &#123; <span class="comment">//判断最后一段是否统计了（如果now里面有值，说明最后一段还没有统计）</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;<span class="comment">//返回数列最终能够分成几段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">bin_search</span><span class="params">()</span> </span>&#123;<span class="comment">//要的是一个和，有可能很大</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = tl, r = tr;</span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> s = func(mid);</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= m) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        tl = max(tl, num[i]);</span><br><span class="line">        tr += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bin_search() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201125192915755.png" alt="image-20201125192915755"></p>
<h2 id="oj-394-跳石头"><a href="#oj-394-跳石头" class="headerlink" title="oj-394. 跳石头"></a>oj-394. 跳石头</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201125193551106.png" alt="image-20201125193551106"></p>
<p>解题思路</p>
<blockquote>
<p>==0==  2  11  14  17  21  ==25==</p>
<ul>
<li>移去 11  17， 距离变成 2 12 7 4， 最小距离为2；</li>
<li>移去2 14， 距离变为11  6  4  ，最小距离为4；</li>
<li>无论怎么分，移去==2块石头==后最短距离的==最大值为4==；</li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201125195105200.png" alt="image-20201125195105200"></p>
<blockquote>
<ul>
<li>起点与终点都有一块隐藏石头</li>
</ul>
<p>最大值为3，需要移去1块石头；</p>
<p>最大值为4，需要移去2块石头；</p>
<p>最大值为5，需要移去3块石头；</p>
<ul>
<li>4对应的那个答案，是1那边的；</li>
<li>那到底左边是1还要右边是1呢？<ul>
<li>假设3.5, 需要移走2块，同为1；</li>
<li>所有左边都是1，右边都是0</li>
</ul>
</li>
</ul>
<p>111000前面一堆1，后面一堆0，寻找最后一个1；</p>
</blockquote>
<blockquote>
<p>如何确定上界和下界？</p>
<p>​    上界：起点到终点的距离 L</p>
<p>​    下界：最近的两个点之间的距离</p>
<p>遍历是遍历到终点，会移走终点的石头吗，？</p>
<p>​    不会，遍历到最后，但是动的是前面一个石头：<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201125211021537.png" alt="image-20201125211021537"></p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ll, n, m, num[<span class="number">50005</span>], tl;<span class="comment">//num数组表示石头的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;<span class="comment">//假如距离为mid（d），需要移走多少块石头？</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, last = <span class="number">0</span>;<span class="comment">//cnt 最终需要移走石头的数量，last 上一个石头的编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;<span class="comment">//从第一个石头开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (num[i] - last &lt; d) &#123;<span class="comment">//numi减去上一个石头所在的位置 &lt; d,不得不移走这块石头；不然距离不够</span></span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = num[i];<span class="comment">//否则说明距离够，可以不用移走，更新last  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bin_search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = tl, r = ll;</span><br><span class="line">    <span class="keyword">while</span> (l != r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> s = func(mid);<span class="comment">//根据mid求出需要移走多少块石头</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= m) &#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ll &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//起点为num[0],数据从1开始</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;<span class="comment">//更新下界</span></span><br><span class="line">            tl = num[<span class="number">1</span>] - num[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tl = min(tl, num[i] - num[i - <span class="number">1</span>]);<span class="comment">//否则更新出一个极小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num[n + <span class="number">1</span>] = ll;<span class="comment">//起点默认为0，强行加入一个终点为ll</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bin_search() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oj-392-丢瓶盖"><a href="#oj-392-丢瓶盖" class="headerlink" title="oj-392. 丢瓶盖"></a>oj-392. 丢瓶盖</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201125211442451.png" alt="image-20201125211442451"></p>
<p>解题思路</p>
<blockquote>
<p>似曾相识，[暴躁的程序猿](#oj-389. 暴躁的程序猿)</p>
<p>5个工位选三个，使得相邻最近的工位间的距离最大。</p>
</blockquote>
<p>代码</p>
<h2 id="oj-395-复制书稿"><a href="#oj-395-复制书稿" class="headerlink" title="oj-395. 复制书稿"></a>oj-395. 复制书稿</h2><p><img src="%E7%BC%96%E7%A0%81%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87.assets/image-20201125220145967.png" alt="image-20201125220145967"></p>
<p>解题思路</p>
<blockquote>
<p>书分成三组，分别为15 13 17，17为所求的最短的复制时间</p>
<p>这一题需要先求出17，然后遍历数组，找出其他的值（每个人抄的是哪本书）</p>
<ul>
<li>这一题转化为9个连续的数，分成三段，要求每段必须连续，且每段和的最大值越小越好。无论怎么分，最大值不会比17还小了。参考[数列分段](#Oj-391. 数列分段)</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li>求出分出后和最小的最大值；见数列分段；</li>
<li>（如果有多解，尽可能让前面的人少抄书）拿到最大值，从后往前扫数列，分情况记录每个人的起始编号和终止编号，存入数组中。最后输出答案</li>
</ol>
</blockquote>
<h2 id="二分专题总结"><a href="#二分专题总结" class="headerlink" title="二分专题总结"></a>二分专题总结</h2><blockquote>
<ul>
<li>朴素二分</li>
<li>二分的特殊情况<ul>
<li>00001111，找第一个1</li>
<li>11110000，找最后一个1</li>
<li><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201125223230925.png" alt="image-20201125223230925"></li>
<li>小数的二分特殊情况</li>
</ul>
</li>
<li>二分答案<ul>
<li>答案对应求得东西在题意中是单调的，对答案进行二分，在根据答案进行调整指针</li>
<li>二分答案基本都有特殊情况</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="oj题目讲解"><a href="#oj题目讲解" class="headerlink" title="oj题目讲解"></a>oj题目讲解</h1><h2 id="oj-599-两数之和1"><a href="#oj-599-两数之和1" class="headerlink" title="oj-599. 两数之和1"></a>oj-599. 两数之和1</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201126230154503.png" alt="image-20201126230154503"></p>
<p>解题思路</p>
<p>方法一：暴力解法，两层循环，分别枚举第一个和第二个数</p>
<p>​                会超时O(n^2^)</p>
<p>方法二：先固定一个数，内层循环用二分进行</p>
<p>​                O（nlogn）</p>
<p>方法三：哈希表</p>
<blockquote>
<p>O(n)  空间O(n)</p>
</blockquote>
<p>方法四：双指针法O（n）</p>
<blockquote>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201126234032428.png" alt="image-20201126234032428"></li>
<li>左右指针分别指向 1和26 ，此时和为27；</li>
<li>和27大于15，调整右指针–，使得数变小；</li>
<li>此时有指针指向10，10+1 = 11 《 15；</li>
<li>动左指针，指向5；</li>
<li>此时5 + 10 = 15，输出答案</li>
</ul>
<p>假如数组是乱序的，先进行排序</p>
<ul>
<li><p>三数之和：O（n^2^）</p>
<ul>
<li>外层循环，并且固定，内层循环变成二数之和</li>
</ul>
</li>
</ul>
</blockquote>
<p>代码</p>
<ul>
<li>双指针法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, t, num[<span class="number">1000005</span>];<span class="comment">//数组高达100w</span></span><br><span class="line"><span class="comment">//n ， t表示目标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;t);<span class="comment">//避免用c读入会超时</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i]);<span class="comment">//读入数据存入数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[l] + num[r] == t) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//直接输出两个数的下标</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num[l] + num[r] &lt; t) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r--;<span class="comment">//数大了，动有指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//没有找到，输出-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oj-600-杨氏矩阵"><a href="#oj-600-杨氏矩阵" class="headerlink" title="oj-600. 杨氏矩阵"></a>oj-600. 杨氏矩阵</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201127151311146.png" alt="image-20201127151311146"></p>
<p>解题思路</p>
<blockquote>
<ul>
<li>从左下角出发</li>
<li>从 7 出发，7 &lt; 15 ， 说明15一定在7的右边</li>
<li>移动黑圈，到10。10 &lt; 15， 移动黑圈到20；</li>
<li>20 &gt; 15, 说明15 在黑圈的上面。黑圈往上移动一个正好为15，输出黑圈所在的坐标。</li>
</ul>
<p>右上角出发同理，往下往左移动黑圈</p>
<p>O(n+m)</p>
<p>与上一题两数之和有联系</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201127215920845.png" alt="image-20201127215920845"></li>
<li>1 5 10 20，初始化一个数组，记录每每两数之和；左指针指向横着的数组1；右指针指向竖着的数组中的20，此时相当于本题从左下角出发。21 比 30 要小，此时动左指针，到25。过程与本题一致</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t, num[<span class="number">3005</span>][<span class="number">3005</span>];<span class="comment">//n行，m列，t目标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num[i][j]);<span class="comment">//循环读入数据存入num中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = n, y = <span class="number">1</span>;<span class="comment">//从左下角开始查找需要初始的值</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">//或者可以判断边界，当指针出界的时候，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (num[x][y] == t) &#123;<span class="comment">//正好找到目标</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//如果超时，改成printf</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num[x][y] &gt; t) &#123;<span class="comment">//没找到，需要分成两种情况</span></span><br><span class="line">            x--;<span class="comment">//数大了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            y++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oj-477-原音字母"><a href="#oj-477-原音字母" class="headerlink" title="oj-477. 原音字母"></a>oj-477. 原音字母</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201127221654132.png" alt="image-20201127221654132"></p>
<p>解题思路</p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, last = <span class="number">-1</span>; <span class="comment">//last为上一个原音字母的位置</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">105</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;<span class="comment">//输入数据字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;<span class="comment">//从第0位开始，一直到s[i]不为零结束；字符串最后为/0,即条件为假</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;A&#x27;</span> || s[i] == <span class="string">&#x27;E&#x27;</span> || s[i] == <span class="string">&#x27;I&#x27;</span> || s[i] == <span class="string">&#x27;O&#x27;</span> || s[i] == <span class="string">&#x27;U&#x27;</span>) &#123;<span class="comment">//如果是原音</span></span><br><span class="line">            <span class="keyword">if</span> (last != <span class="number">-1</span>) &#123;<span class="comment">//说明不是第一个</span></span><br><span class="line">                ans = max(ans, i - last);</span><br><span class="line">            &#125;</span><br><span class="line">            last = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201127230032288.png" alt="image-20201127230032288"></p>
<blockquote>
<p>如果last==-1，说明是第一个原音，此时更新last的值为i；</p>
<p>又因为无论if是否成立，都会运行last = i，所以说明不需要判断，可以放到循环外面。</p>
</blockquote>
<h2 id="oj-479-乒乓球"><a href="#oj-479-乒乓球" class="headerlink" title="oj-479. 乒乓球"></a>oj-479. 乒乓球</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128103220820.png" alt="image-20201128103220820"></p>
<p>解题思路</p>
<blockquote>
<p>比赛最多进行6000局</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;//求绝对值abs的数学库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a11[<span class="number">6000</span>][<span class="number">2</span>], a21[<span class="number">3000</span>][<span class="number">2</span>], ind1, ind2;<span class="comment">//11分制最多进行6000局，并且记录两个人的分数；</span></span><br><span class="line"><span class="comment">//ind1表示在11分制下,进行到了第几局</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ind1; i++) &#123;<span class="comment">//先输出11分制下</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a11[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; a11[i][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ind2; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a21[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; a21[i][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;<span class="comment">//for循环遍历字符串</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;E&#x27;</span>) &#123;<span class="comment">//如果碰到E了，说明对局结束</span></span><br><span class="line">                p();<span class="comment">//函数输出结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                a11[ind1][<span class="number">0</span>]++;</span><br><span class="line">                a21[ind2][<span class="number">0</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a11[ind1][<span class="number">1</span>]++;</span><br><span class="line">                a21[ind2][<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((a11[ind1][<span class="number">0</span>] &gt;= <span class="number">11</span> || a11[ind1][<span class="number">1</span>] &gt;= <span class="number">11</span>) &amp;&amp; <span class="built_in">abs</span>(a11[ind1][<span class="number">0</span>] - a11[ind1][<span class="number">1</span>]) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                ind1++;<span class="comment">//判断是否这一局结束</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((a21[ind2][<span class="number">0</span>] &gt;= <span class="number">21</span> || a21[ind2][<span class="number">1</span>] &gt;= <span class="number">21</span>) &amp;&amp; <span class="built_in">abs</span>(a21[ind2][<span class="number">0</span>] - a21[ind2][<span class="number">1</span>]) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                ind2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oj-480-保龄球"><a href="#oj-480-保龄球" class="headerlink" title="oj-480. 保龄球"></a>oj-480. 保龄球</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128103759952.png" alt="image-20201128103759952"></p>
<p>解题思路</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128105524585.png" alt="image-20201128105524585"></p>
<blockquote>
<ul>
<li>一局有可能打两个球</li>
<li>可以将每局的状态作为独立的结构保存下来，可以判断这一局是直接还是间接清空。</li>
<li><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128111712123.png" alt="image-20201128111712123"></li>
<li>字符串:记录多少局</li>
<li>int num1，2：记录第一次和第二次扔球得分</li>
<li>int flag：记录这一局是直接清空间接清空还是没清空</li>
<li>如果没清空，这一局分数就是num2的值</li>
<li>间接清空，加上下一局分数的num1；</li>
<li>直接清空，判断一下下一局是否为直接清空；<ul>
<li>如果是直接清空，加上直接清空分数，再加上下下局的分数num1；</li>
<li>间接清空或者没清空，则直接加上num2得分</li>
</ul>
</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="comment">//定义一个数据结构</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">4</span>];<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> num1, num2, flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node b[<span class="number">15</span>];<span class="comment">//开一个这个类型的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">//表示最终答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="built_in">cin</span> &gt;&gt; b[i].s; i++) &#123;<span class="comment">//当能输入的时候就一直输入；</span></span><br><span class="line">        <span class="comment">//每次读入两个字符或者一个字符，b[i]的字符串,一局有可能打两球</span></span><br><span class="line">        <span class="keyword">if</span> (b[i].s[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;<span class="comment">//直接清空</span></span><br><span class="line">            b[i].num1 = b[i].num2 = <span class="number">10</span>;</span><br><span class="line">            b[i].flag = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b[i].s[<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;<span class="comment">//间接清空</span></span><br><span class="line">            b[i].num1 = b[i].s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            b[i].num2 = <span class="number">10</span>;</span><br><span class="line">            b[i].flag = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//没清空</span></span><br><span class="line">            b[i].num1 = b[i].s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            b[i].num2 = b[i].s[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> + b[i].num1;</span><br><span class="line">            b[i].flag = <span class="number">0</span>;<span class="comment">//不往后计分，所以是0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//遍历10局游戏</span></span><br><span class="line">        ans += b[i].num2;<span class="comment">//先把自身答案加上</span></span><br><span class="line">        <span class="keyword">if</span> (b[i].flag == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += b[i + <span class="number">1</span>].num1;<span class="comment">//下一轮的第一球的得分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b[i].flag == <span class="number">2</span>) &#123;<span class="comment">//否则，直接清空，加后两个球</span></span><br><span class="line">            <span class="keyword">if</span> (b[i + <span class="number">1</span>].flag == <span class="number">2</span>) &#123;<span class="comment">//如果下一句是直接清空的</span></span><br><span class="line">                ans += <span class="number">10</span> + b[i + <span class="number">2</span>].num1;<span class="comment">//加上下下局第一球的得分</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += b[i + <span class="number">1</span>].num2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128113147440.png" alt="image-20201128113147440"></p>
<h2 id="oj-481-冰壶比赛"><a href="#oj-481-冰壶比赛" class="headerlink" title="oj-481. 冰壶比赛"></a>oj-481. 冰壶比赛</h2><p>解题思路<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128114715964.png" alt="image-20201128114715964"></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r, ans[<span class="number">15</span>][<span class="number">2</span>];<span class="comment">//最多10局，每局两个队的得分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="number">0</span>, a2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">//从第一轮开始到n轮结束</span></span><br><span class="line">        a1 += ans[i][<span class="number">0</span>];</span><br><span class="line">        a2 += ans[i][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ans[i][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; a2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r;<span class="comment">//输入圆圈的半径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;<span class="comment">//循环输入比赛数据</span></span><br><span class="line">        <span class="keyword">int</span> num1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;, num2[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num1[j];</span><br><span class="line">            <span class="keyword">if</span> (num1[j] == <span class="number">-1</span>) &#123;<span class="comment">//-1表示有队伍投降，直接输出答案并且退出程序</span></span><br><span class="line">                p(i);<span class="comment">//传入参数i，表示比赛进行到第几轮</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(num1, num1 + <span class="number">8</span>);</span><br><span class="line">        sort(num2, num2 + <span class="number">8</span>);<span class="comment">//排序判断谁离圆心更近</span></span><br><span class="line">        <span class="keyword">if</span> (num1[<span class="number">0</span>] &lt; num2[<span class="number">0</span>]) &#123;<span class="comment">//说明1队得分</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num1[j] &gt; r || num1[j] &gt;= num2[<span class="number">0</span>]) <span class="keyword">break</span>;<span class="comment">//这种情况下不得分</span></span><br><span class="line">                ans[i][<span class="number">0</span>]++;<span class="comment">//得分</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//第二队得分</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num2[j] &gt; r || num2[j] &gt;= num1[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">                ans[i][<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oj-484-柱状统计图"><a href="#oj-484-柱状统计图" class="headerlink" title="==oj-484. 柱状统计图=="></a>==oj-484. 柱状统计图==</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128121500940.png" alt="image-20201128121500940"></p>
<p>解题思路</p>
<blockquote>
<p>难点：</p>
<ul>
<li>按行输出结果<ul>
<li>最多字符的数量 &gt; 行数</li>
</ul>
</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">130</span>];<span class="comment">//统计个个字符出现的次数；char 的上限是128</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">1005</span>];<span class="comment">//存入字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;<span class="comment">//每次遍历一下字符串，把对应字符数量+1；</span></span><br><span class="line">            num[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mmax = <span class="number">0</span>;<span class="comment">//表示最高字符，即高度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++) &#123;<span class="comment">//从A开始到Z结束</span></span><br><span class="line">        mmax = max(mmax, num[i]);<span class="comment">//统计完找到最高的高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mmax; i &gt; <span class="number">0</span>; i--) &#123;<span class="comment">//循环最高高度次</span></span><br><span class="line">        <span class="keyword">int</span> ind = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="string">&#x27;Z&#x27;</span>; j &gt; <span class="string">&#x27;A&#x27;</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &gt;= i) &#123;<span class="comment">//说明有东西</span></span><br><span class="line">                ind = j;<span class="comment">//找到最后一个字符所在的位置</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="string">&#x27;A&#x27;</span>; j &lt;= ind; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &gt;= i) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">&#x27;A&#x27;</span>; i &lt;= <span class="string">&#x27;Z&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oj-485-均分纸牌"><a href="#oj-485-均分纸牌" class="headerlink" title="oj-485. 均分纸牌"></a>oj-485. 均分纸牌</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128135023275.png"></p>
<p>解题思路</p>
<blockquote>
<ul>
<li>先求出最终均分值为10</li>
<li>9比10小，往后一位借1 &gt; 10  7  17  6</li>
<li>10 10 14 6</li>
<li>14比10大，借给后面 &gt; 10  10  10  10</li>
</ul>
<p>扫描一遍数组，不是10就ans++，是10直接下一个数</p>
<p>特殊情况：如果 0 0 0 4，不够借：</p>
<p>​    1  -1  0  4  &gt;   1  1  -2  4 &gt;  1  1  1  1</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">105</span>], ans, sum, avg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">        sum += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    avg = sum / n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;<span class="comment">//最后一堆牌不需要</span></span><br><span class="line">        <span class="keyword">if</span> (num[i] != avg) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            num[i + <span class="number">1</span>] += num[i] - avg;<span class="comment">//无论加减都可以通过这个式子解决；解析见下图</span></span><br><span class="line">            num[i] = avg;<span class="comment">//可写可不写，让num[i]变成平均值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128140936404.png" alt="image-20201128140936404"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128141115551.png" alt="image-20201128141115551"></p>
<h2 id="oj-503-独木舟"><a href="#oj-503-独木舟" class="headerlink" title="oj-503. 独木舟"></a>oj-503. 独木舟</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128143303332.png" alt="image-20201128143303332"></p>
<p>解题思路</p>
<blockquote>
<p>排序，扫一遍，判断能否两个人搭一条船</p>
</blockquote>
<p>代码</p>
<h2 id="oj-504-删数"><a href="#oj-504-删数" class="headerlink" title="==oj-504. 删数=="></a>==oj-504. 删数==</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128145243691.png" alt="image-20201128145243691"></p>
<p>解题思路</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128152514455.png" alt="image-20201128152514455"></p>
<blockquote>
<p>两数比较，假如前面一个数字大的话，删去他可以使整体数字值变小</p>
<ul>
<li>1  75  66   &gt;  1566， 7 &gt; 5删去还需要删去2个数</li>
<li>如果都是满足小数在前，大数在后，此时删去最后的数字 </li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;//string是一个类</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;<span class="comment">//建立一个shring对象，存入大整数</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//表示删掉几位数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str &gt;&gt; n;<span class="comment">//输入大整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//循环n次，每次删掉一个数</span></span><br><span class="line">        <span class="keyword">int</span> ind = str.size() - <span class="number">1</span>;<span class="comment">//默认索引为字符串长度-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str.size() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[j] &gt; str[j + <span class="number">1</span>]) &#123;<span class="comment">//不满足前小后大</span></span><br><span class="line">                ind = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str.replace(ind, <span class="number">1</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//string类中的替换函数：位置ind，长度1，替换成“ ”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;<span class="comment">//判断是否有前导0</span></span><br><span class="line">        <span class="keyword">if</span> (str[i] != <span class="string">&#x27;0&#x27;</span>) &#123;<span class="comment">//不是字符0，</span></span><br><span class="line">            f = <span class="number">1</span>;<span class="comment">//0_flag置为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oj-505-最大整数"><a href="#oj-505-最大整数" class="headerlink" title="oj-505. 最大整数"></a>oj-505. 最大整数</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128224625256.png" alt="image-20201128224625256"></p>
<p>解题思路</p>
<blockquote>
<p>sort一下，数字按照字符串的形式存入。最终连起来也是按照字符串输出</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128171851280.png" alt="image-20201128171851280"></p>
<p>按照字典序比较大小进行排序</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span> </span>&#123;<span class="comment">//传入两个字符串</span></span><br><span class="line">    <span class="keyword">return</span> a + b &gt; b + a;<span class="comment">//a+b连接后的字典序大于b+a连接后的字典序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s[i];<span class="comment">//读入数据整数，但是按照字符串相连</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(s, s + n, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128224607590.png" alt="image-20201128224607590"></p>
<h2 id="oj-508-两人过河"><a href="#oj-508-两人过河" class="headerlink" title="oj-508. 两人过河"></a>oj-508. 两人过河</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128224800545.png" alt="image-20201128224800545"></p>
<p>解题思路</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128232627716.png" alt="image-20201128232627716"></p>
<blockquote>
<p>但是，假如是这样一组数据：1  2  1000  1001<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128231032054.png" alt="image-20201128231032054"></p>
<p>方案1：右边：1当工具人来回送;     （传手电的速度快）     </p>
<p>​    最慢最快 》 最快 》次慢最快  》 最快</p>
<p>方案2：左边：1001和1000两人一起过河，然后派2过来接1再一起过河（过桥的效率高）</p>
<p>​    最快次快 》最快 》 最慢次慢 》 次快</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201128232353729.png" alt="image-20201128232353729"></p>
<p>当n&gt;=4的时候，比较两种方法选取一个用时最少的</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">1005</span>], ans;<span class="comment">//n人数，num每个人的过河时间，</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(num + <span class="number">1</span>, num + n + <span class="number">1</span>);<span class="comment">//跑得快的在前面，跑得慢的在后面</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i -= <span class="number">2</span>) &#123;<span class="comment">//-=2表示每次过去两个人</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;<span class="comment">//说明只有一个人过河</span></span><br><span class="line">            ans += num[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            ans += num[<span class="number">2</span>];<span class="comment">//慢的那个人的时间</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;<span class="comment">//最快的人当工具人送手电筒</span></span><br><span class="line">            ans += num[<span class="number">3</span>] + num[<span class="number">1</span>] + num[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//四个人以上，两种情况</span></span><br><span class="line">            ans += min(num[i] + num[<span class="number">1</span>] + num[i - <span class="number">1</span>] + num[<span class="number">1</span>], num[<span class="number">2</span>] + num[<span class="number">1</span>] + num[i] + num[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oj-509-智力大冲浪"><a href="#oj-509-智力大冲浪" class="headerlink" title="==oj-509. 智力大冲浪=="></a>==oj-509. 智力大冲浪==</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129093020688.png" alt="image-20201129093020688"></p>
<p>解题思路</p>
<blockquote>
<ul>
<li>为了少扣钱，优先完成扣钱多的任务；</li>
<li>扣钱多少与任务时间作为一个结构，进行排序</li>
<li>优先完成扣钱多的任务</li>
<li>其次优先完成时间短的任务，</li>
<li>整个时段看作一个标记数组，尽可能把能完成任务的时间往后放，判断是否占用</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(task a, task b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.m == b.m) <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">    <span class="keyword">return</span> a.m &gt; b.m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mark[<span class="number">100000</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">task game[<span class="number">505</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; game[i].t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; game[i].m;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(game, game + n, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = game[i].t; j &gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mark[j] == <span class="number">0</span>) &#123;<span class="comment">//说明没有用过</span></span><br><span class="line">                mark[j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;<span class="comment">//说明所有时间都被占了</span></span><br><span class="line">                m -= game[i].m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oj-518-金币"><a href="#oj-518-金币" class="headerlink" title="oj-518. 金币"></a>oj-518. 金币</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129112242897.png" alt="image-20201129112242897"></p>
<p>解题思路</p>
<blockquote>
<p>两个循环</p>
</blockquote>
<h2 id="oj-513-楼层编号"><a href="#oj-513-楼层编号" class="headerlink" title="oj-513. 楼层编号"></a>oj-513. 楼层编号</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129113234199.png" alt="image-20201129113234199"></p>
<p>解题思路</p>
<blockquote>
<p>枚举；如果楼层存在，则真实楼层+1</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span> </span>&#123;<span class="comment">//i的每一拿出来看看有没有t</span></span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">10</span> == t) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, t, ans = <span class="number">0</span>;<span class="comment">//虚假；删掉数字；真实楼层</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (func(i, t)) &#123;<span class="comment">//如果第i个楼层真实存在</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ans += func(i, t);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="oj-514-火柴棒等式"><a href="#oj-514-火柴棒等式" class="headerlink" title="==oj-514==. 火柴棒等式"></a>==oj-514==. 火柴棒等式</h2><p><img src="%E7%BC%96%E7%A0%81%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87.assets/image-20201129115304749.png" alt="image-20201129115304749"></p>
<p>解题思路</p>
<blockquote>
<p>去掉+和=所用的火柴棒，还有20根</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129114110013.png" alt="image-20201129114110013"></p>
<p>确定上界</p>
<p>两层循环</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">15</span>] = &#123;</span><br><span class="line">  <span class="number">6</span></span><br><span class="line">  ,<span class="number">2</span></span><br><span class="line">  ,<span class="number">5</span></span><br><span class="line">  ,<span class="number">5</span></span><br><span class="line">  ,<span class="number">4</span></span><br><span class="line">  ,<span class="number">5</span></span><br><span class="line">  ,<span class="number">6</span></span><br><span class="line">  ,<span class="number">3</span></span><br><span class="line">  ,<span class="number">7</span></span><br><span class="line">  ,<span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">//专门求数量的函数</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;<span class="comment">//x为0，根本不会进入循环，但是0的确是一个数字</span></span><br><span class="line">        <span class="keyword">return</span> num[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;<span class="comment">//拆出每一位</span></span><br><span class="line">        ans += num[x % <span class="number">10</span>];</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="comment">//所消耗火柴的数量</span></span><br><span class="line">    <span class="keyword">int</span> x = sum(a), y = sum(b), z = sum(a + b);</span><br><span class="line">    <span class="keyword">return</span> x + y + z + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;<span class="comment">//枚举范围</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2000</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (func(i, j) == n) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; i + j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="oj-515-比例简化"><a href="#oj-515-比例简化" class="headerlink" title="==oj-515==. 比例简化"></a>==oj-515==. 比例简化</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129115559467.png" alt="image-20201129115559467"></p>
<p>解题思路</p>
<blockquote>
<p>两个for循环枚举A’和B’</p>
<p>然后看是否满足三个条件，保留一个尽可能满足条件的答案</p>
<p>互质条件不需要判断，因为是从小枚举到大，如果15/30，结果是1/2，但是已经被在之前舍弃了</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="oj-516-牛奶碑文"><a href="#oj-516-牛奶碑文" class="headerlink" title="==oj-516. 牛奶碑文=="></a>==oj-516. 牛奶碑文==</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129121419222.png" alt="image-20201129121419222"></p>
<p>解题思路</p>
<blockquote>
<ul>
<li><p>经过第一个O，左边两个c，右边两个w，所以有4种；</p>
</li>
<li><p>第二个O同理，4+4 = 8；</p>
</li>
<li><p>问题转化为求多少个c和w</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210203162625736.png" alt="image-20210203162625736"></p>
</li>
</ul>
<p>PUSH如何查看：On^2^</p>
<p>从前往后扫找到多少个P，从后往前找到多少个H，去找U，找到U后去后面找每一个s，在答案中加上U前面多少个P，s后面多少个H</p>
<p>前缀和</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">100005</span>], wcnt;<span class="comment">//num从前往后扫到某个位置有多少个c，wcnt从后往前到某个位置有多少个w</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100005</span>];<span class="comment">//字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; &amp;str[<span class="number">1</span>];<span class="comment">//从1开始，避免遇到ocow，数组越界</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//有多少个c</span></span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;C&#x27;</span>) &#123;<span class="comment">//如果是字符C</span></span><br><span class="line">            num[i] = num[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num[i] = num[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">            wcnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            ans += (<span class="keyword">long</span> <span class="keyword">long</span>)num[i - <span class="number">1</span>] * wcnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129122442097.png" alt="image-20201129122442097"></p>
<h2 id="oj-517-三角形个数"><a href="#oj-517-三角形个数" class="headerlink" title="==oj-517==. 三角形个数"></a>==oj-517==. 三角形个数</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129123136661.png" alt="image-20201129123136661"></p>
<p>解题思路</p>
<blockquote>
<p>难点：不一样的三角形的个数</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129123427932.png" alt="image-20201129123427932"></p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= (n - i) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j &gt; n - i - j) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oj-519-优雅数"><a href="#oj-519-优雅数" class="headerlink" title="==oj-519==. 优雅数"></a>==oj-519==. 优雅数</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129124559464.png" alt="image-20201129124559464"></p>
<p>解题思路</p>
<blockquote>
<p>枚举题</p>
<p>反过来，枚举优雅数与，判断是否在区间之内</p>
<p>4层枚举循环</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210203164417531.png" alt="image-20210203164417531"></p>
<p>for（一堆数Y）</p>
<ul>
<li><p>for（一个数X）</p>
</li>
<li><p>if（x==y） continue；</p>
<ul>
<li><p>for（数长3-17）</p>
<ul>
<li><p>for（x的位置1-数长）</p>
</li>
<li><p>如果x=0，不能在第一个位置；</p>
</li>
<li><p>如果y=0，x必须在第一位</p>
<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129125355146.png" alt="image-20201129125355146" style="zoom:33%;" />

<p>​    for循环构造这个数，统计是否在区间内</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>, left, right;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; left &gt;&gt; right;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//枚举一堆数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;<span class="comment">//枚举一个数</span></span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//不是优雅数，直接continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">3</span>; k &lt;= <span class="number">17</span>; k++) &#123;<span class="comment">//枚举数字的长度</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= k; l++) &#123;<span class="comment">//枚举一个数在一堆数中的位置</span></span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; l != <span class="number">1</span>) &#123;<span class="comment">//一堆数为0，且一个数不在开头，不存在</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; l == <span class="number">1</span>) &#123;<span class="comment">//一个数为0，且在第一位</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">0</span>;<span class="comment">//开始构造优雅数t</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= k; m++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (m == l) &#123;</span><br><span class="line">                            t = t * <span class="number">10</span> + j;<span class="comment">//一个数</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            t = t * <span class="number">10</span> + i;<span class="comment">//否则为一堆数</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (left &lt;= t &amp;&amp; t &lt;= right) &#123;</span><br><span class="line">                        <span class="comment">//cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">                        ans++;<span class="comment">//说明t在区间当中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="leetcode试题"><a href="#leetcode试题" class="headerlink" title="leetcode试题"></a>leetcode试题</h1><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><blockquote>
<p>快速求解多次询问区间和的题目</p>
<p>前缀和是个数组，表示第i项之前所有数的和，（空间换时间）</p>
<p>假设想求x-y区间的和，假设前缀和数组为sum[]</p>
<p>​    sum[y] - sum[x-1]</p>
<p>sum[0] = 0;避免求1-6区间和，会越界</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129131516025.png" alt="image-20201129131516025"></p>
</blockquote>
<h2 id="leetcode-13-罗马数字转整数"><a href="#leetcode-13-罗马数字转整数" class="headerlink" title="leetcode.13 罗马数字转整数"></a>leetcode.13 罗马数字转整数</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129135611528.png" alt="image-20201129135611528"></p>
<p>解题思路</p>
<blockquote>
<p>遍历一遍字符串，单独判断是否为IXC这三个字符，</p>
<p>如果是这些字符，需要判断是否为减法</p>
</blockquote>
<p>代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129162433801.png" alt="image-20201129162433801"></p>
<h2 id="LeetCode-14-最长公共前缀"><a href="#LeetCode-14-最长公共前缀" class="headerlink" title="LeetCode.14 最长公共前缀"></a>LeetCode.14 最长公共前缀</h2><p>解题思路</p>
<blockquote>
<ul>
<li>遍历，保留每两个字符串的前缀，最后输出这个词缀</li>
<li>如果中途已经为空了，则返回“”</li>
</ul>
</blockquote>
<p>代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129171112715.png" alt="image-20201129171112715"></p>
<h2 id="LeetCode-26-删除排序数组中的重复项"><a href="#LeetCode-26-删除排序数组中的重复项" class="headerlink" title="LeetCode.26 删除排序数组中的重复项"></a>LeetCode.26 删除排序数组中的重复项</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129174653334.png" alt="image-20201129174653334"></p>
<p>解题思路</p>
<blockquote>
<p>两个指针，一个往后走，一个指针表示存到了第几个数</p>
<p>如果这个数和之前的数不一样，存到第二个指针，并且两个指针都往后走；</p>
</blockquote>
<p>代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129174339430.png" alt="image-20201129174339430"></p>
<h2 id="LeetCode-27-移除元素"><a href="#LeetCode-27-移除元素" class="headerlink" title="LeetCode.27 移除元素"></a>LeetCode.27 移除元素</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129174903249.png" alt="image-20201129174903249"></p>
<p>解题思路</p>
<blockquote>
<p>类似上一题</p>
</blockquote>
<p>代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129175152192.png" alt="image-20201129175152192"></p>
<h2 id="LeetCode-35-搜索插入位置"><a href="#LeetCode-35-搜索插入位置" class="headerlink" title="LeetCode.35 搜索插入位置"></a>LeetCode.35 搜索插入位置</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129175448565.png" alt="image-20201129175448565"></p>
<p>解题思路</p>
<blockquote>
<p>0000000111111，找第一个1的特殊情况</p>
</blockquote>
<p>代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129180208833.png" alt="image-20201129180208833"></p>
<h2 id="LeetCode-38-外观数列"><a href="#LeetCode-38-外观数列" class="headerlink" title="LeetCode.38 外观数列"></a>LeetCode.38 外观数列</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129180129575.png" alt="image-20201129180129575"></p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129180310635.png" alt="image-20201129180310635"></p>
<h2 id="LeetCode-53-最大子序和"><a href="#LeetCode-53-最大子序和" class="headerlink" title="LeetCode.53 最大子序和"></a>LeetCode.53 最大子序和</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129180357994.png" alt="image-20201129180357994"></p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129180627366.png" alt="image-20201129180627366"></p>
<h1 id="STL容器的使用"><a href="#STL容器的使用" class="headerlink" title="==STL容器的使用==="></a>==STL容器的使用===</h1><h2 id="queue与stack的操作"><a href="#queue与stack的操作" class="headerlink" title="queue与stack的操作"></a>queue与stack的操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push(<span class="number">5</span>); 入队</span><br><span class="line">que.pop();出队</span><br><span class="line">que.front();队首元素</span><br><span class="line">que.size();元素个数</span><br><span class="line">que.empty();判断是否为空，真为空，返回<span class="number">0</span>表示不为空</span><br><span class="line">    </span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">double</span>&gt; que; 定义一个<span class="keyword">double</span>类型的列表</span><br></pre></td></tr></table></figure>

<p>自定义类型：<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129181501949.png" alt="image-20201129181501949"></p>
<p>栈的操作</p>
<p>stack与queue底层是一个双端队列：deque；四边都可以出入；如图堵住，变成队列</p>
<ul>
<li>与队列相比，front操作变成了top操作</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129181929910.png" alt="image-20201129181929910"></p>
<p>队列的代码演示</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129182857410.png" alt="image-20201129182857410"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129182843068.png" alt="image-20201129182843068"></p>
<p>对于自定义结构的队列操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129183339991.png" alt="image-20201129183339991"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129183419692.png" alt="image-20201129183419692"></p>
<p>栈的代码演示</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129184152957.png" alt="image-20201129184152957"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129184211093.png" alt="image-20201129184211093"></p>
<h2 id="vector与priority-queue的操作（优先队列）"><a href="#vector与priority-queue的操作（优先队列）" class="headerlink" title="vector与priority_queue的操作（优先队列）"></a>vector与priority_queue的操作（优先队列）</h2><p>动态数组</p>
<blockquote>
<p>假设定义存入整数的动态数组</p>
<p>vector <int> v;</p>
<ul>
<li>v.push_back(5); 往动态数组的最后放东西；（O1）</li>
<li>v.size();</li>
<li>v.insert(1,6);在第一个位置插入元素6（On）：要往后移动很多数字</li>
</ul>
<p>二维动态数组：vector&lt;vector<int> &gt;:（空格不能省去）   五行四列</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210203173058357.png" alt="image-20210203173058357"></p>
<p>底层实现：数组，一片连续的空间</p>
</blockquote>
<p>priority_queue: 优先队列, 内部是一个有序的队列</p>
<blockquote>
<p>底层实现: 堆</p>
<p>priority_queue <int> que;</p>
<p>que.push(5);</p>
<p>que.pop();</p>
<p>que.top();</p>
<p>que.size();</p>
<p>que.empty();</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129194303307.png" alt="image-20201129194303307"></p>
<p>注意：假如是自定义结构，无法进行自动排序</p>
<p>解决方法：重载小于号</p>
</blockquote>
<p>动态数组vector的代码演示</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129200541265.png" alt="image-20201129200541265"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129200557307.png" alt="image-20201129200557307"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129201137505.png" alt="image-20201129201137505"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129201153945.png" alt="image-20201129201153945"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129201624231.png" alt="image-20201129201624231"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129201637859.png" alt="image-20201129201637859"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; v;</span></span><br><span class="line"><span class="comment">    for (int i = 105; i &lt;= 110; i++) &#123;</span></span><br><span class="line"><span class="comment">        v.push_back(i);</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; v.size() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; v.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; v[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; v;</span><br><span class="line">    v.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">66</span>; i &lt;= <span class="number">70</span>; i++) &#123;</span><br><span class="line">        v[<span class="number">0</span>].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    v.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>)); <span class="comment">//5个值为0的元素</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">    v2.push_back(<span class="number">5</span>);</span><br><span class="line">    v2.push_back(<span class="number">6</span>);</span><br><span class="line">    v2.push_back(<span class="number">7</span>);</span><br><span class="line">    v.push_back(v2);</span><br><span class="line">    v.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123; <span class="comment">//整体作为二维数组输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].size(); j++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; v[i][j] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先队列priority_queue的代码演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">//默认使用必须重载小于号</span></span><br><span class="line">        <span class="comment">//但小于号内部可以实现各种各样符合需求的功能</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4.5</span>&#125;);</span><br><span class="line">    que.push((node)&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5.6</span>&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; que.top().x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; que.top().x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    priority_queue&lt;int&gt; que;//默认为大顶堆，从大到小输出</span></span><br><span class="line"><span class="comment">    que.push(10);</span></span><br><span class="line"><span class="comment">    que.push(20);</span></span><br><span class="line"><span class="comment">    que.push(5);</span></span><br><span class="line"><span class="comment">    que.push(6);</span></span><br><span class="line"><span class="comment">    que.push(1);</span></span><br><span class="line"><span class="comment">    while (!que.empty()) &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; que.top() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        que.pop();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>默认就是从大到小排列<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129203239500.png" alt="image-20201129203239500"></p>
<p>自定义结构体，需要重载小于号(完成了大于号的功能)<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201129204222398.png" alt="image-20201129204222398"></p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><blockquote>
<p>string str;</p>
<ul>
<li>str.size()  /  str.length() </li>
<li>str.find(s2);  //在str中查找s2，如果找到，返回正整数下标<ul>
<li>abcde中str.find(“cd”), 返回2</li>
<li>传入两个参数：abcdcde中str.find(“cd”, 3): 从3下标开始找，返回4</li>
<li>若何判断有没有找到：等于表示没找到。不等于表示找到了。不可直接写-1<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201130203743988.png" alt="image-20201130203743988"></li>
<li>npos：（no position）  无符号long long</li>
</ul>
</li>
<li>str.insert(x, s2); 在x出插入字符串s2<ul>
<li>abcde ：str.insert(2, “123”)  &gt;   ab123cde</li>
</ul>
</li>
<li>str.sub(s2): 字符串截取：<ul>
<li>一个参数：abcde ： str.sub(2)  &gt;   cde(一直截取到最后)</li>
<li>两个参数：abcde ： str.sub(2, 2) &gt; cd(第二个参数表示截取的长度)</li>
</ul>
</li>
<li>str.replace(x, y, s2): 从第x个位置替换长度为y ，替换为s2<ul>
<li>abcde：str.replace(2, 2, “123”) &gt;  ab123e</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>重载运算符：</p>
<ul>
<li>加号”+“：string a = “123” + “a”;<ul>
<li>a = “123a”</li>
</ul>
</li>
<li>大于等于“&lt;&gt; &gt;=  &lt;= !=”:根据字典序去判断</li>
</ul>
</blockquote>
<h2 id="map-键值对（映射）"><a href="#map-键值对（映射）" class="headerlink" title="map 键值对（映射）"></a>map 键值对（映射）</h2><blockquote>
<p>头文件: <map></p>
<p>map &lt;string , int&gt; m;(由字符串类型对于整形的映射)</p>
<p>一一对应的一种关系： “123”  &gt;   456</p>
<ul>
<li>[] :     m[“123”] = 456;   key与value <ul>
<li>假如直接输出 cout &lt;&lt; m[“123”] &lt;&lt; endl;<ul>
<li>会自动寻找123所对应的映射值，假如没有int类型的会自动加一个默认值0，字符串给一个默认值空</li>
</ul>
</li>
</ul>
</li>
<li>insert</li>
<li>find</li>
<li>earse</li>
<li>count 返回有多少键，可通过返回01判断某个元素是否出现过</li>
</ul>
</blockquote>
<blockquote>
<p>如果自定义结构体作为key，必须要重载小于号。因为map本质是一个红黑树RBTree，有序的。需要让他知道如何排序。</p>
</blockquote>
<blockquote>
<p>multimap： 可以存在多键；</p>
<p>unordered_map: 内部是哈希表，均摊时间复杂度 O1</p>
</blockquote>
<p>代码演示</p>
<blockquote>
<p>没有456，会在里面加一个456；并且会返回一个默认值0</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201130214446573.png" alt="image-20201130214446573"><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201130214520616.png" alt="image-20201130214520616"></p>
<p>自定义结构体使用map</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201130221100917.png" alt="image-20201130221100917"></p>
</blockquote>
<h2 id="pair的使用"><a href="#pair的使用" class="headerlink" title="pair的使用"></a>pair的使用</h2><h2 id="Oj-383-周末舞会"><a href="#Oj-383-周末舞会" class="headerlink" title="Oj-383. 周末舞会"></a>Oj-383. 周末舞会</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201201154412949.png" alt="image-20201201154412949"></p>
<p>解题思路</p>
<blockquote>
<p>两个队列，每次输出队首元素</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; n;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qx, qy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i++) &#123;</span><br><span class="line">        qx.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= y; i++) &#123;</span><br><span class="line">        qy.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; qx.front() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; qy.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        qx.push(qx.front());</span><br><span class="line">        qy.push(qy.front());</span><br><span class="line">        qy.pop();</span><br><span class="line">        qx.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-378-字符串括号匹配2"><a href="#Oj-378-字符串括号匹配2" class="headerlink" title="==Oj-378==. 字符串括号匹配2"></a>==Oj-378==. 字符串括号匹配2</h2><p>解题思路</p>
<blockquote>
<p>碰到括号，无条件的联想到栈</p>
<p>碰到括号，就入栈；碰到括回，查看是否匹配成对；</p>
<p>注意提前判断栈顶元素是否为空；</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;//string 类生成一个对象</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; sta;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            sta.push(s[i]);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sta.empty() || sta.top() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sta.pop();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sta.empty() || sta.top() != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sta.pop();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sta.empty() || sta.top() != <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sta.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                <span class="keyword">if</span> (sta.empty()) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-376-机器翻译"><a href="#Oj-376-机器翻译" class="headerlink" title="Oj-376. 机器翻译"></a>Oj-376. 机器翻译</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201201165152919.png" alt="image-20201201165152919"></p>
<p>解题思路</p>
<blockquote>
<p>碰到一个词，判断是否在队列中，如果在就直接pass</p>
<p>如果队列已满，则弹出队首元素；</p>
<p>如果在队列当中，直接标记成1</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans, n, m, mark[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;<span class="comment">//m表示内存大小，n个单词</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t; </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (mark[t] == <span class="number">0</span>) &#123;<span class="comment">//如果不在内存单元里</span></span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">if</span> (que.size() == m) &#123;<span class="comment">//表示内存已满</span></span><br><span class="line">                mark[que.front()] = <span class="number">0</span>;<span class="comment">//弹出前标记取消，因为已经不在内存当中了</span></span><br><span class="line">                que.pop();<span class="comment">//弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">            que.push(t);</span><br><span class="line">            mark[t] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-379-仓库日志"><a href="#Oj-379-仓库日志" class="headerlink" title="Oj-379. 仓库日志"></a>Oj-379. 仓库日志</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201201170849506.png" alt="image-20201201170849506"></p>
<p>解题思路</p>
<blockquote>
<p>栈</p>
<p>本题一个栈就够了</p>
<p>需要一个额外的栈，表示当前仓库当中的极大值，输出栈顶元素</p>
<table>
<thead>
<tr>
<th align="left">货物栈</th>
<th>极大值栈</th>
</tr>
</thead>
<tbody><tr>
<td align="left">入1</td>
<td>入1</td>
</tr>
<tr>
<td align="left">入2</td>
<td>比较,2 大</td>
</tr>
<tr>
<td align="left">查询</td>
<td>输出最顶层的2</td>
</tr>
<tr>
<td align="left">入4</td>
<td>4大于2，入栈4</td>
</tr>
<tr>
<td align="left">入2</td>
<td>2 小于 最大的4，不入栈</td>
</tr>
<tr>
<td align="left">查询</td>
<td>直接输出栈顶元素4</td>
</tr>
</tbody></table>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//表示操作次数</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; g, mmax;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">            g.push(t);<span class="comment">//货物占无条件入栈</span></span><br><span class="line">            <span class="keyword">if</span> (mmax.empty()) &#123;</span><br><span class="line">                mmax.push(t);<span class="comment">//如果是空的，直接入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是空的，比较后入栈大的</span></span><br><span class="line">                mmax.push(max(t, mmax.top()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!g.empty()) &#123;</span><br><span class="line">                g.pop();</span><br><span class="line">                mmax.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.empty()) &#123;<span class="comment">//如果栈此时为空</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; mmax.top() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//不是空，输出极大值栈的栈顶元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-382-报数"><a href="#Oj-382-报数" class="headerlink" title="==Oj-382==. 报数"></a>==Oj-382==. 报数</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201201190350189.png" alt="image-20201201190350189"></p>
<p>解题思路</p>
<blockquote>
<p> 约瑟夫环问题</p>
<p>建立一个人的队列</p>
<p>1234567  第一个人报1  ，安全了扔到队尾2345671</p>
<p>第二个人报数2，安全扔到队尾3456712</p>
<p>第三个人报数3，淘汰 ，不扔到队尾456712</p>
<p>第四个人报数1，安全，扔到队尾567124</p>
<p>当que.size（）== 1的时候吗，输出答案</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, now = <span class="number">1</span>;<span class="comment">//n个人，报数到m的人会被淘汰，now此时报的数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        que.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (que.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now == m) &#123;</span><br><span class="line">            que.pop();<span class="comment">//淘汰</span></span><br><span class="line">            now = <span class="number">1</span>;<span class="comment">//当前报的号重置为1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            que.push(que.front());</span><br><span class="line">            now++;</span><br><span class="line">            que.pop();<span class="comment">//放到队尾后还得把自身弹出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; que.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-384-敲七"><a href="#Oj-384-敲七" class="headerlink" title="Oj-384. 敲七"></a>Oj-384. 敲七</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201201191641742.png" alt="image-20201201191641742"></p>
<p>解题思路</p>
<blockquote>
<p>类似上一题</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Oj-385-海港"><a href="#Oj-385-海港" class="headerlink" title="==Oj-385. 海港=="></a>==Oj-385. 海港==</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201201192027143.png" alt="image-20201201192027143"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201201200732639.png" alt="image-20201201200732639"></p>
<p>解题思路</p>
<blockquote>
<p>队列</p>
<p>队列中可以存船的信息或者人的信息</p>
<p>如何求国家的数量：map键值对，或者开一个大的标记数组</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> t, c;<span class="comment">//队列中存入人的信息：来的时间   国家</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, con, mark[<span class="number">100005</span>];<span class="comment">//船   多少个国家   标记数组存每个国家有多少人</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;person&gt; que;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> at, pcnt;<span class="comment">//到达时间和人数</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;at, &amp;pcnt);</span><br><span class="line">        <span class="keyword">while</span> (!que.empty() &amp;&amp; at - que.front().t &gt;= <span class="number">86400</span>) &#123;<span class="comment">//队列不为</span></span><br><span class="line">            <span class="comment">//空且人是一天之前来的，那就把人赶出去</span></span><br><span class="line">            mark[que.front().c]--;</span><br><span class="line">            <span class="keyword">if</span> (mark[que.front().c] == <span class="number">0</span>) &#123;</span><br><span class="line">                con--;<span class="comment">//如果这个人是国家的最后一个人，那么国家数量-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pcnt; j++) &#123;<span class="comment">//来的船统计一下</span></span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">            que.push((person)&#123;at, temp&#125;);</span><br><span class="line">            mark[temp]++;</span><br><span class="line">            <span class="keyword">if</span> (mark[temp] == <span class="number">1</span>) &#123;</span><br><span class="line">                con++;<span class="comment">//如果是国家的第一个人，国家数+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, con);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201201200629561.png" alt="image-20201201200629561"></p>
<h2 id="Oj-569-溶液模拟器"><a href="#Oj-569-溶液模拟器" class="headerlink" title="Oj-569. 溶液模拟器"></a>Oj-569. 溶液模拟器</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201201201226114.png" alt="image-20201201201226114"></p>
<p>解题思路</p>
<blockquote>
<p>使用栈。加的时候入栈，并且处理一下数据；撤销的时候出栈。</p>
<p>存入盐的质量和总质量</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> s, ws;<span class="comment">//s盐的质量，ws总质量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ws0, c0, s0;<span class="comment">//初始总质量，初始浓度，初始盐</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ws0 &gt;&gt; c0;</span><br><span class="line">    s0 = ws0 * c0 / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">stack</span>&lt;node&gt; sta;<span class="comment">//定义一个栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> t;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="string">&#x27;P&#x27;</span>) &#123;<span class="comment">//说明加入了东西</span></span><br><span class="line">            <span class="keyword">double</span> wst, ct, st;<span class="comment">//临时总质量，浓度，盐</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; wst &gt;&gt; ct;</span><br><span class="line">            st = wst * ct / <span class="number">100</span>;</span><br><span class="line">            ws0 += wst;</span><br><span class="line">            s0 += st;</span><br><span class="line">            sta.push((node)&#123;st, wst&#125;);<span class="comment">//存入栈中，第一个放的是盐 第二个放的是盐+水</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sta.size()) &#123;<span class="comment">//如果栈不为空，有东西才往外弹</span></span><br><span class="line">                ws0 -= sta.top().ws;</span><br><span class="line">                s0 -= sta.top().s;</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %.5f\n&quot;</span>, (<span class="keyword">int</span>)ws0, s0 / ws0 * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-232-用栈实现队列"><a href="#LeetCode-232-用栈实现队列" class="headerlink" title="LeetCode.232 用栈实现队列"></a>LeetCode.232 用栈实现队列</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201202203046333.png" alt="image-20201202203046333"></p>
<p>解题思路</p>
<blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201202204816325.png" alt="image-20201202204816325"></p>
<p>两个栈，从一个栈pop出来push到另外一个栈里面</p>
<p>pop：  把s1所有元素扔到右边s2里，弹出栈顶元素，再把s2所有元荤扔回s1</p>
<p>front（获取队首元素）：把s1所有元素逐个仍达s2，输出栈顶元素，再扔回去</p>
</blockquote>
<p>代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203141715627.png" alt="image-20201203141715627"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203141854887.png" alt="image-20201203141854887"></p>
<h2 id="LeetCode-225-队列模拟一个栈"><a href="#LeetCode-225-队列模拟一个栈" class="headerlink" title="LeetCode.225 队列模拟一个栈"></a>LeetCode.225 队列模拟一个栈</h2><p>解题思路<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203142817833.png" alt="image-20201203142817833"></p>
<blockquote>
<p>一个队列就行了，push的时候，把push的数字前的所有数按顺序push到队列末尾，然后队首元素就是栈顶元素一个</p>
</blockquote>
<h2 id="oj-575-查字典"><a href="#oj-575-查字典" class="headerlink" title="oj-575. 查字典"></a>oj-575. 查字典</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210204112247379.png" alt="image-20210204112247379"></p>
<h2 id="Oj-240-打印图形4"><a href="#Oj-240-打印图形4" class="headerlink" title="==Oj-240==. 打印图形4"></a>==Oj-240==. 打印图形4</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203151700596.png" alt="image-20201203151700596"></p>
<p>解题思路</p>
<blockquote>
<p>递归：将大的问题分解成小问题</p>
<p>图案：字符类型的 二维数组</p>
<p>func（1，1，7）递归函数：在（1，1）点画一个大小为7的图形</p>
<p>注意点：递归边界：什么时候停止递归（当大小n为1的时候，直接画一个x就好）</p>
<p>​                递归式：</p>
</blockquote>
<blockquote>
<p>当n=1，边长为1；</p>
<p>n=2，边长为3；</p>
<p>n=3，边长为9；</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;<span class="comment">//存入边长</span></span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">3000</span>][<span class="number">3000</span>];<span class="comment">//画布</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">        num[i] = num[i - <span class="number">1</span>] * <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        mmap[x][y] = <span class="string">&#x27;X&#x27;</span>;<span class="comment">//递归边界</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    func(x, y, n - <span class="number">1</span>);<span class="comment">//如果不是1，分解成5个小图形</span></span><br><span class="line">    func(x, y + num[n] / <span class="number">3</span> * <span class="number">2</span>, n - <span class="number">1</span>);</span><br><span class="line">    func(x + num[n] / <span class="number">3</span> * <span class="number">2</span>, y, n - <span class="number">1</span>);</span><br><span class="line">    func(x + num[n] / <span class="number">3</span>, y + num[n] / <span class="number">3</span>, n - <span class="number">1</span>);</span><br><span class="line">    func(x + num[n] / <span class="number">3</span> * <span class="number">2</span>, y + num[n] / <span class="number">3</span> * <span class="number">2</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num[t]; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num[t]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mmap[i][j] == <span class="string">&#x27;X&#x27;</span>) &#123;<span class="comment">//如果是x，就输出x</span></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">//否者输出一个空格 </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-235-递归实现指数型枚举"><a href="#Oj-235-递归实现指数型枚举" class="headerlink" title="==Oj-235. 递归实现指数型枚举=="></a>==Oj-235. 递归实现指数型枚举==</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203153916951.png" alt="image-20201203153916951"></p>
<p>解题思路</p>
<blockquote>
<p>递归的一层选一个数字</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203154254855.png" alt="image-20201203154254855"></p>
<p>答案记录在数组中</p>
<p>递归函数的两个参数：一：这一层是从第几层开始选；</p>
<p>​                              二：这一层是第几层。</p>
<p>可以用纸和笔模拟一下</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">15</span>];<span class="comment">//num表示存入的那些数字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> deep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= deep; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> deep)</span> </span>&#123;<span class="comment">//这一层从几开始选    这一层是第几层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= n; i++) &#123;</span><br><span class="line">        num[deep] = i;</span><br><span class="line">        p(deep);<span class="comment">//输出到第几层</span></span><br><span class="line">        func(i + <span class="number">1</span>, deep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只有一个参数，有回溯感   （类似深搜）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">15</span>], cnt;<span class="comment">//cnt表示选到了第几个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= n; i++) &#123;</span><br><span class="line">        num[cnt] = i;</span><br><span class="line">        p();</span><br><span class="line">        cnt++;</span><br><span class="line">        func(i + <span class="number">1</span>);</span><br><span class="line">        cnt--;<span class="comment">//递归回去之后，回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    func(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Oj-236-递归实现组合型枚举"><a href="#Oj-236-递归实现组合型枚举" class="headerlink" title="==Oj-236==. 递归实现组合型枚举"></a>==Oj-236==. 递归实现组合型枚举</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203161123085.png" alt="image-20201203161123085"></p>
<p>解题思路</p>
<blockquote>
<p>如何输出：</p>
<p>func（s, left）: 从几开始选   还剩几个数需要选</p>
<p>递归边界：当left == 0的时候，表示所有数都选完了</p>
<p>讲解视频包含模拟</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203162500643.png" alt="image-20201203162500643"></p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, num[<span class="number">15</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">        p();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= n; i++) &#123;</span><br><span class="line">        num[cnt] = i;</span><br><span class="line">        cnt++;</span><br><span class="line">        func(i + <span class="number">1</span>, left - <span class="number">1</span>);</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    func(<span class="number">1</span>, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-237-递归实现排列性枚举"><a href="#Oj-237-递归实现排列性枚举" class="headerlink" title="==Oj-237.== 递归实现排列性枚举"></a>==Oj-237.== 递归实现排列性枚举</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203162709582.png" alt="image-20201203162709582"></p>
<p>解题思路</p>
<blockquote>
<p>不同点：每一层都是1-n循环</p>
<p>​             引入标记数组，得知道这个数有没有被选过</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">15</span>], mark[<span class="number">15</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> left)</span> </span>&#123;<span class="comment">//传入剩几个数需要选</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;<span class="comment">//递归边界</span></span><br><span class="line">        p();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//每一层都从1开始</span></span><br><span class="line">        <span class="keyword">if</span> (mark[i] == <span class="number">0</span>) &#123;<span class="comment">//没有被占用过，才可以选</span></span><br><span class="line">            mark[i] = <span class="number">1</span>;<span class="comment">//先标记上，占了</span></span><br><span class="line">            num[cnt] = i;<span class="comment">//把数存在对应的位置</span></span><br><span class="line">            cnt++;</span><br><span class="line">            func(left - <span class="number">1</span>);</span><br><span class="line">            cnt--;</span><br><span class="line">            mark[i] = <span class="number">0</span>;<span class="comment">//取消标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    func(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203165114078.png" alt="image-20201203165114078"></p>
<h2 id="排列组合问题的总结"><a href="#排列组合问题的总结" class="headerlink" title="排列组合问题的总结"></a>排列组合问题的总结</h2><blockquote>
<p>递归 240</p>
<p>排列组合三兄弟  235  </p>
<p>​                        236 组合</p>
<p>​                        237 全排列</p>
</blockquote>
<h1 id="排列组合与搜索走地图问题"><a href="#排列组合与搜索走地图问题" class="headerlink" title="排列组合与搜索走地图问题"></a>排列组合与搜索走地图问题</h1><h2 id="搜索的解题套路"><a href="#搜索的解题套路" class="headerlink" title="==搜索的解题套路=="></a>==搜索的解题套路==</h2><blockquote>
<p>1.状态如何定义       存 起 终 转 重</p>
<p>2.起始状态</p>
<p>3.终止状态</p>
<p>4.状态如何转移</p>
<p>5.去重（避免重复搜索）</p>
</blockquote>
<h2 id="什么是深度搜索"><a href="#什么是深度搜索" class="headerlink" title="什么是深度搜索"></a>什么是深度搜索</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203150234617.png" alt="image-20201203150234617"></p>
<blockquote>
<p>搜索与回溯的过程</p>
</blockquote>
<h2 id="什么是搜索走地图问题"><a href="#什么是搜索走地图问题" class="headerlink" title="==什么是搜索走地图问题=="></a>==什么是搜索走地图问题==</h2><blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203170353606.png" alt="image-20201203170353606"></p>
<p>深搜走地图：每次找到下一个点，都以此为起点重新开始走</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203173243828.png" alt="image-20201203173243828"></p>
<p>能否从起点走到终点？？</p>
<ul>
<li>方向数组</li>
<li>存地图</li>
</ul>
<p>func（x,y）: 把起点传入递归函数中，循环四个方向，求出新方向的坐标，判断是否可以走。</p>
<p>如果可以走，递归进行到下一层。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy;<span class="comment">//地图n行m列，起点横坐标和纵坐标</span></span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">105</span>][<span class="number">105</span>];<span class="comment">//定义一个地图</span></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;<span class="comment">//方向数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;<span class="comment">//分别王四个方向去走</span></span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];<span class="comment">//新点的横纵坐标</span></span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//直接走到终点，返回1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">&#x27;.&#x27;</span>) &#123;<span class="comment">//表示可以走</span></span><br><span class="line">            mmap[xx][yy] = <span class="string">&#x27;#&#x27;</span>;<span class="comment">//避免重复搜索，死循环。如果可以走，标记一下</span></span><br><span class="line">            <span class="keyword">if</span> (func(xx, yy) == <span class="number">1</span>) &#123;<span class="comment">//再以此为起点继续往下递归</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//上一层return 1  每一层都return1 最终在主函数return1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//四个方向都走不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;<span class="comment">//判断起点</span></span><br><span class="line">                sx = i, sy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (func(sx, sy) == <span class="number">1</span>) &#123;<span class="comment">//以起点开始去搜返回1</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203175109401.png" alt="image-20201203175109401"></p>
<h2 id="LeetCode-200-岛屿数量"><a href="#LeetCode-200-岛屿数量" class="headerlink" title="==LeetCode-200.岛屿数量=="></a>==LeetCode-200.岛屿数量==</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210204174719964.png" alt="image-20210204174719964"></p>
<blockquote>
<p>深搜，当找到一个岛屿，cnt++，并且将其相连的所有1变成0</p>
</blockquote>
<h2 id="Oj-535-瓷砖"><a href="#Oj-535-瓷砖" class="headerlink" title="==Oj-535==. 瓷砖"></a>==Oj-535==. 瓷砖</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203180540862.png" alt="image-20201203180540862"></p>
<p>解题思路</p>
<blockquote>
<p>深搜，碰到一个点，就以此为起点。并且cnt++</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans = <span class="number">1</span>, sx, sy;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">105</span>][<span class="number">150</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;<span class="comment">//循环四个方向</span></span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];<span class="comment">//每次求出新方向的坐标</span></span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            mmap[xx][yy] = <span class="number">0</span>;<span class="comment">//去重</span></span><br><span class="line">            func(xx, yy);<span class="comment">//以新起点开始继续往下递归</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">&#x27;@&#x27;</span>) &#123;<span class="comment">//读入时判断是否为起点</span></span><br><span class="line">                sx = i, sy = j;<span class="comment">//是就记录坐标 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func(sx, sy);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-397-僵尸来袭"><a href="#Oj-397-僵尸来袭" class="headerlink" title="==Oj-397==. 僵尸来袭"></a>==Oj-397==. 僵尸来袭</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203181613256.png" alt="image-20201203181613256"></p>
<p>解题思路</p>
<blockquote>
<p>求一共有几片连在一起的数字区域</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203181726762.png" alt="image-20201203181726762"></p>
<p>每遇到一个不为0的数字就开始深搜，同时ans++；并且把有数字的都变成0</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans, mmap[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] != <span class="number">0</span>) &#123;</span><br><span class="line">            mmap[xx][yy] = <span class="number">0</span>;</span><br><span class="line">            func(xx, yy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mmap[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;<span class="comment">//遍历整个地图</span></span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                mmap[i][j] = <span class="number">0</span>;</span><br><span class="line">                func(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-536-最大黑色区域"><a href="#Oj-536-最大黑色区域" class="headerlink" title="Oj-536. 最大黑色区域"></a>Oj-536. 最大黑色区域</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203182600122.png" alt="image-20201203182600122"></p>
<p>解题思路</p>
<blockquote>
<p>与上一题题意相近</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans, temp;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            temp++;</span><br><span class="line">            mmap[xx][yy] = <span class="number">0</span>;</span><br><span class="line">            func(xx, yy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; &amp;mmap[i][<span class="number">1</span>];<span class="comment">//如果是存入到mmp[i][0],可以直接写，不然需要取地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">                mmap[i][j] = <span class="number">0</span>;</span><br><span class="line">                func(i, j);</span><br><span class="line">                ans = max(ans, temp);<span class="comment">//更新区域的最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-396-填涂颜色"><a href="#Oj-396-填涂颜色" class="headerlink" title="Oj-396. 填涂颜色"></a>Oj-396. 填涂颜色</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203183643038.png" alt="image-20201203183643038"></p>
<p>解题思路</p>
<blockquote>
<p>被1包住的0无法判断，但是没被1包住的0可以判断</p>
<p>没被1包住的0肯定和地图边缘相连，可以都改成另外一个数字3</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203184315163.png" alt="image-20201203184315163"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203185650745.png" alt="image-20201203185650745"></p>
<p>方法一：遍历整个外圈，如果是0，那肯定和外圈相邻，以他为起点，把所有0改成3</p>
<p>方法二：从（1，1）开始存数据，所以外圈有一圈0，而且是连通的。</p>
<p>​            所以可以从左上角（0，0）点开始搜索，相邻的0都改成3</p>
<p>​            缺点：需要严格判断边界</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, mmap[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">//没有返回值，只是判断连通性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx &gt; n + <span class="number">1</span> || yy &gt; n + <span class="number">1</span>) &#123;<span class="comment">//单独判断边界，说明出界</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] == <span class="number">0</span>) &#123;<span class="comment">//说明是相连的0，改成3</span></span><br><span class="line">            mmap[xx][yy] = <span class="number">3</span>;</span><br><span class="line">            func(xx, yy);<span class="comment">//新点为起点继续深搜</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mmap[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mmap[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">    func(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//00点为起点，开始搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//按要求，根据0，1，3分别输出不同的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mmap[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-404-01迷宫简易版"><a href="#Oj-404-01迷宫简易版" class="headerlink" title="Oj-404. 01迷宫简易版"></a>Oj-404. 01迷宫简易版</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203212909169.png" alt="image-20201203212909169"></p>
<p>解题思路</p>
<blockquote>
<p>输入地图，以题目中给的点为起点深搜。</p>
<p>和之前不一样，就可以走</p>
<p>需要开一个去重数组，访问过的点就标记上</p>
<p>需要判断边界，因为最外面一圈都是0</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mark[<span class="number">3003</span>][<span class="number">3005</span>], ans, sx, sy;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">3005</span>][<span class="number">3005</span>];<span class="comment">//虽然是0和1，但是因为是连着输入的，所以需要字符数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; n || yy &gt; m || mark[xx][yy] == <span class="number">1</span>) &#123;<span class="comment">//表示在标记数组中标记了</span></span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//判断边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mmap[x][y] != mmap[xx][yy]) &#123;<span class="comment">//来的那个点和新求出来的那个点不一样</span></span><br><span class="line">            ans++;</span><br><span class="line">            mark[xx][yy] = <span class="number">1</span>;<span class="comment">//在标记数组里标记上</span></span><br><span class="line">            func(xx, yy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; &amp;mmap[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; sx &gt;&gt; sy;</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    mark[sx][sy] = <span class="number">1</span>;<span class="comment">//标记为1，表示已经搜过</span></span><br><span class="line">    func(sx, sy);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//搜索完毕直接输出答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203220225906.png" alt="image-20201203220225906"></p>
<h2 id="Oj-405-01迷宫"><a href="#Oj-405-01迷宫" class="headerlink" title="==Oj-405==. 01迷宫"></a>==Oj-405==. 01迷宫</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201203222643303.png" alt="image-20201203222643303"></p>
<p>解题思路</p>
<blockquote>
<p>比上一题多了个k次，</p>
<p>方法一：上一个代码循环k次，会超时</p>
<p>方法二：空间换时间，先遍历一遍，把每个点究竟能走到多少提前处理好  用队列暂存数据</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;<span class="comment">//自定义结构坐标，</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line"><span class="keyword">int</span> n, m, k, ans[<span class="number">3005</span>][<span class="number">3005</span>], temp;<span class="comment">//ans存答案以及去重数组，</span></span><br><span class="line"><span class="comment">//temp搜索过程中某一点处一共有几片连同的点</span></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">3005</span>][<span class="number">3005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node t = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        ans[t.x][t.y] = temp;<span class="comment">//每个点上存上有多少个连同点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    que.push((node)&#123;x, y&#125;);<span class="comment">//先把点存入队列中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; n || yy &gt; m || ans[xx][yy] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mmap[x][y] != mmap[xx][yy]) &#123;<span class="comment">//不一样，就可以走</span></span><br><span class="line">            ans[xx][yy] = <span class="number">1</span>;</span><br><span class="line">            temp++;</span><br><span class="line">            func(xx, yy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; &amp;mmap[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;<span class="comment">//从头到尾遍历</span></span><br><span class="line">            <span class="keyword">if</span> (ans[i][j] == <span class="number">0</span>) &#123;<span class="comment">//说明没有走过</span></span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">                ans[i][j] = <span class="number">1</span>;<span class="comment">//标记，表示占了</span></span><br><span class="line">                func(i, j);</span><br><span class="line">                check();<span class="comment">//用队列记录点的信息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[a][b] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是广搜？"><a href="#什么是广搜？" class="headerlink" title="==什么是广搜？=="></a>==什么是广搜？==</h2><blockquote>
<p>需要用到一个队列  搜索队列</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204113004345.png" alt="image-20201204113004345"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204114407894.png" alt="image-20201204114407894"></p>
<p>按照层数来，一层一层往外扩展</p>
<p>经典问题，起点走到终点，并且求出最短步数</p>
<p>因为按层数来，所以最先搜到的一定是最短的</p>
<p>自定义结构：横纵坐标   到这里走了多少步</p>
</blockquote>
<p>广搜走地图的代码演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;<span class="comment">//横纵坐标以及步数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">                sx = i, sy = j;<span class="comment">//记录起点坐标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;<span class="comment">//建立搜索队列</span></span><br><span class="line">    que.push((node)&#123;sx, sy, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;<span class="comment">//当队列不为空就一直搜</span></span><br><span class="line">        node temp = que.front();<span class="comment">//每次拿出队列队首元素状态并且弹出去</span></span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;<span class="comment">//往四个方向走</span></span><br><span class="line">            <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];<span class="comment">//求出新点的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] == <span class="string">&#x27;T&#x27;</span>) &#123;<span class="comment">//如果是终点</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//直接输出答案</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] == <span class="string">&#x27;.&#x27;</span>) &#123;<span class="comment">//如果可以走</span></span><br><span class="line">                mmap[x][y] = <span class="number">0</span>;<span class="comment">//去重，改成不能走</span></span><br><span class="line">                que.push((node)&#123;x, y, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//所有试完了还没有return 0，说明走不到终点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204121922890.png" alt="image-20201204121922890"></p>
<h2 id="Oj-396-填涂颜色广搜版-解决连通性问题"><a href="#Oj-396-填涂颜色广搜版-解决连通性问题" class="headerlink" title="==Oj-396== . 填涂颜色广搜版-解决连通性问题"></a>==Oj-396== . 填涂颜色广搜版-解决连通性问题</h2><p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, mmap[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mmap[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    mmap[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt; n + <span class="number">1</span> || y &gt; n + <span class="number">1</span> || mmap[x][y] == <span class="number">3</span>) &#123;<span class="comment">//判断边界 </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                mmap[x][y] = <span class="number">3</span>;</span><br><span class="line">                que.push((node)&#123;x, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mmap[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204122659294.png" alt="image-20201204122659294"></p>
<h2 id="Oj-399-小明吃饭"><a href="#Oj-399-小明吃饭" class="headerlink" title="==Oj-399==. 小明吃饭"></a>==Oj-399==. 小明吃饭</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204122824762.png" alt="image-20201204122824762"></p>
<p>解题思路</p>
<blockquote>
<p>最短步数，去重直接改原地图</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">                sx = i, sy = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;sx, sy, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] == <span class="string">&#x27;3&#x27;</span>) &#123;<span class="comment">//如果是终点</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] == <span class="string">&#x27;.&#x27;</span>) &#123;<span class="comment">//如果是可以走的点，需要继续搜索</span></span><br><span class="line">                mmap[x][y] = <span class="number">0</span>;</span><br><span class="line">                que.push((node)&#123;x, y, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-304-骑士风度的牛"><a href="#Oj-304-骑士风度的牛" class="headerlink" title="==Oj-304==. 骑士风度的牛"></a>==Oj-304==. 骑士风度的牛</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204123719884.png" alt="image-20201204123719884"></p>
<p>解题思路</p>
<blockquote>
<p>马走日<img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204124935429.png" alt="image-20201204124935429"></p>
<p>难点：11点走有可能会越界  从（2，2）点开始存图  或者直接从（5，5）点</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; n + <span class="number">5</span>; i++) &#123;<span class="comment">//(1,1)开始读到（n,m）结束 （5，5）读从（n+4,m+4）结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">5</span>; j &lt; m + <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">&#x27;K&#x27;</span>) &#123;</span><br><span class="line">                que.push((node)&#123;i, j, <span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;<span class="comment">//循环8个方向</span></span><br><span class="line">            <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                que.push((node)&#123;x, y, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">                mmap[x][y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-398-马的遍历"><a href="#Oj-398-马的遍历" class="headerlink" title="==Oj-398==. 马的遍历"></a>==Oj-398==. 马的遍历</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204130714642.png" alt="image-20201204130714642"></p>
<p>解题思路</p>
<blockquote>
<p>大数组存答案并且去重</p>
<p>点不为0，就不用搜了</p>
<p>最后输出走不了的特殊判断 ： 是不是起点，是不是到不了的点</p>
<p>或者直接初始化为-1，可以避免特判</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">405</span>][<span class="number">405</span>], n, m, sx, sy;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">-1</span>, <span class="keyword">sizeof</span>(num));<span class="comment">//数组都初始化为-1 需要用到头文件</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; sx &gt;&gt; sy;</span><br><span class="line">    num[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;sx, sy, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span> || x &gt; n || y &gt; m || num[x][y] != <span class="number">-1</span>) &#123;<span class="comment">//最后判断是否求过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num[x][y] = temp.step + <span class="number">1</span>;<span class="comment">//上一个点的步数+1</span></span><br><span class="line">            que.push((node)&#123;x, y, num[x][y]&#125;);<span class="comment">//新点放到搜索队列中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; num[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-401-奇怪的象棋游戏升级版"><a href="#Oj-401-奇怪的象棋游戏升级版" class="headerlink" title="Oj-401. 奇怪的象棋游戏升级版"></a>Oj-401. 奇怪的象棋游戏升级版</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204141428797.png" alt="image-20201204141428797"></p>
<p>解题思路</p>
<blockquote>
<p>任一点到（1，1）的距离       》           （1，1）点到任一点的距离</p>
<p>起点与终点调换 ，以（1，1）为起点，往外遍历所有地图，记录答案，结果直接输出对应坐标所存的答案</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">12</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">-1</span>, <span class="keyword">sizeof</span>(num));<span class="comment">//起点是0，避免特判，数组初始化为-1</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;<span class="comment">//建立搜索队列</span></span><br><span class="line">    que.push((node)&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;);<span class="comment">//起点放入搜索队列中</span></span><br><span class="line">    num[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//起点答案初始化一下</span></span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        que.pop();<span class="comment">//拿出队首元素后再弹出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span> || x &gt; <span class="number">500</span> || y &gt; <span class="number">500</span> || num[x][y] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            num[x][y] = temp.step + <span class="number">1</span>;<span class="comment">//记录答案，然后放到搜索队列中</span></span><br><span class="line">            que.push((node)&#123;x, y, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[a][b] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-303-矩阵距离一"><a href="#Oj-303-矩阵距离一" class="headerlink" title="==Oj-303==. 矩阵距离一"></a>==Oj-303==. 矩阵距离一</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204142800570.png" alt="image-20201204142800570"></p>
<p>解题思路</p>
<blockquote>
<p>类似于上一题，以所有的1为起点开始往外走</p>
<p>涉及到输出答案为0，所以可以把数组初始化为-1，再进行去重</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, num[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">1005</span>][<span class="number">1005</span>];<span class="comment">//char数组存真的地图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">-1</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                que.push((node)&#123;i, j, <span class="number">0</span>&#125;);<span class="comment">//放到搜索队列中</span></span><br><span class="line">                num[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//此时，所以1起点都整装待发</span></span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;<span class="comment">//开始广搜</span></span><br><span class="line">        node temp = que.front();<span class="comment">//每次拿出队首元素</span></span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];<span class="comment">//求出新点的坐标，并进行判断</span></span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] != <span class="number">0</span> &amp;&amp; num[x][y] == <span class="number">-1</span>) &#123;<span class="comment">//先判断下有没有出界</span></span><br><span class="line">                <span class="comment">//不为0，说明输入了数据，没出界    </span></span><br><span class="line">                num[x][y] = temp.step + <span class="number">1</span>;</span><br><span class="line">                que.push((node)&#123;x, y, num[x][y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; num[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-305-乳草的入侵"><a href="#Oj-305-乳草的入侵" class="headerlink" title="Oj-305. 乳草的入侵"></a>Oj-305. 乳草的入侵</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204155605619.png" alt="image-20201204155605619"></p>
<p>解题思路</p>
<blockquote>
<p>广搜</p>
<p>起始状态：左下角</p>
<p>终止状态：所有能走过的都做过了，即搜索队列为空时候，所有的点都被占了</p>
<p>问题：如何记录答案：int ans  不断更新ans，</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; sy &gt;&gt; sx;</span><br><span class="line">    sx = n - sx + <span class="number">1</span>;<span class="comment">//在左下角</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; &amp;mmap[i][<span class="number">1</span>];<span class="comment">//一次读一行，因为不需要单独判断是否为起点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;sx, sy, <span class="number">0</span>&#125;);</span><br><span class="line">    mmap[sx][sy] = <span class="number">0</span>;<span class="comment">//避免搜索重复</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        ans = temp.step;<span class="comment">//不用写max，因为最后的肯定是最后进队列的，肯定是最远的那个点</span></span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                mmap[x][y] = <span class="number">0</span>;</span><br><span class="line">                que.push((node)&#123;x, y, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-529-龙与虫"><a href="#Oj-529-龙与虫" class="headerlink" title="==Oj-529==. 龙与虫"></a>==Oj-529==. 龙与虫</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204164336986.png" alt="image-20201204164336986"></p>
<p>解题思路</p>
<blockquote>
<p>预设能干掉敌人终点的位置，以敌人为起点</p>
<p>从绿框出发，走到任意一个蓝框所需要的最短距离</p>
<p>注意：多组数据，地图不可以直接更改，因为还需要用到，所以额外开数组：标记终点1与去重2</p>
<p>一个数组完成两个功能</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204164345653.png" alt="image-20201204164345653"></p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;<span class="comment">//地图大小</span></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">//走的时候只遍历0-3；射击的时候遍历0-7</span></span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">150</span>][<span class="number">150</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="keyword">if</span> (!a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mark[<span class="number">150</span>][<span class="number">150</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a + dir[i][<span class="number">0</span>] * j;</span><br><span class="line">            <span class="keyword">int</span> y = b + dir[i][<span class="number">1</span>] * j;</span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] != <span class="string">&#x27;O&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            mark[x][y] = <span class="number">1</span>;<span class="comment">//标记为1，说明可以射到敌人</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mark[a][b] = <span class="number">1</span>;<span class="comment">//敌人自己这个点本来就可以设到，设为1</span></span><br><span class="line">    <span class="keyword">if</span> (mark[c][d] == <span class="number">1</span>) &#123;<span class="comment">//如果开始的点直接就可以打到敌人</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;c, d, <span class="number">0</span>&#125;);</span><br><span class="line">    mark[c][d] = <span class="number">2</span>;<span class="comment">//标记2，说明走过了</span></span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (mark[x][y] == <span class="number">1</span>) &#123;<span class="comment">//说明能射到敌人</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] == <span class="string">&#x27;O&#x27;</span> &amp;&amp; mark[x][y] != <span class="number">2</span>) &#123;<span class="comment">//如果是可以走的点：可以走，且没走过</span></span><br><span class="line">                que.push((node)&#123;x, y, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">                mark[x][y] = <span class="number">2</span>;<span class="comment">//标记为2，防止重复访问 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Impossible!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; &amp;mmap[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (func()) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="oj-81-小明回家"><a href="#oj-81-小明回家" class="headerlink" title="==oj-81==. 小明回家"></a>==oj-81==. 小明回家</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210205183915611.png" alt="image-20210205183915611"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210206123424298.png" alt="image-20210206123424298"></p>
<blockquote>
<p>按位存储状态</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210205225801732.png" alt="image-20210205225801732"></p>
<p><img src="%E7%BC%96%E7%A0%81%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87.assets/image-20210205225859129.png" alt="image-20210205225859129"></p>
<h2 id="Oj-527-飞跃原野"><a href="#Oj-527-飞跃原野" class="headerlink" title="==Oj-527==. 飞跃原野"></a>==Oj-527==. 飞跃原野</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201204195156840.png" alt="image-20201204195156840"></p>
<blockquote>
<p>终点在于如何去重：三位check数组  根据不同的能量分别去重</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, d, mark[<span class="number">105</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; &amp;mmap[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, d&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        mark[<span class="number">1</span>][<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= temp.d; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>] * j;</span><br><span class="line">                <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>] * j;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span> || x &gt; n || y &gt; m) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x == n &amp;&amp; y == m) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mmap[x][y] == <span class="string">&#x27;P&#x27;</span> &amp;&amp; mark[x][y][temp.d - j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push((node)&#123;x, y, temp.step + <span class="number">1</span>, temp.d - j&#125;);</span><br><span class="line">                    mark[x][y][temp.d - j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x == n &amp;&amp; y == m) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mmap[x][y] == <span class="string">&#x27;P&#x27;</span> &amp;&amp; mark[x][y][temp.d] == <span class="number">0</span>) &#123;</span><br><span class="line">                que.push((node)&#123;x, y, temp.step + <span class="number">1</span>, temp.d&#125;);</span><br><span class="line">                mark[x][y][temp.d] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-528-关系网络"><a href="#Oj-528-关系网络" class="headerlink" title="==Oj-528==. 关系网络"></a>==Oj-528==. 关系网络</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20201205175338514.png" alt="image-20201205175338514"></p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> now, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x, y, check[<span class="number">105</span>], arr[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;x, <span class="number">0</span>&#125;);</span><br><span class="line">    check[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[temp.now][i] == <span class="number">1</span> &amp;&amp; check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == y) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; temp.step &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                que.push((node)&#123;i, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">                check[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-538-图的遍历"><a href="#Oj-538-图的遍历" class="headerlink" title="Oj-538. 图的遍历"></a>Oj-538. 图的遍历</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210309234609338.png" alt="image-20210309234609338"></p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, arr[<span class="number">25</span>][<span class="number">25</span>], check[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; now;</span><br><span class="line">    check[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check[i] == <span class="number">0</span> &amp;&amp; arr[now][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            func(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            func(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-402-奇怪的电梯"><a href="#Oj-402-奇怪的电梯" class="headerlink" title="==Oj-402==. 奇怪的电梯"></a>==Oj-402==. 奇怪的电梯</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210309234929231.png" alt="image-20210309234929231"></p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> now, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, b, num[<span class="number">205</span>], check[<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;a, <span class="number">0</span>&#125;);</span><br><span class="line">    check[a] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">int</span> up = temp.now + num[temp.now], down = temp.now - num[temp.now];</span><br><span class="line">        <span class="keyword">if</span> (up == b || down == b) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (up &lt;= n &amp;&amp; check[up] == <span class="number">0</span>) &#123;</span><br><span class="line">            que.push((node)&#123;up, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">            check[up] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (down &gt;= <span class="number">1</span> &amp;&amp; check[down] == <span class="number">0</span>) &#123;</span><br><span class="line">            que.push((node)&#123;down, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">            check[down] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-530-警察找车"><a href="#Oj-530-警察找车" class="headerlink" title="==Oj-530==. 警察找车"></a>==Oj-530==. 警察找车</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210309235015442.png" alt="image-20210309235015442"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210206235110643.png" alt="image-20210206235110643"></p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                que.push((node)&#123;i, j&#125;);</span><br><span class="line">                mmap[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; cnt;</span><br><span class="line">    <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="keyword">int</span> dir_num, check[<span class="number">55</span>][<span class="number">55</span>] = &#123;<span class="number">0</span>&#125;, qsize = que.size();</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">&quot;NORTH&quot;</span>) &#123;</span><br><span class="line">            dir_num = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">&quot;SOUTH&quot;</span>) &#123;</span><br><span class="line">            dir_num = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str == <span class="string">&quot;WEST&quot;</span>) &#123;</span><br><span class="line">            dir_num = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dir_num = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (qsize--) &#123;</span><br><span class="line">            node temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = temp.x + dir[dir_num][<span class="number">0</span>] * i;</span><br><span class="line">                <span class="keyword">int</span> y = temp.y + dir[dir_num][<span class="number">1</span>] * i;</span><br><span class="line">                <span class="keyword">if</span> (mmap[x][y] != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (check[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push((node)&#123;x, y&#125;);</span><br><span class="line">                    check[x][y] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        mmap[temp.x][temp.y] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; &amp;mmap[i][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-531-奇怪的电视"><a href="#Oj-531-奇怪的电视" class="headerlink" title="==Oj-531==. 奇怪的电视"></a>==Oj-531==. 奇怪的电视</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210309235145875.png" alt="image-20210309235145875"></p>
<p>解题思路</p>
<blockquote>
<p>按位与状态</p>
<p>int 有32位，可以存32个不同的状态</p>
<p>1表示按下去，0表示释放</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210207001750214.png" alt="image-20210207001750214"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210207113731645.png" alt="image-20210207113731645"></p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> status, step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num2[<span class="number">22</span>] = &#123;<span class="number">1</span>&#125;, check[<span class="number">2200000</span>], num[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">        num2[i] = num2[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">            start += num2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t2;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; t2;</span><br><span class="line">            num[i] += num2[t2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    que.push((node)&#123;start, <span class="number">0</span>&#125;);</span><br><span class="line">    check[start] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        node temp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">if</span> (temp.status == <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; temp.step &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((temp.status &amp; num2[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = temp.status;</span><br><span class="line">                t &amp;= ~num[i];</span><br><span class="line">                t |= num2[i];</span><br><span class="line">                <span class="keyword">if</span> (check[t] == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push((node)&#123;t, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">                    check[t] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210207113007657.png" alt="image-20210207113007657"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210207112839262.png" alt="image-20210207112839262"></p>
<h2 id="Oj-537-门票问题"><a href="#Oj-537-门票问题" class="headerlink" title="==Oj-537==. 门票问题"></a>==Oj-537==. 门票问题</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210309235225606.png" alt="image-20210309235225606"></p>
<p>解题思路</p>
<blockquote>
<p>同236</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l, c, cnt, ynum, fnum;</span><br><span class="line"><span class="keyword">char</span> num[<span class="number">30</span>], ans[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> deep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep == l) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ynum &gt;= <span class="number">1</span> &amp;&amp; fnum &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            p();</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">25000</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt; c; i++) &#123;</span><br><span class="line">        ans[deep] = num[i];</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[i] == <span class="string">&#x27;a&#x27;</span> || num[i] == <span class="string">&#x27;e&#x27;</span> || num[i] == <span class="string">&#x27;i&#x27;</span> || num[i] == <span class="string">&#x27;o&#x27;</span> || num[i] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">            ynum++;</span><br><span class="line">            f = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fnum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (func(i + <span class="number">1</span>, left - <span class="number">1</span>, deep + <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">0</span>) &#123;</span><br><span class="line">            fnum--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ynum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(num, num + c);</span><br><span class="line">    func(<span class="number">0</span>, l, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-540-生日购物"><a href="#Oj-540-生日购物" class="headerlink" title="==Oj-540==. 生日购物"></a>==Oj-540==. 生日购物</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210309235303174.png" alt="image-20210309235303174"></p>
<p>解题思路</p>
<blockquote>
<p>同235</p>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Oj-541-相遇问题"><a href="#Oj-541-相遇问题" class="headerlink" title="==Oj-541==. 相遇问题"></a>==Oj-541==. 相遇问题</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210309235342805.png" alt="image-20210309235342805"></p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">2</span>][<span class="number">20</span>][<span class="number">20</span>], ans[<span class="number">2</span>][<span class="number">100000</span>], cnt[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> pnum, <span class="keyword">int</span> now, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now == n) &#123;</span><br><span class="line">        ans[pnum][cnt[pnum]++] = cost;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = now + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[pnum][now][i] != <span class="number">0</span>) &#123;</span><br><span class="line">            func(pnum, i, cost + arr[pnum][now][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        arr[<span class="number">0</span>][a][b] = arr[<span class="number">0</span>][b][a] = c;</span><br><span class="line">        arr[<span class="number">1</span>][a][b] = arr[<span class="number">1</span>][b][a] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    func(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> fin = <span class="number">2100000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fin &lt; ans[<span class="number">0</span>][i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt[<span class="number">1</span>]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[<span class="number">0</span>][i] == ans[<span class="number">1</span>][j]) &#123;</span><br><span class="line">                fin = ans[<span class="number">0</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fin == <span class="number">2100000000</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;IMPOSSIBLE&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210207123232542.png" alt="image-20210207123232542"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210207123302717.png" alt="image-20210207123302717"></p>
<h2 id="Oj-542-奶酪"><a href="#Oj-542-奶酪" class="headerlink" title="==Oj-542==. 奶酪"></a>==Oj-542==. 奶酪</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210309235451717.png" alt="image-20210309235451717"></p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, h, r, s[<span class="number">1005</span>], scnt, e[<span class="number">1005</span>], arr[<span class="number">1005</span>][<span class="number">1005</span>], check[<span class="number">1005</span>], ball[<span class="number">1005</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e[now] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[now][i] &amp;&amp; check[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            check[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (func(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        scnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="built_in">memset</span>(check, <span class="number">0</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; h &gt;&gt; r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ball[i][<span class="number">0</span>] &gt;&gt; ball[i][<span class="number">1</span>] &gt;&gt; ball[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (ball[i][<span class="number">2</span>] &lt;= r) &#123;</span><br><span class="line">                s[scnt++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ball[i][<span class="number">2</span>] + r &gt;= h) &#123;</span><br><span class="line">                e[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x0 = ball[i][<span class="number">0</span>] - ball[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y0 = ball[i][<span class="number">1</span>] - ball[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> z0 = ball[i][<span class="number">2</span>] - ball[j][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">sqrt</span>(x0 * x0 + y0 * y0 + z0 * z0) &lt;= <span class="number">2</span> * r) &#123;</span><br><span class="line">                    arr[i][j] = arr[j][i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scnt; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check[s[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                check[s[i]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (func(s[i])) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    f = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-417-太平洋大西洋水流问题"><a href="#LeetCode-417-太平洋大西洋水流问题" class="headerlink" title="LeetCode.417 太平洋大西洋水流问题"></a>LeetCode.417 太平洋大西洋水流问题</h2><blockquote>
<p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p>
</blockquote>
<p>提示：</p>
<p>输出坐标的顺序不重要<br>m 和 n 都小于150</p>
<p>示例：</p>
<p>给定下面的 5x5 矩阵:</p>
<p>  太平洋 ~   ~   ~   ~   ~<br>       ~  1   2   2   3  (5) *<br>       ~  3   2   3  (4) (4) *<br>       ~  2   4  (5)  3   1  *<br>       ~ (6) (7)  1   4   5  *<br>       ~ (5)  1   1   2   4  *<br>          *   *   *   *   * 大西洋</p>
<p>返回:</p>
<p>[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow">https://leetcode-cn.com/problems/pacific-atlantic-water-flow</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n, m, check[<span class="number">155</span>][<span class="number">155</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pacificAtlantic(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (matrix.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            que.push((node)&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line">            check[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            que.push((node)&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">            check[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            node temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == n || y == m || check[x][y] == <span class="number">1</span> || </span><br><span class="line">                    matrix[temp.x][temp.y] &gt; matrix[x][y]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                que.push((node)&#123;x, y&#125;);</span><br><span class="line">                check[x][y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            que.push((node)&#123;i, m - <span class="number">1</span>&#125;);</span><br><span class="line">            check[i][m - <span class="number">1</span>] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            que.push((node)&#123;n - <span class="number">1</span>, i&#125;);</span><br><span class="line">            check[n - <span class="number">1</span>][i] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            node temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span> (check[temp.x][temp.y] == <span class="number">3</span>) &#123;</span><br><span class="line">                ans.push_back((<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;)&#123;temp.x, temp.y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == n || y == m || (check[x][y] &amp; <span class="number">2</span>) ||</span><br><span class="line">                    matrix[temp.x][temp.y] &gt; matrix[x][y]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                que.push((node)&#123;x, y&#125;);</span><br><span class="line">                check[x][y] += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-529-扫雷游戏"><a href="#LeetCode-529-扫雷游戏" class="headerlink" title="==LeetCode.529== 扫雷游戏"></a>==LeetCode.529== 扫雷游戏</h2><p>让我们一起来玩扫雷游戏！</p>
<p>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。</p>
<p>现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p>
<p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。<br>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。<br>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。<br>如果在此次点击中，若无更多方块可被揭露，则返回面板。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minesweeper">https://leetcode-cn.com/problems/minesweeper</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;mmap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx == n || yy == m) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t += (mmap[xx][yy] == <span class="string">&#x27;M&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; updateBoard(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; click) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> board;</span><br><span class="line">        &#125;</span><br><span class="line">        n = board.size(), m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (func(click[<span class="number">0</span>], click[<span class="number">1</span>], board) == <span class="number">0</span>) &#123;</span><br><span class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">            que.push((node)&#123;click[<span class="number">0</span>], click[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = func(click[<span class="number">0</span>], click[<span class="number">1</span>], board) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> board;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            node temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == n || y == m || board[x][y] != <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> t = func(x, y, board);</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="number">0</span>) &#123;</span><br><span class="line">                    board[x][y] = t + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    board[x][y] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">                    que.push((node)&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-934-最短的桥"><a href="#LeetCode-934-最短的桥" class="headerlink" title="LeetCode.934 最短的桥"></a>LeetCode.934 最短的桥</h2><p>在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）</p>
<p>现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。</p>
<p>返回必须翻转的 0 的最小数目。（可以保证答案至少是 1。）</p>
<p>示例 1：</p>
<p>输入：[[0,1],[1,0]]<br>输出：1<br>示例 2：</p>
<p>输入：[[0,1,0],[0,0,0],[0,0,1]]<br>输出：2<br>示例 3：</p>
<p>输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br>输出：1</p>
<p>提示：</p>
<p>1 &lt;= A.length = A[0].length &lt;= 100<br>A[i][j] == 0 或 A[i][j] == 1</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shortest-bridge">https://leetcode-cn.com/problems/shortest-bridge</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, step;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;mmap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx == n || yy == m) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] == <span class="number">1</span>) &#123;</span><br><span class="line">                mmap[xx][yy] = <span class="number">2</span>;</span><br><span class="line">                que.push((node)&#123;xx, yy, <span class="number">0</span>&#125;);</span><br><span class="line">                func(xx, yy, mmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        n = A.size(), m = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    A[i][j] = <span class="number">2</span>;</span><br><span class="line">                    que.push((node)&#123;i, j, <span class="number">0</span>&#125;);</span><br><span class="line">                    func(i, j, A);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!que.empty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            node temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == n || y == m) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (A[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> temp.step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (A[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">                    A[x][y] = <span class="number">2</span>;</span><br><span class="line">                    que.push((node)&#123;x, y, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-967-连续差相同的数字"><a href="#LeetCode-967-连续差相同的数字" class="headerlink" title="==LeetCode.967== 连续差相同的数字="></a>==LeetCode.967== 连续差相同的数字=</h2><p>返回所有长度为 N 且满足其每两个连续位上的数字之间的差的绝对值为 K 的非负整数。</p>
<p>请注意，除了数字 0 本身之外，答案中的每个数字都不能有前导零。例如，01 因为有一个前导零，所以是无效的；但 0 是有效的。</p>
<p>你可以按任何顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：N = 3, K = 7<br>输出：[181,292,707,818,929]<br>解释：注意，070 不是一个有效的数字，因为它有前导零。<br>示例 2：</p>
<p>输入：N = 2, K = 1<br>输出：[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]</p>
<p>提示：</p>
<p>1 &lt;= N &lt;= 9<br>0 &lt;= K &lt;= 9</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/numbers-with-same-consecutive-differences">https://leetcode-cn.com/problems/numbers-with-same-consecutive-differences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> left, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.push_back(now);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now % <span class="number">10</span> + k &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            func(now * <span class="number">10</span> + now % <span class="number">10</span> + k, left - <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="number">0</span> &amp;&amp; now % <span class="number">10</span> - k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            func(now * <span class="number">10</span> + now % <span class="number">10</span> - k, left - <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numsSameConsecDiff</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            func(i, n - <span class="number">1</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-752-打开转盘锁"><a href="#LeetCode-752-打开转盘锁" class="headerlink" title="==LeetCode.752==打开转盘锁"></a>==LeetCode.752==打开转盘锁</h2><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为  ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p>
<p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p>
<p>示例 1:</p>
<p>输入：deadends = [“0201”,”0101”,”0102”,”1212”,”2002”], target = “0202”<br>输出：6<br>解释：<br>可能的移动序列为 “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”。<br>注意 “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” 这样的序列是不能解锁的，<br>因为当拨动到 “0102” 时这个锁就会被锁定。<br>示例 2:</p>
<p>输入: deadends = [“8888”], target = “0009”<br>输出：1<br>解释：<br>把最后一位反向旋转一次即可 “0000” -&gt; “0009”。<br>示例 3:</p>
<p>输入: deadends = [“8887”,”8889”,”8878”,”8898”,”8788”,”8988”,”7888”,”9888”], target = “8888”<br>输出：-1<br>解释：<br>无法旋转到目标数字且不被锁定。<br>示例 4:</p>
<p>输入: deadends = [“0000”], target = “8888”<br>输出：-1</p>
<p>提示：</p>
<p>死亡列表 deadends 的长度范围为 [1, 500]。<br>目标数字 target 不会在 deadends 之中。<br>每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 ‘0000’ 到 ‘9999’ 中产生。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/open-the-lock">https://leetcode-cn.com/problems/open-the-lock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="built_in">string</span> status;</span><br><span class="line">        <span class="keyword">int</span> step;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deadends.size(); i++) &#123;</span><br><span class="line">            m[deadends[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="string">&quot;0000&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m[<span class="string">&quot;0000&quot;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">        que.push((node)&#123;<span class="string">&quot;0000&quot;</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        m[<span class="string">&quot;0000&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            node temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">string</span> t = temp.status;</span><br><span class="line">                t[i]++;</span><br><span class="line">                <span class="keyword">if</span> (t[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    t[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> temp.step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (m[t] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m[t] = <span class="number">1</span>;</span><br><span class="line">                    que.push((node)&#123;t, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                t = temp.status;</span><br><span class="line">                t[i]--;</span><br><span class="line">                <span class="keyword">if</span> (t[i] &lt; <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    t[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (t == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> temp.step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (m[t] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m[t] = <span class="number">1</span>;</span><br><span class="line">                    que.push((node)&#123;t, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-864-获取所有钥匙的最短路径"><a href="#LeetCode-864-获取所有钥匙的最短路径" class="headerlink" title="==LeetCode-864==. 获取所有钥匙的最短路径"></a>==LeetCode-864==. 获取所有钥匙的最短路径</h2><p>给定一个二维网格 grid。 “.” 代表一个空房间， “#” 代表一堵墙， “@” 是起点，（”a”, “b”, …）代表钥匙，（”A”, “B”, …）代表锁。</p>
<p>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</p>
<p>假设 K 为钥匙/锁的个数，且满足 1 &lt;= K &lt;= 6，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。</p>
<p>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</p>
<p>示例 1：</p>
<p>输入：[“@.a.#”,”###.#”,”b.A.B”]<br>输出：8<br>示例 2：</p>
<p>输入：[“@..aA”,”..B#.”,”….b”]<br>输出：6</p>
<p>提示：</p>
<p>1 &lt;= grid.length &lt;= 30<br>1 &lt;= grid[0].length &lt;= 30<br>grid[i][j] 只含有 ‘.’, ‘#’, ‘@’, ‘a’-‘f’ 以及 ‘A’-‘F’<br>钥匙的数目范围是 [1, 6]，每个钥匙都对应一个不同的字母，正好打开一个对应的锁。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shortest-path-to-get-all-keys">https://leetcode-cn.com/problems/shortest-path-to-get-all-keys</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, status, step;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n, m, check[<span class="number">35</span>][<span class="number">35</span>][<span class="number">200</span>], key_cnt = <span class="number">0</span>, end_status;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> bit2[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathAllKeys</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;mmap = grid;</span><br><span class="line">        n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;node&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mmap[i][j] == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">                    que.push((node)&#123;i, j, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">                    check[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                    mmap[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mmap[i][j] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; mmap[i][j] &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">                    key_cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end_status = bit2[key_cnt] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            node temp = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span> (temp.status == end_status) &#123;</span><br><span class="line">                <span class="keyword">return</span> temp.step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x == n || y == m || check[x][y][temp.status] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mmap[x][y] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    check[x][y][temp.status] = <span class="number">1</span>;</span><br><span class="line">                    que.push((node)&#123;x, y, temp.status, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mmap[x][y] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; mmap[x][y] &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">                    check[x][y][temp.status] = <span class="number">1</span>;</span><br><span class="line">                    check[x][y][temp.status | bit2[mmap[x][y] - <span class="string">&#x27;a&#x27;</span>]] = <span class="number">1</span>;</span><br><span class="line">                    que.push((node)&#123;x, y, temp.status | bit2[mmap[x][y] - <span class="string">&#x27;a&#x27;</span>], temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mmap[x][y] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; mmap[x][y] &lt;= <span class="string">&#x27;F&#x27;</span> &amp;&amp; (temp.status &amp; bit2[mmap[x][y] - <span class="string">&#x27;A&#x27;</span>])) &#123;</span><br><span class="line">                    check[x][y][temp.status] = <span class="number">1</span>;</span><br><span class="line">                    que.push((node)&#123;x, y, temp.status, temp.step + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Oj-539-速算游戏"><a href="#Oj-539-速算游戏" class="headerlink" title="Oj-539. 速算游戏"></a>Oj-539. 速算游戏</h2><p><img src="https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210207130019040.png" alt="image-20210207130019040"></p>
<p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="LeetCode127-单词接龙"><a href="#LeetCode127-单词接龙" class="headerlink" title="LeetCode127. 单词接龙"></a><code>LeetCode127</code>. 单词接龙</h2><p>解题思路</p>
<blockquote>
</blockquote>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>完结</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
