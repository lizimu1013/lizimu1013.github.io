{"meta":{"title":"zimuのblog","subtitle":"","description":"","author":"Zimu","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"算法","slug":"算法上","date":"2021-03-09T13:48:18.939Z","updated":"2021-03-09T15:56:49.492Z","comments":true,"path":"2021/03/09/算法上/","link":"","permalink":"http://example.com/2021/03/09/%E7%AE%97%E6%B3%95%E4%B8%8A/","excerpt":"","text":"语法入门如何读入带空格的字符串12scanf(&quot;%[^\\n]s&quot;, str);getchar(); 如何随机一个数组 sort 对于int 类型数组排序： 假如有一个数组，int num [100], 值为0~（n-1）； 1sort(num, num + n);//从小到大， num[0] - num[n-1]排序 对于int 来说，不需要传参数，可以直接比较大小；但是对于自定义类型排序，需要自己传入排序方法； 123456789struct node &#123; int x;&#125;;node n[105];//n[0]到n[m-1]排序sort(n, n + m, cmp)//从n排到n+m，用cmp方法排序comparebool cmp(node a, node b) &#123;//a表示前面的元素，b后面的元素，表示他们的相对关系 return a.x &gt; b.x;//排好序后，a的x大于b的x&#125; 二分查找 ==朴素的二分查找== 一个大数组，左边界和右边界左右边界求mid 查看mid的值是否符合要求，假如mid小于所要查找的值，则连同mid以及mid左侧的值全部淘汰，左指针设到mid+1处。 string类的用法12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;//string是一个类using namespace std;string str;//建立一个shring对象，存入大整数int n;//表示删掉几位数int main() &#123; cin &gt;&gt; str &gt;&gt; n;//输入大整数 for (int i = 0; i &lt; n; i++) &#123;//循环n次，每次删掉一个数 int ind = str.size() - 1;//默认索引为字符串长度-1 for (int j = 0; j &lt; str.size() - 1; j++) &#123; if (str[j] &gt; str[j + 1]) &#123;//不满足前小后大 ind = j; break; &#125; &#125; str.replace(ind, 1, &quot;&quot;);//string类中的替换函数：位置ind，长度1，替换成“ ” &#125; int f = 0; for (int i = 0; i &lt; str.size(); i++) &#123;//判断是否有前导0 if (str[i] != &#x27;0&#x27;) &#123;//不是字符0， f = 1;//0_flag置为1 &#125; if (f == 1) &#123; cout &lt;&lt; str[i]; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 编码能力提升1. 欧拉-15（路径问题） 解题思路： 对于每个点，有不同的方案数； 为了避免越界，从（1 ，1）点开始存； 方法一：递归法 某一点的方案数 = 左边的方案数 + 上面的方案数 代码：123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; long long dp[25][25] = &#123;0&#125;;//递推数组（多加5） for (int i = 1; i &lt;= 21; i++) &#123; for (int j = 1; j &lt;= 21; j++) &#123;//20 * 20格子右下角为21 if (i == 1 &amp;&amp; j == 1) &#123;//需要初始化最左上角为（1,1） dp[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125; &#125; cout &lt;&lt; dp[21][21] &lt;&lt; endl; return 0;&#125; 方法二：数学方法 左上走到右下一共路径数为 4； 往下走2步，往右走2步； 从4步里选出两步往下走: （4 * 3） / （2 * 1） C^20^ 40 1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; long long ans = 1; for (int i = 40, j = 1; i &gt; 20; i--, j++) &#123; ans *= i; ans /= j; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; 2. 欧拉-18 (数学三角形：数塔问题) 求从下面展示的三角形顶端出发到达底部，所能够得到的最大路径和： 解题思路：方法一：从上往下 (x-1,y-1) (x-1,y) (x,y) 从哪一个路径下来，取决于上面两个数谁大。 1dp[i][j] = max(dp[i-1][j-1], dp[i-1][j-1]); 对于某个点，只能从左上方或正上面过来，并且取决于两者的最大值； 遍历一遍最后一排，取一个最大值。 可以在最外面加一层0，避免特殊判断； 代码1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int n, num[20][20], ans[20][20];//num为元数据，ans为计算和int main() &#123; n = 15; for (int i = 1; i &lt;= n; i++) &#123;//从（1,1）开始从，外圈为0 for (int j = 1; j &lt;= i; j++) &#123; cin &gt;&gt; num[i][j];//输入数组 &#125; &#125; int fin = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123;//从左上方和正上方求和 ans[i][j] = max(ans[i - 1][j - 1], ans[i - 1][j]) + num[i][j];//num[i][j]为自己的值 fin = max(fin, ans[i][j]);//不断更新答案 &#125; &#125; cout &lt;&lt; fin &lt;&lt; endl; return 0;&#125; 方法二：从下往上算 上面一个代码只能是正下和右下代码过来； 算到最后，最上面的就是答案。 代码123456789101112131415161718#include &lt;iostream&gt;using namespace std;int n, num[20][20], ans[20][20];int main() &#123; n = 15; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; cin &gt;&gt; num[i][j]; &#125; &#125; for (int i = n; i &gt; 0; i--) &#123; for (int j = 1; j &lt;= i; j++) &#123; ans[i][j] = max(ans[i + 1][j], ans[i + 1][j + 1]) + num[i][j];//正下方和右下方过来 &#125; &#125; cout &lt;&lt; ans[1][1] &lt;&lt; endl;//最后求得的结果即为答案 return 0;&#125; 3. oj-590 (数塔狂想曲)求最长路径和 解题思路 每次只搬掉一个点：搬掉（2,2），结果为17；搬掉（5,4），结果为22；搬掉（1,1），无法走，输出-1； 最暴力办法是每次重新跑一遍，但会很耗时； 方法一：上下结合结合==从上到下==和==从下到上== 对于每一行来说，都有一个最大路径 结合红色（从上往下所有路径和）和绿色表格，能求出某个点的最大路径 经过黑框点，18 + 8 - 4 = 22（-4是因为经过了两次） 再记录一个次大的点（假如最大的点被ban了，取次大点的值） 对于每一行，只需判断是否ban掉的值为最大值；是则输出次大值，否则输出最大值 ==从下往上最大路径为8，从下往上最大路径为18，但同时，4那个点加了两次，所以需要删去一个== 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;//scanf需要，避免超时using namespace std;//up to down | down to up//num存的原始的数//ans 为经过每个点，最大路径和（不需要）//mmax 0记录最大值的那个点的坐标，第二行1记录次大值//n表示n行int n, m, num[1005][1005], utd[1005][1005], dtu[1005][1005], ans[1005][1005], mmax[1005][2];int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; scanf(&quot;%d&quot;, &amp;num[i][j]); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; utd[i][j] = max(utd[i - 1][j - 1], utd[i - 1][j]) + num[i][j]; &#125;//从上往下求答案 &#125; for (int i = n; i &gt; 0; i--) &#123; for (int j = 1; j &lt;= i; j++) &#123; dtu[i][j] = max(dtu[i + 1][j], dtu[i + 1][j + 1]) + num[i][j]; &#125;//从下往上求答案 &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; //求出ans ans[i][j] = utd[i][j] + dtu[i][j] - num[i][j]; &#125; &#125; //对于每行来说，求出最大值与次大值 for (int i = 1; i &lt;= n; i++) &#123; int m2 = 0, m1 = 0, cnt = 0; for (int j = 1; j &lt;= i; j++) &#123; if (ans[i][j] &gt; m1) &#123;//判断是否为最大值 m2 = m1;//次大值赋值为最大值 m1 = ans[i][j]; cnt = j; &#125; else if (m2 &lt; ans[i][j]) &#123; m2 = ans[i][j];//否则如果 更新m2，避免漏掉（如果第一个点为最大值，则次大值永远无法更新） &#125; &#125; mmax[i][0] = cnt;//对于第i行的0表示下标，1表示次大值 mmax[i][1] = m2; &#125; for (int i = 0; i &lt; m; i++) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (a == 1 &amp;&amp; b == 1) &#123; printf(&quot;-1\\n&quot;);//搬掉最上点，才输出-1 &#125; else if (mmax[a][0] == b) &#123;//ban掉最大值，输出次大值 printf(&quot;%d\\n&quot;, mmax[a][1]); &#125; else &#123;//否则正常输出最大值； printf(&quot;%d\\n&quot;, dtu[1][1]); &#125; &#125; return 0;&#125; 4. 欧拉-22 (姓名得分) 解题思路： ==暴力破解== ==难点：==数据处理，执行替换 将“，”替换成空格 /g表示全文替换； 代码12345678910111213141516171819202122232425262728 &gt; File Name: euler22.cpp &gt; Author: &gt; Mail: &gt; Created Time: Sat 21 Nov 2020 01:53:29 PM CST ************************************************************************/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;int main() &#123; int n = 0;//表示最终字符串有多少个 string name[6005]; while (cin &gt;&gt; name[n]) &#123; n++;//循环读入，知道数据读完 &#125; sort(name, name + n);//从name开始排到name+n这个位置，从小到大 long long ans = 0; for (int i = 0; i &lt; n; i++) &#123;//遍历字符串数组 int t = 0; for (int j = 0; j &lt; name[i].size(); j++) &#123;//到第i个字符串的大小为止 t += name[i][j] - &#x27;A&#x27; + 1;//从1开始算，不是从0开始算 &#125; ans += t * (i + 1);//乘上对应的系数 &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 5. 欧拉-32（数字位数计算） 解题思路：​ ==暴力枚举== 是否为9位数 避免重复运算：枚举时候第一个数字比第二个数字要大； 第一个数字范围：1-100（超过100的话，101 * 102大于五位数了，不只9位数了） 第二个数字范围：第一个数字长度a + 第二个数字长度b + 结果长度c &gt; 9 的时候停止 只有==9的时候需要判断是否为全数字 是否为全数字 定义一个数组 int num[10] ; 数的每一位拆开放在数组的对应位置里面，如果有个位置已经放入了数字，则不是全数字 987 + 129 放入数组中，num[7] = 1, num [8] = 1, num[9] = 1; num [9] = 1,重复了，所以不是全数字。 只计算一次乘积 定义一个去重数组 int mark[10000],如果乘积出现过，标记为1.如果发现乘积运算过，则跳过 ==如何确定一个数的位数：== log 10^123^ = 2.*** 对于2.***：先下取整，再 +1；（不是上取整，因为log10^100^=2, 上下取整都为2） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/************************************************************************* &gt; File Name: euler32.cpp &gt; Author: &gt; Mail: &gt; Created Time: Sat 21 Nov 2020 02:51:52 PM CST ************************************************************************/#include &lt;iostream&gt;#include &lt;cmath&gt;//数学库using namespace std;int digit(int x) &#123;//判断一个数字有几位 return (int)floor(log10(x)) + 1;//对于x取以10为底的对数，并向下取整； //floor 返回值为double类型，强转为int&#125;int check(int x, int *num) &#123;//x为第二个传入的是数组；判断是否重复 while (x) &#123;//把数字的每一位拿出来放到对应的位置离 if (num[x % 10] == 1) &#123;//最后一位 return 0; &#125; num[x % 10] = 1;//置0 x /= 10;//缩位 &#125; return 1;&#125;int func(int a, int b, int c) &#123;//判断是否为全数字 int num[10] = &#123;1&#125;; if (check(a, num) == 0) return 0; if (check(b, num) == 0) return 0; if (check(c, num) == 0) return 0; return 1;//真的是全数字&#125;int main() &#123; int ans = 0, mark[10005] = &#123;0&#125;; for (int i = 1; i &lt; 100; i++) &#123;//枚举第一个数 for (int j = i + 1; 1; j++) &#123;//第二个数 int a = digit(i), b = digit(j), c = digit(i * j); if (a + b + c == 9) &#123; if (func(i, j, i * j)) &#123;//判断是否为全数字 if (mark[i * j] == 0) &#123; mark[i * j] = 1;//只有新的答案才被标记 ans += i * j; &#125; cout &lt;&lt; i &lt;&lt; &quot; * &quot; &lt;&lt; j &lt;&lt; &quot; = &quot; &lt;&lt; i * j &lt;&lt; endl; &#125; &#125; else if (a + b + c &gt; 9) &#123;//分为大于和小于，小于不需要操作 break; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 6. 欧拉-33（十字相乘） 解题思路： 从11-99 枚举分子；从i+1 - 99枚举分母； 共有四种结果；分别枚举出来，运用十字相乘法判断约分后与原分数是否相等。 难点：如何用辗转相除法进行约分 代码：12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int check(int a, int b) &#123;//传入分子和分母 int x1 = a / 10, x2 = a % 10; int y1 = b / 10, y2 = b % 10; if (!x1 || !x2 || !y1 || !y2) return 0;//有零为平凡值，不成立 if (x1 == y1 &amp;&amp; a * y2 == b * x2) return 1;//十字相乘，判断是否相等 if (x1 == y2 &amp;&amp; a * y1 == b * x2) return 1; if (x2 == y1 &amp;&amp; a * y2 == b * x1) return 1; if (x2 == y2 &amp;&amp; a * y1 == b * x1) return 1; return 0;//如果都不成立，返回0；&#125;int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a % b);//辗转相除法 求公倍数&#125;int main() &#123; int a = 1, b = 1;//答案的分子和分母 for (int i = 11; i &lt; 100; i++) &#123;//枚举分子 for (int j = i + 1; j &lt; 100; j++) &#123;//枚举分母 if (check(i, j)) &#123;//符合题意，是一个特殊的分数 a *= i; b *= j; cout &lt;&lt; i &lt;&lt; &quot; / &quot; &lt;&lt; j &lt;&lt; endl; &#125; &#125; &#125; int c = gcd(a, b); cout &lt;&lt; b / c &lt;&lt; endl; return 0;&#125; 7. 欧拉-36 （双进制回文数） 解题思路 输入时候有前导0的时候也会正常输入。 十进制回文数如何判断？见欧拉-2 t即为翻转后的数字，并且判断与原数是否相等，相等即为回文数。（蓝色方框处与十进制有关） 所以当10 == 2 的时候，即为以二进制进行翻转。 代码1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int check(int x, int n) &#123;//n进制下，x是否为回文数 int raw = x, t = 0;//记录原始的x，和翻转后的结果t while (x) &#123; t = t * n + x % n; x /= n; &#125; return t == raw;//判断t是否等于原来的数&#125;int main() &#123; int ans = 0; for (int i = 1; i &lt; 1000000; i++) &#123; if (check(i, 10) &amp;&amp; check(i, 2)) &#123; ans += i; cout &lt;&lt; i &lt;&lt; endl; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 8. 欧拉-30（各位数字的五次幂） 解题思路 ==难点==：枚举的上限，到哪个数结束。 设x为枚举的位数 9^5^ * x 为能得到的最大阶乘和。 原数最大为10^x^ 9^5^ * x = 10^x^ 求得x = 5.xxx 所以枚举到所有6位数结束即可（枚举的上界，x = 7肯定超过最大值了） 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int num[10];void init() &#123;//初始化数组 for (int i = 1; i &lt; 10; i++) &#123; int t = i; for (int j = 1; j &lt; 5; j++) &#123; t *= i;//乘4次，求五次方 &#125; num[i] = t;//num[1-9]存入对应数字的5次方 &#125;&#125;int check(int x) &#123; int raw = x, t = 0;//保存原数字/ t存储拿出来的值的五次方的和 while (x) &#123; t += num[x % 10]; x /= 10; &#125; return raw == t;&#125;int main() &#123; init(); int ans = 0; for (int i = 10; i &lt; 1000000; i++) &#123;//个位数不认 if (check(i)) &#123; ans += i;//加到答案中并且打印出来看看 cout &lt;&lt; i &lt;&lt; endl; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 欧拉-34（各位数字的阶乘）解题思路 ==难点==：上限是多少:设x为上限的位数, 解方程==9! * x = 10^x^== x = 6.xxxxx 向下取整并且 + 1; 所以枚举的位数上限为7 代码类似于[欧拉-30](# 8. 欧拉-30（各位数字的五次幂）) 二分专题oj-380. 大统领投票（sort排序） 解题思路 做一个排序 练习使用==[sort](# sort)==; 输出编号, 必须编号与票数一起排序,需要用到==struct==, 将编号与票数结合在一个结构体内; 票数很大, 需要用到==字符串==读入: string读入,并且可以直接比较大小; 谁长谁大; 一样长,则比较字典序（因为是字符串，而且只有数字） 如何理解==排序方法cmp==函数 传入两个参数a, b, 分别表示排完序后前元素和后元素的相对位置关系; 想让a和b满足什么条件, 就return什么条件 ```c++return a.s.size() &gt; b.s.size();//按照长度排序, 前面的元素a的长度大于后面的元素b的长度 1234567891011121314151617181920212223242526272829303132333435### 代码&#96;&#96;&#96;c++#include &lt;iostream&gt;#include &lt;string&gt;&#x2F;&#x2F;引进string类的头文件#include &lt;algorithm&gt;&#x2F;&#x2F;sort在算法库里，需要引进来using namespace std;struct node &#123; int num;&#x2F;&#x2F;编号 string s;&#x2F;&#x2F;票数&#125;;int n;node p[105];&#x2F;&#x2F;结构体数组bool cmp(node a, node b) &#123;&#x2F;&#x2F;相当于a和b排好序后,a是前面的那个元素,b是后面的那个元素&#x2F;&#x2F;node &amp;a, node &amp;b传引用的意思 if (a.s.size() &#x3D;&#x3D; b.s.size()) &#123; return a.s &gt; b.s;&#x2F;&#x2F;如果长度一样,按照字典序来排序，前面的大于后面 &#125; return a.s.size() &gt; b.s.size();&#x2F;&#x2F;先按照长度来排序&#125;int main() &#123; cin &gt;&gt; n; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; cin &gt;&gt; p[i].s;&#x2F;&#x2F;读入票数,存入结构体的票数中 p[i].num &#x3D; i;&#x2F;&#x2F;编号置为i &#125; sort(p + 1, p + n + 1, cmp);&#x2F;&#x2F;从1开始输入的，所以要+1； 起始位置 结束为止 排序方法cmp cout &lt;&lt; p[1].num &lt;&lt; endl &lt;&lt; p[1].s &lt;&lt; endl; return 0;&#125; oj-381. 谁拿了最大奖学金解题思路 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct person &#123;//结构体表示每个同学 string name; int num, avg, cla, paper, m;//m奖学金 num编号 char off, west;&#125;;bool cmp(person a, person b) &#123; if (a.m == b.m) &#123; return a.num &lt; b.num;//如果奖学金相同，按照编号进行排序； &#125; return a.m &gt; b.m//排在前面的奖学金大于后面的奖学金&#125;int n, ans;//n学生数量，ans总的奖学金数量person stu[105];//学生数组，最多100人；int func(int x) &#123;//求获得了多少奖学金 int t = 0; if (stu[x].avg &gt; 80 &amp;&amp; stu[x].paper &gt;= 1) t += 8000; if (stu[x].avg &gt; 85 &amp;&amp; stu[x].cla &gt; 80) t += 4000; if (stu[x].avg &gt; 90) t += 2000; if (stu[x].avg &gt; 85 &amp;&amp; stu[x].west == &#x27;Y&#x27;) t += 1000; if (stu[x].cla &gt; 80 &amp;&amp; stu[x].off == &#x27;Y&#x27;) t += 850; return t;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stu[i].name &gt;&gt; stu[i].avg &gt;&gt; stu[i].cla &gt;&gt; stu[i].off &gt;&gt; stu[i].west &gt;&gt; stu[i].paper; stu[i].num = i;//给上编号 stu[i].m = func(i); ans += stu[i].m; &#125; sort(stu, stu + n, cmp); cout &lt;&lt; stu[0].name &lt;&lt; endl &lt;&lt; stu[0].m &lt;&lt; endl &lt;&lt; ans &lt;&lt; endl; return 0;&#125; oj-386. 吃瓜群众（朴素二分） 解题思路 ==二分查找法（点击跳转）== 对于想要的瓜的数量，进行排序， 再进行二分查找，看是否有一个对应的一组瓜数量是一致的； 有，输出编号，没有，输出0 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int cnt, num;//编号与瓜的数量&#125;;int n, m;node wm[100005];//西瓜的数组bool cmp(const node &amp;a, const node &amp;b) &#123; return a.num &lt; b.num;//从小到大，按照瓜的数量&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; wm[i].num;//第i组西瓜的数量 wm[i].cnt = i + 1; &#125; sort(wm, wm + n, cmp);//从西瓜开始排到西瓜+1 for (int i = 0; i &lt; m; i++) &#123; int t, f = 0, l = 0, r = n - 1;//二分查找的左区间和右区间 cin &gt;&gt; t; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (t == wm[mid].num) &#123; f = wm[mid].cnt;//瓜的编号，而不是数组所在的位置 break; &#125; if (t &lt; wm[mid].num) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; cout &lt;&lt; f &lt;&lt; endl; &#125; return 0;&#125; oj-387. 吃瓜群众升级版（二分查找的特殊情况） 解题思路 与386不同，不需要找正好相等的瓜数，只需要找大于等于的数 如何理解输出0: 方案1. 特判：输入的西瓜是否大于最大的一堆瓜的数量 方案2. 建立虚拟瓜堆，特别大，大于输入的数据，并且置为0；假如找不到，就找到虚拟的瓜，并且输出0； ==二分查找的特殊情况== ==第一种特殊情况：前面一堆0，后面一堆1，找第一个1== 假设西瓜堆为 1 3 9 12 17；第一个群众想吃7个瓜。1 3 不符合，编号初始化为0；9 12 17符合，编号初始化为1； 题意抽象为找第一个1的编号为多少。 前面一堆0，后面一堆1，如何找第一个1的套路：（二分查找的特殊情况） 动态调整边界 二分条件变化：当 左 不等于 右，就一直二分 与==朴素二分==的区别： 1.条件不一样； 2.R = mid（不是mid-1）；假如正好mid指向1的话，R= mid = 1，即正好mid是我们想要的最终答案，这时候，假如mid - 1就会错过这个答案了。 ==第二种情况：前面一堆1，后面一堆0，找最后一个1；== 假如mid指向1，动左指针；动到哪里取决于mid是否可能是答案。假如为1，mid有可能是答案，所以mid区间不能删，左指针不能删 mid指向0，动右指针，0一定不是答案，所以可以mid - 1； 12345678while(L ! = R) &#123; int mid = (L + R + 1) / 2;//避免死循环 if (n[mid] == 1) &#123; L = mid; &#125; else &#123; R = mid - 1; &#125;&#125; 为什么mid = （L+R+1）/ 2: 在（L+R）/2的情况下，所求mid指向左指针，为1，右指针指向0，此时L=mid。还是指向1，会无限循环； 让mid = （L+R+1）/ 2， 此时mid会指向右指针，为0，此时R= mid-1，即与左指针重合，返回结果。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int cnt, num;&#125;;//定义西瓜的自定义结构bool cmp(const node &amp;a, const node &amp;b) &#123; return a.num &lt; b.num;//直接写排序函数，从小到大&#125;int n, m;node wm[100005];//最多10w个西瓜数组int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; wm[i].num;//循环输入西瓜的数量 wm[i].cnt = i + 1;//每组西瓜给编号，从1开始 &#125; wm[n].cnt = 0; wm[n].num = 2100000000;//建立虚拟瓜堆 sort(wm, wm + n + 1, cmp);//排序的时候包含虚拟瓜堆，+1 for (int i = 0; i &lt; m; i++) &#123; int t, l = 0, r = n; cin &gt;&gt; t; while (l != r) &#123; int mid = (l + r) / 2; if (wm[mid].num &gt;= t) &#123;//套路中1那边的 r = mid; &#125; else &#123;//0那边的 l = mid + 1; &#125; &#125; cout &lt;&lt; wm[l].cnt &lt;&lt; endl;//左右随便输出哪一个都行 &#125; return 0;&#125; Leecode-278. 第一个错误的版本 解题思路 二分的特殊情况：没有bug为0，出bug为1，找到第一个1 代码 oj-390. 原木切割（二分答案）解题思路 长度为5时，能切成8段；长度为6时，能切出6段；所以5是能切出8段的最大答案 最短切1，最大切木头里最长的木头的长度。 假定最大长度为mid，遍历带入，算出能切出多少段（假如8段）；再根据段数与题意要求段数进行调整左右指针； 5能切8段，符合；6能切6段，不符合； 题意转化为前面一堆1，后面一堆0，求最后一个1； Mid = (L + R +1) / 2 切长度为4， 可以切10段，显然属于套路中1那边，此时调整左指针L= mid； 否则，R = mid - 1； 为什么叫二分答案？ 因为是根据mid求出能砍木头的段数，然后根据段数来调整左右指针。绕了一圈。 代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int n, m, num[100005], lr;//n个木头，m表示切出多少段。num原木长度的大数组//lr右界，即所有原木中最长的原木的长度int func(int len) &#123;//传入一个长度，根据mid求出能切除多少段 int s = 0; for (int i = 0; i &lt; n; i++) &#123;//遍历原木的长度 s += num[i] / len;//整数除以整数 &#125; return s;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num[i]; lr = max(lr, num[i]);//输入完数据更新lr &#125; int l = 1, r = lr;//定义完开始二分 while (l != r) &#123; int mid = (l + r + 1) / 2; int s = func(mid);//求出长度为mid时候能切出多少段 if (s &gt;= m) &#123;//根据多少段求出是套路中的那堆1还是0 l = mid;//是那堆1，调整左指针 &#125; else &#123; r = mid - 1; &#125; &#125; cout &lt;&lt; r &lt;&lt; endl; return 0;&#125; oj-389. 暴躁的程序猿 解题思路 ①②③表示放的三个人的位置，①②距离为1，②③距离为7 最近的距离为1，太近了容易打起来。 这也是一道二分答案题，根据分出来的位置间的 ==最大距离==调整指针 距离下界L可以赋值为1，距离上界为最大与最小距离只差； 如何调整左右指针？ 求出临时距离mid； 根据mid求出可以安排的人数； 求出的安排人数与应该安排人数进行比较：距离1，可以安排5人；距离2，可以安排3人；所以左边533，能安排下的都是1；右边22安排不下，为0；特殊情况：11100，找最后一个1； 难点: 如何根据临时距离求出安排人数：扫一遍工位 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, num[100005], tr;int func(int d) &#123;//传入距离d int s = 1, last = num[0];//为了让人越多越好，起始位置肯定要安排上人，s=1； //last记录上一个安排人的位置,最开始那个人安排在num【0】 for (int i = 1; i &lt; n; i++) &#123;//遍历一遍num数组，0已经安排人，从1开始 if (num[i] - last &gt;= d) &#123;//判断，上一次在last位置，这一次在num[i]， //可否安排 s++;//可放人的位置数量+1 last = num[i];//更新记录上一次放人位置last &#125; &#125;//遍历完之后，s存入最多可以放人的个数 return s;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num[i];//循环输入工位的编号 tr = max(tr, num[i]);//更新上界 &#125; sort(num, num + n);//对数据进行排序，从num开始排到num+n；默认排序就好 int l = 1, r = tr; while (l != r) &#123;//开始二分 int mid = (l + r + 1) / 2; int s = func(mid);//抽象成函数求出能够安排多少人 if (s &gt;= m) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; cout &lt;&lt; l &lt;&lt; endl; return 0;&#125; 主函数输入数据，并且统计一下上边界，排序保证遍历工位时候是有序的 开始二分 二分答案：根据临时距离，求出可以安排人数；根据可以安排人数多少，调整左右指针 初始化时，安排一个人在0，保证人最多 运用套路，一串1111000， 找最后一个1 输出答案为3 oj-393. 切绳子（小数二分） 解题思路 与上一题不同，这一题求==小数的二分== 难点：小数二分与整数二分的区别 前面11110000，找最后一个1 循环判断条件不同：不是判断是否相等，而是判断是否大于预设精度 调整指针也不需要+1 或 -1 要求保留后2位 》保留后四位；以及如何直接舍弃2位后的小数点 如何==直接舍掉2位后的小数==？printf会四舍五入。12.12345 方法一：先乘再除 12.12345 * 100 = 1212.345 （int）1212.345 &gt; 1212 1212 / 100.0 &gt; 12.12 方法二：减去0.005后再四舍五入 12.12345 - 0.005 = 12.11845 四舍五入printf (“”%.2f”)：12.12 方法三： 代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdio&gt;//需要使用printfusing namespace std;int n, m;//总共绳子的数量， 要切成多少段double num[10005], tr;//存入绳子长度， 最大绳子的长度int func(double len) &#123;//只有涉及到绳子长度的才是double类型 int s = 0; for (int i = 0; i &lt; n; i++) &#123; s += num[i] / len;//小数除以小数，为小数，再加入整数中，小数部分自动舍去 &#125; return s;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num[i]; tr = max(tr, num[i]);//更新最大值 &#125; double l = 0, r = tr;//定义左右边界，开始二分 while (r - l &gt; 0.00001) &#123;//保留4位 double mid = (l + r) / 2;//因为是小数，不需要+1/-1 int s = func(mid); if (s &gt;= m) &#123; l = mid; &#125; else &#123; r = mid; &#125; &#125; printf(&quot;%.2f\\n&quot;, (int)(l * 100) / 100.0);//乘上100后强转为int后 再除100.0 return 0;&#125; Oj-82. 伐木 解题思路 假如高度设为13，可以切下来总长度为（7+4+2）13； 假如高度设为14， 那么切下来为6 3 1 0，总共长度为10；题目要求的是9； 假如高度设为15，总长度为7 所以是个1110000，找最后一个1的二分答案题 寻找上界和下界 下界为要去切除树木的临时长度0:把树都切了；上界为最高树的高度20； 根据临时长度求出可以切树木段数的总数，然后再根据总数调整左右指针 长度很长，用long long存储数据，避免溢出。 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int n, m, num[1000005], tr;//n表示木头根叔，m表示要切出来的根数，num存木头长度，最多有100w，//tr上界为最长木头的长度long long func(int h) &#123;//传入一个参数，表示高度 long long s = 0; for (int i = 0; i &lt; n; i++) &#123;//开始切木头 if (h &lt; num[i]) &#123;//所切的高度必须小于树木的高度 s += num[i] - h;//切出来的长度累加 &#125; &#125; return s;&#125;int bin_search() &#123;//通过函数进行二分答案 int l = 0, r = tr;//左右边界 while (l != r) &#123; int mid = ((long long)l + r + 1) / 2;//防止l+r溢出，先进行强转 long long s = func(mid);//有可能切出超过int范围 if (s &gt;= m) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; return r;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num[i]; tr = max(tr, num[i]);//得到最长木头的值作为上界 &#125; cout &lt;&lt; bin_search() &lt;&lt; endl;//将二分抽象为一个函数，并且输出函数的返回值 return 0;&#125; Oj-391. 数列分段 解题思路 分成三段：4 - 11 - 1 最大为11；6 - 6 - 4 最大为6；每段的最大值最小，所以为6 二分答案：分每段的和 假如最大和为5，可以分成5段：不行 ==假如最大和为6，可以分成三段；6 - 4 - 6== 假如最大和为7，可以分成三段：6 - 4 - 6 8 三段； 9 三段； 10 两段； 00001111，找第一个1的特殊情况 左界：n个数分成n段，其中最大的那一段就是每段长度和的最小值 L = min(num[i]) 上界：n个数分成1段，求段数和 R = sum(num[i]); func（）函数注意为什么分成三种情况，不要绕晕了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;long long n, m, num[100005], tl, tr;//n表示数字多少，m表示要分成几段long long func(long long x) &#123;//根据x求出能把数列分成多少段 long long cnt = 0, now = 0;//定义段和当前和 for (int i = 0; i &lt; n; i++) &#123;//表遍历一遍数列 if (now + num[i] == x) &#123;//所有数的和加上当前 等于 x，说明数列加到这正好是一段 cnt++; now = 0;//全新的开始 &#125; else if (now + num[i] &gt; x) &#123;//说明上一段应该在之前一段结束 cnt++; now = num[i];//更新新一段的值为起点 &#125; else &#123; now += num[i];//还是同一段，直接加 &#125; &#125; if (now) &#123; //判断最后一段是否统计了（如果now里面有值，说明最后一段还没有统计） cnt++; &#125; return cnt;//返回数列最终能够分成几段&#125;long long bin_search() &#123;//要的是一个和，有可能很大 long long l = tl, r = tr; while (l != r) &#123; long long mid = (l + r) / 2; long long s = func(mid); if (s &lt;= m) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num[i]; tl = max(tl, num[i]); tr += num[i]; &#125; cout &lt;&lt; bin_search() &lt;&lt; endl; return 0;&#125; oj-394. 跳石头 解题思路 ==0== 2 11 14 17 21 ==25== 移去 11 17， 距离变成 2 12 7 4， 最小距离为2； 移去2 14， 距离变为11 6 4 ，最小距离为4； 无论怎么分，移去==2块石头==后最短距离的==最大值为4==； 起点与终点都有一块隐藏石头 最大值为3，需要移去1块石头； 最大值为4，需要移去2块石头； 最大值为5，需要移去3块石头； 4对应的那个答案，是1那边的； 那到底左边是1还要右边是1呢？ 假设3.5, 需要移走2块，同为1； 所有左边都是1，右边都是0 111000前面一堆1，后面一堆0，寻找最后一个1； 如何确定上界和下界？ ​ 上界：起点到终点的距离 L ​ 下界：最近的两个点之间的距离 遍历是遍历到终点，会移走终点的石头吗，？ ​ 不会，遍历到最后，但是动的是前面一个石头： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;int ll, n, m, num[50005], tl;//num数组表示石头的距离int func(int d) &#123;//假如距离为mid（d），需要移走多少块石头？ int cnt = 0, last = 0;//cnt 最终需要移走石头的数量，last 上一个石头的编号 for (int i = 1; i &lt;= n + 1; i++) &#123;//从第一个石头开始遍历 if (num[i] - last &lt; d) &#123;//numi减去上一个石头所在的位置 &lt; d,不得不移走这块石头；不然距离不够 cnt++; &#125; else &#123; last = num[i];//否则说明距离够，可以不用移走，更新last &#125; &#125; return cnt;&#125;int bin_search() &#123; int l = tl, r = ll; while (l != r) &#123; int mid = (l + r + 1) / 2; int s = func(mid);//根据mid求出需要移走多少块石头 if (s &lt;= m) &#123; l = mid; &#125; else &#123; r = mid - 1; &#125; &#125; return r;&#125;int main() &#123; cin &gt;&gt; ll &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123;//起点为num[0],数据从1开始 cin &gt;&gt; num[i]; if (i == 1) &#123;//更新下界 tl = num[1] - num[0]; &#125; else &#123; tl = min(tl, num[i] - num[i - 1]);//否则更新出一个极小值 &#125; &#125; num[n + 1] = ll;//起点默认为0，强行加入一个终点为ll cout &lt;&lt; bin_search() &lt;&lt; endl; return 0;&#125; oj-392. 丢瓶盖 解题思路 似曾相识，[暴躁的程序猿](#oj-389. 暴躁的程序猿) 5个工位选三个，使得相邻最近的工位间的距离最大。 代码oj-395. 复制书稿 解题思路 书分成三组，分别为15 13 17，17为所求的最短的复制时间 这一题需要先求出17，然后遍历数组，找出其他的值（每个人抄的是哪本书） 这一题转化为9个连续的数，分成三段，要求每段必须连续，且每段和的最大值越小越好。无论怎么分，最大值不会比17还小了。参考[数列分段](#Oj-391. 数列分段) 求出分出后和最小的最大值；见数列分段； （如果有多解，尽可能让前面的人少抄书）拿到最大值，从后往前扫数列，分情况记录每个人的起始编号和终止编号，存入数组中。最后输出答案 二分专题总结 朴素二分 二分的特殊情况 00001111，找第一个1 11110000，找最后一个1 小数的二分特殊情况 二分答案 答案对应求得东西在题意中是单调的，对答案进行二分，在根据答案进行调整指针 二分答案基本都有特殊情况 oj题目讲解oj-599. 两数之和1 解题思路方法一：暴力解法，两层循环，分别枚举第一个和第二个数​ 会超时O(n^2^) 方法二：先固定一个数，内层循环用二分进行​ O（nlogn） 方法三：哈希表 O(n) 空间O(n) 方法四：双指针法O（n） 左右指针分别指向 1和26 ，此时和为27； 和27大于15，调整右指针–，使得数变小； 此时有指针指向10，10+1 = 11 《 15； 动左指针，指向5； 此时5 + 10 = 15，输出答案 假如数组是乱序的，先进行排序 三数之和：O（n^2^） 外层循环，并且固定，内层循环变成二数之和 代码 双指针法 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n, t, num[1000005];//数组高达100w//n ， t表示目标int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;t);//避免用c读入会超时 for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;num[i]);//读入数据存入数组中 &#125; int l = 0, r = n - 1; while (l &lt; r) &#123; if (num[l] + num[r] == t) &#123; cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;//直接输出两个数的下标 return 0; &#125; if (num[l] + num[r] &lt; t) &#123; l++; &#125; else &#123; r--;//数大了，动有指针 &#125; &#125; cout &lt;&lt; -1 &lt;&lt; endl;//没有找到，输出-1 return 0;&#125; oj-600. 杨氏矩阵 解题思路 从左下角出发 从 7 出发，7 &lt; 15 ， 说明15一定在7的右边 移动黑圈，到10。10 &lt; 15， 移动黑圈到20； 20 &gt; 15, 说明15 在黑圈的上面。黑圈往上移动一个正好为15，输出黑圈所在的坐标。 右上角出发同理，往下往左移动黑圈 O(n+m) 与上一题两数之和有联系 1 5 10 20，初始化一个数组，记录每每两数之和；左指针指向横着的数组1；右指针指向竖着的数组中的20，此时相当于本题从左下角出发。21 比 30 要小，此时动左指针，到25。过程与本题一致 代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n, m, t, num[3005][3005];//n行，m列，t目标int main() &#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf(&quot;%d&quot;, &amp;num[i][j]);//循环读入数据存入num中 &#125; &#125; int x = n, y = 1;//从左下角开始查找需要初始的值 while (1) &#123;//或者可以判断边界，当指针出界的时候，退出循环 if (num[x][y] == t) &#123;//正好找到目标 cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;//如果超时，改成printf return 0; &#125; if (num[x][y] &gt; t) &#123;//没找到，需要分成两种情况 x--;//数大了 &#125; else &#123; y++; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125; oj-477. 原音字母 解题思路代码123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; int ans = 0, last = -1; //last为上一个原音字母的位置 char s[105]; cin &gt;&gt; s;//输入数据字符串 for (int i = 0; s[i]; i++) &#123;//从第0位开始，一直到s[i]不为零结束；字符串最后为/0,即条件为假 if (s[i] == &#x27;A&#x27; || s[i] == &#x27;E&#x27; || s[i] == &#x27;I&#x27; || s[i] == &#x27;O&#x27; || s[i] == &#x27;U&#x27;) &#123;//如果是原音 if (last != -1) &#123;//说明不是第一个 ans = max(ans, i - last); &#125; last = i; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 如果last==-1，说明是第一个原音，此时更新last的值为i； 又因为无论if是否成立，都会运行last = i，所以说明不需要判断，可以放到循环外面。 oj-479. 乒乓球 解题思路 比赛最多进行6000局 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cmath&gt;//求绝对值abs的数学库using namespace std;int a11[6000][2], a21[3000][2], ind1, ind2;//11分制最多进行6000局，并且记录两个人的分数；//ind1表示在11分制下,进行到了第几局void p() &#123; for (int i = 0; i &lt;= ind1; i++) &#123;//先输出11分制下 cout &lt;&lt; a11[i][0] &lt;&lt; &quot;:&quot; &lt;&lt; a11[i][1] &lt;&lt; endl; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt;= ind2; i++) &#123; cout &lt;&lt; a21[i][0] &lt;&lt; &quot;:&quot; &lt;&lt; a21[i][1] &lt;&lt; endl; &#125;&#125;int main() &#123; char s[30]; while (cin &gt;&gt; s) &#123; for (int i = 0; s[i]; i++) &#123;//for循环遍历字符串 if (s[i] == &#x27;E&#x27;) &#123;//如果碰到E了，说明对局结束 p();//函数输出结果 return 0; &#125; if (s[i] == &#x27;W&#x27;) &#123; a11[ind1][0]++; a21[ind2][0]++; &#125; else &#123; a11[ind1][1]++; a21[ind2][1]++; &#125; if ((a11[ind1][0] &gt;= 11 || a11[ind1][1] &gt;= 11) &amp;&amp; abs(a11[ind1][0] - a11[ind1][1]) &gt;= 2) &#123; ind1++;//判断是否这一局结束 &#125; if ((a21[ind2][0] &gt;= 21 || a21[ind2][1] &gt;= 21) &amp;&amp; abs(a21[ind2][0] - a21[ind2][1]) &gt;= 2) &#123; ind2++; &#125; &#125; &#125; return 0;&#125; oj-480. 保龄球 解题思路 一局有可能打两个球 可以将每局的状态作为独立的结构保存下来，可以判断这一局是直接还是间接清空。 字符串:记录多少局 int num1，2：记录第一次和第二次扔球得分 int flag：记录这一局是直接清空间接清空还是没清空 如果没清空，这一局分数就是num2的值 间接清空，加上下一局分数的num1； 直接清空，判断一下下一局是否为直接清空； 如果是直接清空，加上直接清空分数，再加上下下局的分数num1； 间接清空或者没清空，则直接加上num2得分 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;struct node &#123;//定义一个数据结构 char s[4];// int num1, num2, flag;&#125;;node b[15];//开一个这个类型的数组int main() &#123; int ans = 0;//表示最终答案 for (int i = 0; cin &gt;&gt; b[i].s; i++) &#123;//当能输入的时候就一直输入； //每次读入两个字符或者一个字符，b[i]的字符串,一局有可能打两球 if (b[i].s[0] == &#x27;/&#x27;) &#123;//直接清空 b[i].num1 = b[i].num2 = 10; b[i].flag = 2; &#125; else if (b[i].s[1] == &#x27;/&#x27;) &#123;//间接清空 b[i].num1 = b[i].s[0] - &#x27;0&#x27;; b[i].num2 = 10; b[i].flag = 1; &#125; else &#123;//没清空 b[i].num1 = b[i].s[0] - &#x27;0&#x27;; b[i].num2 = b[i].s[1] - &#x27;0&#x27; + b[i].num1; b[i].flag = 0;//不往后计分，所以是0 &#125; &#125; for (int i = 0; i &lt; 10; i++) &#123;//遍历10局游戏 ans += b[i].num2;//先把自身答案加上 if (b[i].flag == 1) &#123; ans += b[i + 1].num1;//下一轮的第一球的得分 &#125; else if (b[i].flag == 2) &#123;//否则，直接清空，加后两个球 if (b[i + 1].flag == 2) &#123;//如果下一句是直接清空的 ans += 10 + b[i + 2].num1;//加上下下局第一球的得分 &#125; else &#123; ans += b[i + 1].num2; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; oj-481. 冰壶比赛解题思路代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int r, ans[15][2];//最多10局，每局两个队的得分void p(int n) &#123; int a1 = 0, a2 = 0; for (int i = 1; i &lt; n; i++) &#123;//从第一轮开始到n轮结束 a1 += ans[i][0]; a2 += ans[i][1]; cout &lt;&lt; ans[i][0] &lt;&lt; &quot;:&quot; &lt;&lt; ans[i][1] &lt;&lt; endl; &#125; cout &lt;&lt; a1 &lt;&lt; &quot;:&quot; &lt;&lt; a2 &lt;&lt; endl;&#125;int main() &#123; cin &gt;&gt; r;//输入圆圈的半径 for (int i = 1; i &lt;= 10; i++) &#123;//循环输入比赛数据 int num1[10] = &#123;0&#125;, num2[10] = &#123;0&#125;; for (int j = 0; j &lt; 8; j++) &#123; cin &gt;&gt; num1[j]; if (num1[j] == -1) &#123;//-1表示有队伍投降，直接输出答案并且退出程序 p(i);//传入参数i，表示比赛进行到第几轮 return 0; &#125; &#125; for (int j = 0; j &lt; 8; j++) &#123; cin &gt;&gt; num2[j]; &#125; sort(num1, num1 + 8); sort(num2, num2 + 8);//排序判断谁离圆心更近 if (num1[0] &lt; num2[0]) &#123;//说明1队得分 for (int j = 0; j &lt; 8; j++) &#123; if (num1[j] &gt; r || num1[j] &gt;= num2[0]) break;//这种情况下不得分 ans[i][0]++;//得分 &#125; &#125; else &#123;//第二队得分 for (int j = 0; j &lt; 8; j++) &#123; if (num2[j] &gt; r || num2[j] &gt;= num1[0]) break; ans[i][1]++; &#125; &#125; &#125; p(11); return 0;&#125; ==oj-484. 柱状统计图== 解题思路 难点： 按行输出结果 最多字符的数量 &gt; 行数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;int num[130];//统计个个字符出现的次数；char 的上限是128char str[1005];//存入字符串int main() &#123; while (cin &gt;&gt; str) &#123; for (int i = 0; str[i]; i++) &#123;//每次遍历一下字符串，把对应字符数量+1； num[str[i]]++; &#125; &#125; int mmax = 0;//表示最高字符，即高度 for (int i = &#x27;A&#x27;; i &lt;= &#x27;Z&#x27;; i++) &#123;//从A开始到Z结束 mmax = max(mmax, num[i]);//统计完找到最高的高度 &#125; for (int i = mmax; i &gt; 0; i--) &#123;//循环最高高度次 int ind = &#x27;A&#x27;; for (int j = &#x27;Z&#x27;; j &gt; &#x27;A&#x27;; j--) &#123; if (num[j] &gt;= i) &#123;//说明有东西 ind = j;//找到最后一个字符所在的位置 break; &#125; &#125; for (int j = &#x27;A&#x27;; j &lt;= ind; j++) &#123; if (j != &#x27;A&#x27;) &#123; cout &lt;&lt; &quot; &quot;; &#125; if (num[j] &gt;= i) &#123; cout &lt;&lt; &quot;*&quot;; &#125; else &#123; cout &lt;&lt; &quot; &quot;; &#125; &#125; cout &lt;&lt; endl; &#125; for (char i = &#x27;A&#x27;; i &lt;= &#x27;Z&#x27;; i++) &#123; if (i != &#x27;A&#x27;) &#123; cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; i; &#125; cout &lt;&lt; endl; return 0;&#125; oj-485. 均分纸牌 解题思路 先求出最终均分值为10 9比10小，往后一位借1 &gt; 10 7 17 6 10 10 14 6 14比10大，借给后面 &gt; 10 10 10 10 扫描一遍数组，不是10就ans++，是10直接下一个数 特殊情况：如果 0 0 0 4，不够借： ​ 1 -1 0 4 &gt; 1 1 -2 4 &gt; 1 1 1 1 代码12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int n, num[105], ans, sum, avg;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num[i]; sum += num[i]; &#125; avg = sum / n; for (int i = 0; i &lt; n - 1; i++) &#123;//最后一堆牌不需要 if (num[i] != avg) &#123; ans++; num[i + 1] += num[i] - avg;//无论加减都可以通过这个式子解决；解析见下图 num[i] = avg;//可写可不写，让num[i]变成平均值 &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; oj-503. 独木舟 解题思路 排序，扫一遍，判断能否两个人搭一条船 代码==oj-504. 删数== 解题思路 两数比较，假如前面一个数字大的话，删去他可以使整体数字值变小 1 75 66 &gt; 1566， 7 &gt; 5删去还需要删去2个数 如果都是满足小数在前，大数在后，此时删去最后的数字 代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;//string是一个类using namespace std;string str;//建立一个shring对象，存入大整数int n;//表示删掉几位数int main() &#123; cin &gt;&gt; str &gt;&gt; n;//输入大整数 for (int i = 0; i &lt; n; i++) &#123;//循环n次，每次删掉一个数 int ind = str.size() - 1;//默认索引为字符串长度-1 for (int j = 0; j &lt; str.size() - 1; j++) &#123; if (str[j] &gt; str[j + 1]) &#123;//不满足前小后大 ind = j; break; &#125; &#125; str.replace(ind, 1, &quot;&quot;);//string类中的替换函数：位置ind，长度1，替换成“ ” &#125; int f = 0; for (int i = 0; i &lt; str.size(); i++) &#123;//判断是否有前导0 if (str[i] != &#x27;0&#x27;) &#123;//不是字符0， f = 1;//0_flag置为1 &#125; if (f == 1) &#123; cout &lt;&lt; str[i]; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; oj-505. 最大整数 解题思路 sort一下，数字按照字符串的形式存入。最终连起来也是按照字符串输出 按照字典序比较大小进行排序 代码123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;string s[100005];int n;bool cmp(const string &amp;a, const string &amp;b) &#123;//传入两个字符串 return a + b &gt; b + a;//a+b连接后的字典序大于b+a连接后的字典序&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s[i];//读入数据整数，但是按照字符串相连 &#125; sort(s, s + n, cmp); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; s[i]; &#125; cout &lt;&lt; endl; return 0;&#125; oj-508. 两人过河 解题思路 但是，假如是这样一组数据：1 2 1000 1001 方案1：右边：1当工具人来回送; （传手电的速度快） ​ 最慢最快 》 最快 》次慢最快 》 最快 方案2：左边：1001和1000两人一起过河，然后派2过来接1再一起过河（过桥的效率高） ​ 最快次快 》最快 》 最慢次慢 》 次快 当n&gt;=4的时候，比较两种方法选取一个用时最少的 代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, num[1005], ans;//n人数，num每个人的过河时间，int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; num[i]; &#125; sort(num + 1, num + n + 1);//跑得快的在前面，跑得慢的在后面 for (int i = n; i &gt; 0; i -= 2) &#123;//-=2表示每次过去两个人 if (i == 1) &#123;//说明只有一个人过河 ans += num[1]; break; &#125; else if (i == 2) &#123; ans += num[2];//慢的那个人的时间 break; &#125; else if (i == 3) &#123;//最快的人当工具人送手电筒 ans += num[3] + num[1] + num[2]; break; &#125; else &#123;//四个人以上，两种情况 ans += min(num[i] + num[1] + num[i - 1] + num[1], num[2] + num[1] + num[i] + num[2]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; ==oj-509. 智力大冲浪== 解题思路 为了少扣钱，优先完成扣钱多的任务； 扣钱多少与任务时间作为一个结构，进行排序 优先完成扣钱多的任务 其次优先完成时间短的任务， 整个时段看作一个标记数组，尽可能把能完成任务的时间往后放，判断是否占用 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct task &#123; int t, m;&#125;;bool cmp(task a, task b) &#123; if (a.m == b.m) return a.t &lt; b.t; return a.m &gt; b.m;&#125;int n, m, mark[100000] = &#123;1&#125;;task game[505];int main() &#123; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; game[i].t; &#125; for (int i = 0; i&lt; n; i++) &#123; cin &gt;&gt; game[i].m; &#125; sort(game, game + n, cmp); for(int i = 0; i &lt; n; i++) &#123; for (int j = game[i].t; j &gt;=0; j--)&#123; if (mark[j] == 0) &#123;//说明没有用过 mark[j] = 1; break; &#125; if (j == 0) &#123;//说明所有时间都被占了 m -= game[i].m; &#125; &#125; &#125; cout &lt;&lt; m &lt;&lt;endl; return 0;&#125; oj-518. 金币 解题思路 两个循环 oj-513. 楼层编号解题思路 枚举；如果楼层存在，则真实楼层+1 代码12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int func(int x, int t) &#123;//i的每一拿出来看看有没有t while (x) &#123; if (x % 10 == t) return 0; x /= 10; &#125; return 1;&#125;int main() &#123; int m, t, ans = 0;//虚假；删掉数字；真实楼层 cin &gt;&gt; m &gt;&gt; t; for (int i = 1; i &lt;= m; i++) &#123; if (func(i, t)) &#123;//如果第i个楼层真实存在 ans++; &#125; //ans += func(i, t); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0; ==oj-514==. 火柴棒等式 解题思路 去掉+和=所用的火柴棒，还有20根 确定上界 两层循环 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;int num[15] = &#123; 6 ,2 ,5 ,5 ,4 ,5 ,6 ,3 ,7 ,6&#125;;int sum(int x) &#123;//专门求数量的函数 if (x == 0) &#123;//x为0，根本不会进入循环，但是0的确是一个数字 return num[0]; &#125; int ans = 0; while (x) &#123;//拆出每一位 ans += num[x % 10]; x /= 10; &#125; return ans;&#125;int func(int a, int b) &#123;//所消耗火柴的数量 int x = sum(a), y = sum(b), z = sum(a + b); return x + y + z + 4;&#125;int main() &#123; int n, ans = 0; cin &gt;&gt; n; for (int i = 0; i &lt; 2000; i++) &#123;//枚举范围 for (int j = 0; j &lt; 2000; j++) &#123; if (func(i, j) == n) &#123; ans++; cout &lt;&lt; i &lt;&lt; &quot; + &quot; &lt;&lt; j &lt;&lt; &quot; = &quot; &lt;&lt; i + j &lt;&lt; endl; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; ==oj-515==. 比例简化 解题思路 两个for循环枚举A’和B’ 然后看是否满足三个条件，保留一个尽可能满足条件的答案 互质条件不需要判断，因为是从小枚举到大，如果15/30，结果是1/2，但是已经被在之前舍弃了 代码1 ==oj-516. 牛奶碑文== 解题思路 经过第一个O，左边两个c，右边两个w，所以有4种； 第二个O同理，4+4 = 8； 问题转化为求多少个c和w PUSH如何查看：On^2^ 从前往后扫找到多少个P，从后往前找到多少个H，去找U，找到U后去后面找每一个s，在答案中加上U前面多少个P，s后面多少个H 前缀和 代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int n, num[100005], wcnt;//num从前往后扫到某个位置有多少个c，wcnt从后往前到某个位置有多少个wlong long ans;char str[100005];//字符串int main() &#123; cin &gt;&gt; n &gt;&gt; &amp;str[1];//从1开始，避免遇到ocow，数组越界 for (int i = 1; i &lt;= n; i++) &#123;//有多少个c if (str[i] == &#x27;C&#x27;) &#123;//如果是字符C num[i] = num[i - 1] + 1; &#125; else &#123; num[i] = num[i - 1]; &#125; &#125; for (int i = n; i &gt; 0; i--) &#123; if (str[i] == &#x27;W&#x27;) &#123; wcnt++; &#125; if (str[i] == &#x27;O&#x27;) &#123; ans += (long long)num[i - 1] * wcnt; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; ==oj-517==. 三角形个数 解题思路 难点：不一样的三角形的个数 代码12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int n, ans = 0; cin &gt;&gt; n; for (int i = 1; i &lt;= n / 3; i++) &#123; for (int j = i; j &lt;= (n - i) / 2; j++) &#123; if (i + j &gt; n - i - j) &#123; ans++; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; ==oj-519==. 优雅数 解题思路 枚举题 反过来，枚举优雅数与，判断是否在区间之内 4层枚举循环 for（一堆数Y） for（一个数X） if（x==y） continue； for（数长3-17） for（x的位置1-数长） 如果x=0，不能在第一个位置； 如果y=0，x必须在第一位 ​ for循环构造这个数，统计是否在区间内 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int main() &#123; long long ans = 0, left, right; cin &gt;&gt; left &gt;&gt; right; for (int i = 0; i &lt; 10; i++) &#123;//枚举一堆数 for (int j = 0; j &lt; 10; j++) &#123;//枚举一个数 if (i == j) &#123; continue;//不是优雅数，直接continue &#125; for (int k = 3; k &lt;= 17; k++) &#123;//枚举数字的长度 for (int l = 1; l &lt;= k; l++) &#123;//枚举一个数在一堆数中的位置 if (i == 0 &amp;&amp; l != 1) &#123;//一堆数为0，且一个数不在开头，不存在 break; &#125; if (j == 0 &amp;&amp; l == 1) &#123;//一个数为0，且在第一位 continue; &#125; long long t = 0;//开始构造优雅数t for (int m = 1; m &lt;= k; m++) &#123; if (m == l) &#123; t = t * 10 + j;//一个数 &#125; else &#123; t = t * 10 + i;//否则为一堆数 &#125; &#125; if (left &lt;= t &amp;&amp; t &lt;= right) &#123; //cout &lt;&lt; t &lt;&lt; endl; ans++;//说明t在区间当中 &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; leetcode试题前缀和 快速求解多次询问区间和的题目 前缀和是个数组，表示第i项之前所有数的和，（空间换时间） 假设想求x-y区间的和，假设前缀和数组为sum[] ​ sum[y] - sum[x-1] sum[0] = 0;避免求1-6区间和，会越界 leetcode.13 罗马数字转整数 解题思路 遍历一遍字符串，单独判断是否为IXC这三个字符， 如果是这些字符，需要判断是否为减法 代码 LeetCode.14 最长公共前缀解题思路 遍历，保留每两个字符串的前缀，最后输出这个词缀 如果中途已经为空了，则返回“” 代码 LeetCode.26 删除排序数组中的重复项 解题思路 两个指针，一个往后走，一个指针表示存到了第几个数 如果这个数和之前的数不一样，存到第二个指针，并且两个指针都往后走； 代码 LeetCode.27 移除元素 解题思路 类似上一题 代码 LeetCode.35 搜索插入位置 解题思路 0000000111111，找第一个1的特殊情况 代码 LeetCode.38 外观数列 解题思路 代码 LeetCode.53 最大子序和 解题思路 代码 LeetCode.14 最长公共前缀解题思路 代码1 LeetCode.14 最长公共前缀解题思路 代码1 LeetCode.14 最长公共前缀解题思路 代码1 LeetCode.14 最长公共前缀解题思路 代码1 ==STL容器的使用===queue与stack的操作12345678queue&lt;int&gt; que;que.push(5); 入队que.pop();出队que.front();队首元素que.size();元素个数que.empty();判断是否为空，真为空，返回0表示不为空 queue &lt;double&gt; que; 定义一个double类型的列表 自定义类型： 栈的操作 stack与queue底层是一个双端队列：deque；四边都可以出入；如图堵住，变成队列 与队列相比，front操作变成了top操作 队列的代码演示 对于自定义结构的队列操作 栈的代码演示 vector与priority_queue的操作（优先队列）动态数组 假设定义存入整数的动态数组 vector v; v.push_back(5); 往动态数组的最后放东西；（O1） v.size(); v.insert(1,6);在第一个位置插入元素6（On）：要往后移动很多数字 二维动态数组：vector&lt;vector &gt;:（空格不能省去） 五行四列 底层实现：数组，一片连续的空间 priority_queue: 优先队列, 内部是一个有序的队列 底层实现: 堆 priority_queue que; que.push(5); que.pop(); que.top(); que.size(); que.empty(); 注意：假如是自定义结构，无法进行自动排序 解决方法：重载小于号 动态数组vector的代码演示 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; /* vector&lt;int&gt; v; for (int i = 105; i &lt;= 110; i++) &#123; v.push_back(i); cout &lt;&lt; v.size() &lt;&lt; endl; &#125; for (int i = 0; i &lt; v.size(); i++) &#123; cout &lt;&lt; v[i] &lt;&lt; endl; &#125; */ vector&lt;vector&lt;int&gt; &gt; v; v.push_back(vector&lt;int&gt;()); for (int i = 66; i &lt;= 70; i++) &#123; v[0].push_back(i); &#125; v.push_back(vector&lt;int&gt;(5, 0)); //5个值为0的元素 vector&lt;int&gt; v2; v2.push_back(5); v2.push_back(6); v2.push_back(7); v.push_back(v2); v.push_back(vector&lt;int&gt;(10, 0)); for (int i = 0; i &lt; v.size(); i++) &#123; //整体作为二维数组输出 for (int j = 0; j &lt; v[i].size(); j++) &#123; cout &lt;&lt; v[i][j] &lt;&lt; &quot;\\t&quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 优先队列priority_queue的代码演示1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y; double z; bool operator&lt; (const node &amp;b) const &#123; //默认使用必须重载小于号 //但小于号内部可以实现各种各样符合需求的功能 return this-&gt;x &gt; b.x; &#125;&#125;;int main() &#123; priority_queue&lt;node&gt; que; que.push((node)&#123;1, 2, 4.5&#125;); que.push((node)&#123;2, 1, 5.6&#125;); cout &lt;&lt; que.top().x &lt;&lt; endl; que.pop(); cout &lt;&lt; que.top().x &lt;&lt; endl; /* priority_queue&lt;int&gt; que;//默认为大顶堆，从大到小输出 que.push(10); que.push(20); que.push(5); que.push(6); que.push(1); while (!que.empty()) &#123; cout &lt;&lt; que.top() &lt;&lt; endl; que.pop(); &#125; */ return 0;&#125; 默认就是从大到小排列 自定义结构体，需要重载小于号(完成了大于号的功能) string string str; str.size() / str.length() str.find(s2); //在str中查找s2，如果找到，返回正整数下标 abcde中str.find(“cd”), 返回2 传入两个参数：abcdcde中str.find(“cd”, 3): 从3下标开始找，返回4 若何判断有没有找到：等于表示没找到。不等于表示找到了。不可直接写-1 npos：（no position） 无符号long long str.insert(x, s2); 在x出插入字符串s2 abcde ：str.insert(2, “123”) &gt; ab123cde str.sub(s2): 字符串截取： 一个参数：abcde ： str.sub(2) &gt; cde(一直截取到最后) 两个参数：abcde ： str.sub(2, 2) &gt; cd(第二个参数表示截取的长度) str.replace(x, y, s2): 从第x个位置替换长度为y ，替换为s2 abcde：str.replace(2, 2, “123”) &gt; ab123e 重载运算符： 加号”+“：string a = “123” + “a”; a = “123a” 大于等于“&lt;&gt; &gt;= &lt;= !=”:根据字典序去判断 map 键值对（映射） 头文件: map &lt;string , int&gt; m;(由字符串类型对于整形的映射) 一一对应的一种关系： “123” &gt; 456 [] : m[“123”] = 456; key与value 假如直接输出 cout &lt;&lt; m[“123”] &lt;&lt; endl; 会自动寻找123所对应的映射值，假如没有int类型的会自动加一个默认值0，字符串给一个默认值空 insert find earse count 返回有多少键，可通过返回01判断某个元素是否出现过 如果自定义结构体作为key，必须要重载小于号。因为map本质是一个红黑树RBTree，有序的。需要让他知道如何排序。 multimap： 可以存在多键； unordered_map: 内部是哈希表，均摊时间复杂度 O1 代码演示 没有456，会在里面加一个456；并且会返回一个默认值0 自定义结构体使用map pair的使用Oj-383. 周末舞会 解题思路 两个队列，每次输出队首元素 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123; int x, y, n; cin &gt;&gt; x &gt;&gt; y &gt;&gt; n; queue&lt;int&gt; qx, qy; for (int i = 1; i &lt;= x; i++) &#123; qx.push(i); &#125; for (int i = 1; i &lt;= y; i++) &#123; qy.push(i); &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; qx.front() &lt;&lt; &quot; &quot; &lt;&lt; qy.front() &lt;&lt; endl; qx.push(qx.front()); qy.push(qy.front()); qy.pop(); qx.pop(); &#125; return 0;&#125; ==Oj-378==. 字符串括号匹配2解题思路 碰到括号，无条件的联想到栈 碰到括号，就入栈；碰到括回，查看是否匹配成对； 注意提前判断栈顶元素是否为空； 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;//string 类生成一个对象using namespace std;int main() &#123; string s; cin &gt;&gt; s; stack&lt;char&gt; sta; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] == &#x27;(&#x27; || s[i] == &#x27;[&#x27; || s[i] == &#x27;&#123;&#x27;) &#123; sta.push(s[i]); &#125; else if (s[i] == &#x27;)&#x27;) &#123; if (sta.empty() || sta.top() != &#x27;(&#x27;) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return 0; &#125; sta.pop(); &#125; else if (s[i] == &#x27;]&#x27;) &#123; if (sta.empty() || sta.top() != &#x27;[&#x27;) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt;endl; return 0; &#125; sta.pop(); &#125; else if (s[i] == &#x27;&#125;&#x27;) &#123; if (sta.empty() || sta.top() != &#x27;&#123;&#x27;) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return 0; &#125; sta.pop(); &#125; &#125; if (sta.empty()) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125; Oj-376. 机器翻译 解题思路 碰到一个词，判断是否在队列中，如果在就直接pass 如果队列已满，则弹出队首元素； 如果在队列当中，直接标记成1 代码12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int ans, n, m, mark[1005];int main() &#123; cin &gt;&gt; m &gt;&gt; n;//m表示内存大小，n个单词 queue&lt;int&gt; que; for (int i = 0; i &lt; n; i++) &#123; int t; cin &gt;&gt; t; if (mark[t] == 0) &#123;//如果不在内存单元里 ans++; if (que.size() == m) &#123;//表示内存已满 mark[que.front()] = 0;//弹出前标记取消，因为已经不在内存当中了 que.pop();//弹出 &#125; que.push(t); mark[t] = 1; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Oj-379. 仓库日志 解题思路 栈 本题一个栈就够了 需要一个额外的栈，表示当前仓库当中的极大值，输出栈顶元素 货物栈 极大值栈 入1 入1 入2 比较,2 大 查询 输出最顶层的2 入4 4大于2，入栈4 入2 2 小于 最大的4，不入栈 查询 直接输出栈顶元素4 代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; int n;//表示操作次数 stack&lt;int&gt; g, mmax; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int t; cin &gt;&gt; t; if (t == 0) &#123; cin &gt;&gt; t; g.push(t);//货物占无条件入栈 if (mmax.empty()) &#123; mmax.push(t);//如果是空的，直接入栈 &#125; else &#123;//如果不是空的，比较后入栈大的 mmax.push(max(t, mmax.top())); &#125; &#125; else if (t == 1) &#123; if (!g.empty()) &#123; g.pop(); mmax.pop(); &#125; &#125; else if (t == 2) &#123; if (g.empty()) &#123;//如果栈此时为空 cout &lt;&lt; 0 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; mmax.top() &lt;&lt; endl;//不是空，输出极大值栈的栈顶元素 &#125; &#125; &#125; return 0;&#125; ==Oj-382==. 报数 解题思路 约瑟夫环问题 建立一个人的队列 1234567 第一个人报1 ，安全了扔到队尾2345671 第二个人报数2，安全扔到队尾3456712 第三个人报数3，淘汰 ，不扔到队尾456712 第四个人报数1，安全，扔到队尾567124 当que.size（）== 1的时候吗，输出答案 代码123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123; int n, m, now = 1;//n个人，报数到m的人会被淘汰，now此时报的数 cin &gt;&gt; n &gt;&gt; m; queue&lt;int&gt; que; for (int i = 1; i &lt;= n; i++) &#123; que.push(i); &#125; while (que.size() != 1) &#123; if (now == m) &#123; que.pop();//淘汰 now = 1;//当前报的号重置为1 &#125; else &#123; que.push(que.front()); now++; que.pop();//放到队尾后还得把自身弹出 &#125; &#125; cout &lt;&lt; que.front() &lt;&lt; endl; return 0;&#125; Oj-384. 敲七 解题思路 类似上一题 代码1 ==Oj-385. 海港== 解题思路 队列 队列中可以存船的信息或者人的信息 如何求国家的数量：map键值对，或者开一个大的标记数组 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct person &#123; int t, c;//队列中存入人的信息：来的时间 国家&#125;;int n, con, mark[100005];//船 多少个国家 标记数组存每个国家有多少人int main() &#123; queue&lt;person&gt; que; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; int at, pcnt;//到达时间和人数 scanf(&quot;%d%d&quot;, &amp;at, &amp;pcnt); while (!que.empty() &amp;&amp; at - que.front().t &gt;= 86400) &#123;//队列不为 //空且人是一天之前来的，那就把人赶出去 mark[que.front().c]--; if (mark[que.front().c] == 0) &#123; con--;//如果这个人是国家的最后一个人，那么国家数量-1 &#125; que.pop(); &#125; for (int j = 0; j &lt; pcnt; j++) &#123;//来的船统计一下 int temp; scanf(&quot;%d&quot;, &amp;temp); que.push((person)&#123;at, temp&#125;); mark[temp]++; if (mark[temp] == 1) &#123; con++;//如果是国家的第一个人，国家数+1 &#125; &#125; printf(&quot;%d\\n&quot;, con); &#125; return 0;&#125; Oj-569. 溶液模拟器 解题思路 使用栈。加的时候入栈，并且处理一下数据；撤销的时候出栈。 存入盐的质量和总质量 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;using namespace std;struct node &#123; double s, ws;//s盐的质量，ws总质量&#125;;int main() &#123; double ws0, c0, s0;//初始总质量，初始浓度，初始盐 cin &gt;&gt; ws0 &gt;&gt; c0; s0 = ws0 * c0 / 100; int n; cin &gt;&gt; n; stack&lt;node&gt; sta;//定义一个栈 for (int i = 0; i &lt; n; i++) &#123; char t; cin &gt;&gt; t; if (t == &#x27;P&#x27;) &#123;//说明加入了东西 double wst, ct, st;//临时总质量，浓度，盐 cin &gt;&gt; wst &gt;&gt; ct; st = wst * ct / 100; ws0 += wst; s0 += st; sta.push((node)&#123;st, wst&#125;);//存入栈中，第一个放的是盐 第二个放的是盐+水 &#125; else &#123; if (sta.size()) &#123;//如果栈不为空，有东西才往外弹 ws0 -= sta.top().ws; s0 -= sta.top().s; sta.pop(); &#125; &#125; printf(&quot;%d %.5f\\n&quot;, (int)ws0, s0 / ws0 * 100); &#125; return 0;&#125; LeetCode.232 用栈实现队列 解题思路 两个栈，从一个栈pop出来push到另外一个栈里面 pop： 把s1所有元素扔到右边s2里，弹出栈顶元素，再把s2所有元荤扔回s1 front（获取队首元素）：把s1所有元素逐个仍达s2，输出栈顶元素，再扔回去 代码 LeetCode.225 队列模拟一个栈解题思路 一个队列就行了，push的时候，把push的数字前的所有数按顺序push到队列末尾，然后队首元素就是栈顶元素一个 oj-575. 查字典 ==Oj-240==. 打印图形4 解题思路 递归：将大的问题分解成小问题 图案：字符类型的 二维数组 func（1，1，7）递归函数：在（1，1）点画一个大小为7的图形 注意点：递归边界：什么时候停止递归（当大小n为1的时候，直接画一个x就好） ​ 递归式： 当n=1，边长为1； n=2，边长为3； n=3，边长为9； 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;int num[10] = &#123;0, 1&#125;;//存入边长char mmap[3000][3000];//画布void init() &#123; for (int i = 2; i &lt;= 7; i++) &#123; num[i] = num[i - 1] * 3; &#125;&#125;void func(int x, int y, int n) &#123; if (n == 1) &#123; mmap[x][y] = &#x27;X&#x27;;//递归边界 return ; &#125; func(x, y, n - 1);//如果不是1，分解成5个小图形 func(x, y + num[n] / 3 * 2, n - 1); func(x + num[n] / 3 * 2, y, n - 1); func(x + num[n] / 3, y + num[n] / 3, n - 1); func(x + num[n] / 3 * 2, y + num[n] / 3 * 2, n - 1);&#125;int main() &#123; init(); func(1, 1, 7); int t; while (cin &gt;&gt; t) &#123; if (t == -1) &#123; break; &#125; for (int i = 1; i &lt;= num[t]; i++) &#123; for (int j = 1; j &lt;= num[t]; j++) &#123; if (mmap[i][j] == &#x27;X&#x27;) &#123;//如果是x，就输出x cout &lt;&lt; &#x27;X&#x27;; &#125; else &#123; cout &lt;&lt; &#x27; &#x27;;//否者输出一个空格 &#125; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; &#x27;-&#x27; &lt;&lt; endl; &#125; return 0;&#125; ==Oj-235. 递归实现指数型枚举== 解题思路 递归的一层选一个数字 答案记录在数组中 递归函数的两个参数：一：这一层是从第几层开始选； ​ 二：这一层是第几层。 可以用纸和笔模拟一下 代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int n, num[15];//num表示存入的那些数字void p(int deep) &#123; for (int i = 1; i &lt;= deep; i++) &#123; if (i != 1) &#123; cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; num[i]; &#125; cout &lt;&lt; endl;&#125;void func(int s, int deep) &#123;//这一层从几开始选 这一层是第几层 for (int i = s; i &lt;= n; i++) &#123; num[deep] = i; p(deep);//输出到第几层 func(i + 1, deep + 1); &#125;&#125;int main() &#123; cin &gt;&gt; n; func(1, 1); return 0;&#125; 12345678910111213141516171819202122232425262728293031//只有一个参数，有回溯感 （类似深搜）#include &lt;iostream&gt;using namespace std;int n, num[15], cnt;//cnt表示选到了第几个数void p() &#123; for (int i = 0; i &lt;= cnt; i++) &#123; if (i) &#123; cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; num[i]; &#125; cout &lt;&lt; endl;&#125;void func(int s) &#123; for (int i = s; i &lt;= n; i++) &#123; num[cnt] = i; p(); cnt++; func(i + 1); cnt--;//递归回去之后，回溯 &#125;&#125;int main() &#123; cin &gt;&gt; n; func(1); return 0;&#125; ==Oj-236==. 递归实现组合型枚举 解题思路 如何输出： func（s, left）: 从几开始选 还剩几个数需要选 递归边界：当left == 0的时候，表示所有数都选完了 讲解视频包含模拟 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int n, m, num[15], cnt;void p() &#123; for (int i = 0; i &lt; cnt; i++) &#123; if (i) &#123; cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; num[i]; &#125; cout &lt;&lt; endl;&#125;void func(int s, int left) &#123; if (left == 0) &#123; p(); return ; &#125; for (int i = s; i &lt;= n; i++) &#123; num[cnt] = i; cnt++; func(i + 1, left - 1); cnt--; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; func(1, m); return 0;&#125; ==Oj-237.== 递归实现排列性枚举 解题思路 不同点：每一层都是1-n循环 ​ 引入标记数组，得知道这个数有没有被选过 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;int n, num[15], mark[15], cnt;void p() &#123; for (int i = 0; i &lt; n; i++) &#123; if (i) &#123; cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; num[i]; &#125; cout &lt;&lt; endl;&#125;void func(int left) &#123;//传入剩几个数需要选 if (left == 0) &#123;//递归边界 p(); return ; &#125; for (int i = 1; i &lt;= n; i++) &#123;//每一层都从1开始 if (mark[i] == 0) &#123;//没有被占用过，才可以选 mark[i] = 1;//先标记上，占了 num[cnt] = i;//把数存在对应的位置 cnt++; func(left - 1); cnt--; mark[i] = 0;//取消标记 &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; func(n); return 0;&#125; 排列组合问题的总结 递归 240 排列组合三兄弟 235 ​ 236 组合 ​ 237 全排列 排列组合与搜索走地图问题==搜索的解题套路== 1.状态如何定义 存 起 终 转 重 2.起始状态 3.终止状态 4.状态如何转移 5.去重（避免重复搜索） 什么是深度搜索 搜索与回溯的过程 ==什么是搜索走地图问题== 深搜走地图：每次找到下一个点，都以此为起点重新开始走 能否从起点走到终点？？ 方向数组 存地图 func（x,y）: 把起点传入递归函数中，循环四个方向，求出新方向的坐标，判断是否可以走。 如果可以走，递归进行到下一层。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int n, m, sx, sy;//地图n行m列，起点横坐标和纵坐标char mmap[105][105];//定义一个地图int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;//方向数组int func(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123;//分别王四个方向去走 int xx = x + dir[i][0]; int yy = y + dir[i][1];//新点的横纵坐标 if (mmap[xx][yy] == &#x27;T&#x27;) &#123; return 1;//直接走到终点，返回1 &#125; if (mmap[xx][yy] == &#x27;.&#x27;) &#123;//表示可以走 mmap[xx][yy] = &#x27;#&#x27;;//避免重复搜索，死循环。如果可以走，标记一下 if (func(xx, yy) == 1) &#123;//再以此为起点继续往下递归 return 1;//上一层return 1 每一层都return1 最终在主函数return1 &#125; &#125; &#125; return 0;//四个方向都走不到&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; mmap[i][j]; if (mmap[i][j] == &#x27;S&#x27;) &#123;//判断起点 sx = i, sy = j; &#125; &#125; &#125; if (func(sx, sy) == 1) &#123;//以起点开始去搜返回1 cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125; ==LeetCode-200.岛屿数量== 深搜，当找到一个岛屿，cnt++，并且将其相连的所有1变成0 ==Oj-535==. 瓷砖 解题思路 深搜，碰到一个点，就以此为起点。并且cnt++ 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int n, m, ans = 1, sx, sy;int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;char mmap[105][150];void func(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123;//循环四个方向 int xx = x + dir[i][0];//每次求出新方向的坐标 int yy = y + dir[i][1]; if (mmap[xx][yy] == &#x27;.&#x27;) &#123; ans++; mmap[xx][yy] = 0;//去重 func(xx, yy);//以新起点开始继续往下递归 &#125; &#125;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; mmap[i][j]; if (mmap[i][j] == &#x27;@&#x27;) &#123;//读入时判断是否为起点 sx = i, sy = j;//是就记录坐标 &#125; &#125; &#125; func(sx, sy); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; ==Oj-397==. 僵尸来袭 解题思路 求一共有几片连在一起的数字区域 每遇到一个不为0的数字就开始深搜，同时ans++；并且把有数字的都变成0 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;int n, m, ans, mmap[105][105];int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;void func(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (mmap[xx][yy] != 0) &#123; mmap[xx][yy] = 0; func(xx, yy); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; mmap[i][j]; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123;//遍历整个地图 if (mmap[i][j] != 0) &#123; ans++; mmap[i][j] = 0; func(i, j); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Oj-536. 最大黑色区域 解题思路 与上一题题意相近 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;int n, m, ans, temp;int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;char mmap[105][105];void func(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (mmap[xx][yy] == &#x27;1&#x27;) &#123; temp++; mmap[xx][yy] = 0; func(xx, yy); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; &amp;mmap[i][1];//如果是存入到mmp[i][0],可以直接写，不然需要取地址 &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (mmap[i][j] == &#x27;1&#x27;) &#123; temp = 1; mmap[i][j] = 0; func(i, j); ans = max(ans, temp);//更新区域的最大值 &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Oj-396. 填涂颜色 解题思路 被1包住的0无法判断，但是没被1包住的0可以判断 没被1包住的0肯定和地图边缘相连，可以都改成另外一个数字3 方法一：遍历整个外圈，如果是0，那肯定和外圈相邻，以他为起点，把所有0改成3 方法二：从（1，1）开始存数据，所以外圈有一圈0，而且是连通的。 ​ 所以可以从左上角（0，0）点开始搜索，相邻的0都改成3 ​ 缺点：需要严格判断边界 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;int n, mmap[50][50];int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;void func(int x, int y) &#123;//没有返回值，只是判断连通性 for (int i = 0; i &lt; 4; i++) &#123; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (xx &lt; 0 || yy &lt; 0 || xx &gt; n + 1 || yy &gt; n + 1) &#123;//单独判断边界，说明出界 continue; &#125; if (mmap[xx][yy] == 0) &#123;//说明是相连的0，改成3 mmap[xx][yy] = 3; func(xx, yy);//新点为起点继续深搜 &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; mmap[i][j]; &#125; &#125; mmap[0][0] = 3; func(0, 0);//00点为起点，开始搜索 for (int i = 1; i &lt;= n; i++) &#123;//按要求，根据0，1，3分别输出不同的值 for (int j = 1; j &lt;= n; j++) &#123; if (j != 1) &#123; cout &lt;&lt; &quot; &quot;; &#125; if (mmap[i][j] == 3) &#123; cout &lt;&lt; 0; &#125; else if (mmap[i][j] == 0) &#123; cout &lt;&lt; 2; &#125; else &#123; cout &lt;&lt; 1; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Oj-404. 01迷宫简易版 解题思路 输入地图，以题目中给的点为起点深搜。 和之前不一样，就可以走 需要开一个去重数组，访问过的点就标记上 需要判断边界，因为最外面一圈都是0 代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int n, m, mark[3003][3005], ans, sx, sy;int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;char mmap[3005][3005];//虽然是0和1，但是因为是连着输入的，所以需要字符数组void func(int x, int y) &#123; for (int i = 0; i &lt; 4; i++) &#123; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (xx &lt; 1 || yy &lt; 1 || xx &gt; n || yy &gt; m || mark[xx][yy] == 1) &#123;//表示在标记数组中标记了 continue;//判断边界 &#125; if (mmap[x][y] != mmap[xx][yy]) &#123;//来的那个点和新求出来的那个点不一样 ans++; mark[xx][yy] = 1;//在标记数组里标记上 func(xx, yy); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; &amp;mmap[i][1]; &#125; cin &gt;&gt; sx &gt;&gt; sy; ans = 1; mark[sx][sy] = 1;//标记为1，表示已经搜过 func(sx, sy); cout &lt;&lt; ans &lt;&lt; endl;//搜索完毕直接输出答案 return 0;&#125; ==Oj-405==. 01迷宫 解题思路 比上一题多了个k次， 方法一：上一个代码循环k次，会超时 方法二：空间换时间，先遍历一遍，把每个点究竟能走到多少提前处理好 用队列暂存数据 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y;//自定义结构坐标，&#125;;queue&lt;node&gt; que;int n, m, k, ans[3005][3005], temp;//ans存答案以及去重数组，//temp搜索过程中某一点处一共有几片连同的点int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;char mmap[3005][3005];void check() &#123; while (!que.empty()) &#123; node t = que.front(); que.pop(); ans[t.x][t.y] = temp;//每个点上存上有多少个连同点 &#125;&#125;void func(int x, int y) &#123; que.push((node)&#123;x, y&#125;);//先把点存入队列中 for (int i = 0; i &lt; 4; i++) &#123; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (xx &lt; 1 || yy &lt; 1 || xx &gt; n || yy &gt; m || ans[xx][yy] != 0) &#123; continue; &#125; if (mmap[x][y] != mmap[xx][yy]) &#123;//不一样，就可以走 ans[xx][yy] = 1; temp++; func(xx, yy); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; &amp;mmap[i][1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123;//从头到尾遍历 if (ans[i][j] == 0) &#123;//说明没有走过 temp = 1; ans[i][j] = 1;//标记，表示占了 func(i, j); check();//用队列记录点的信息 &#125; &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; ans[a][b] &lt;&lt; endl; &#125; return 0;&#125; ==什么是广搜？== 需要用到一个队列 搜索队列 按照层数来，一层一层往外扩展 经典问题，起点走到终点，并且求出最短步数 因为按层数来，所以最先搜到的一定是最短的 自定义结构：横纵坐标 到这里走了多少步 广搜走地图的代码演示12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y, step;//横纵坐标以及步数&#125;;int n, m, sx, sy;int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;char mmap[105][105];int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; mmap[i][j]; if (mmap[i][j] == &#x27;S&#x27;) &#123; sx = i, sy = j;//记录起点坐标 &#125; &#125; &#125; queue&lt;node&gt; que;//建立搜索队列 que.push((node)&#123;sx, sy, 0&#125;); while (!que.empty()) &#123;//当队列不为空就一直搜 node temp = que.front();//每次拿出队列队首元素状态并且弹出去 que.pop(); for (int i = 0; i &lt; 4; i++) &#123;//往四个方向走 int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1];//求出新点的坐标 if (mmap[x][y] == &#x27;T&#x27;) &#123;//如果是终点 cout &lt;&lt; temp.step + 1 &lt;&lt; endl;//直接输出答案 return 0; &#125; if (mmap[x][y] == &#x27;.&#x27;) &#123;//如果可以走 mmap[x][y] = 0;//去重，改成不能走 que.push((node)&#123;x, y, temp.step + 1&#125;); &#125; &#125; &#125; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;//所有试完了还没有return 0，说明走不到终点 return 0;&#125; ==Oj-396== . 填涂颜色广搜版-解决连通性问题解题思路 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y;&#125;;int n, mmap[50][50];int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; mmap[i][j]; &#125; &#125; queue&lt;node&gt; que; que.push((node)&#123;0, 0&#125;); mmap[0][0] = 3; while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (x &lt; 0 || y &lt; 0 || x &gt; n + 1 || y &gt; n + 1 || mmap[x][y] == 3) &#123;//判断边界 continue; &#125; if (mmap[x][y] == 0) &#123; mmap[x][y] = 3; que.push((node)&#123;x, y&#125;); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (j != 1) &#123; cout &lt;&lt; &quot; &quot;; &#125; if (mmap[i][j] == 3) &#123; cout &lt;&lt; 0; &#125; else if (mmap[i][j] == 0) &#123; cout &lt;&lt; 2; &#125; else &#123; cout &lt;&lt; 1; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; ==Oj-399==. 小明吃饭 解题思路 最短步数，去重直接改原地图 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y, step;&#125;;int n, m, sx, sy;int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;char mmap[505][505];int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; mmap[i][j]; if (mmap[i][j] == &#x27;2&#x27;) &#123; sx = i, sy = j; &#125; &#125; &#125; queue&lt;node&gt; que; que.push((node)&#123;sx, sy, 0&#125;); while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (mmap[x][y] == &#x27;3&#x27;) &#123;//如果是终点 cout &lt;&lt; temp.step + 1 &lt;&lt; endl; return 0; &#125; if (mmap[x][y] == &#x27;.&#x27;) &#123;//如果是可以走的点，需要继续搜索 mmap[x][y] = 0; que.push((node)&#123;x, y, temp.step + 1&#125;); &#125; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125; ==Oj-304==. 骑士风度的牛 解题思路 马走日 难点：11点走有可能会越界 从（2，2）点开始存图 或者直接从（5，5）点 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y, step;&#125;;int n, m;int dir[8][2] = &#123;1, 2, 1, -2, -1, 2, -1, -2, 2, 1, 2, -1, -2, 1, -2, -1&#125;;char mmap[200][200];int main() &#123; cin &gt;&gt; m &gt;&gt; n; queue&lt;node&gt; que; for (int i = 5; i &lt; n + 5; i++) &#123;//(1,1)开始读到（n,m）结束 （5，5）读从（n+4,m+4）结束 for (int j = 5; j &lt; m + 5; j++) &#123; cin &gt;&gt; mmap[i][j]; if (mmap[i][j] == &#x27;K&#x27;) &#123; que.push((node)&#123;i, j, 0&#125;); &#125; &#125; &#125; while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 8; i++) &#123;//循环8个方向 int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (mmap[x][y] == &#x27;H&#x27;) &#123; cout &lt;&lt; temp.step + 1 &lt;&lt; endl; return 0; &#125; if (mmap[x][y] == &#x27;.&#x27;) &#123; que.push((node)&#123;x, y, temp.step + 1&#125;); mmap[x][y] = &#x27;#&#x27;; &#125; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125; ==Oj-398==. 马的遍历 解题思路 大数组存答案并且去重 点不为0，就不用搜了 最后输出走不了的特殊判断 ： 是不是起点，是不是到不了的点 或者直接初始化为-1，可以避免特判 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;struct node &#123; int x, y, step;&#125;;int num[405][405], n, m, sx, sy;int dir[8][2] = &#123;1, 2, 1, -2, -1, 2, -1, -2, 2, 1, 2, -1, -2, 1, -2, -1&#125;;int main() &#123; memset(num, -1, sizeof(num));//数组都初始化为-1 需要用到头文件 cin &gt;&gt; n &gt;&gt; m &gt;&gt; sx &gt;&gt; sy; num[sx][sy] = 0; queue&lt;node&gt; que; que.push((node)&#123;sx, sy, 0&#125;); while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 8; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m || num[x][y] != -1) &#123;//最后判断是否求过 continue; &#125; num[x][y] = temp.step + 1;//上一个点的步数+1 que.push((node)&#123;x, y, num[x][y]&#125;);//新点放到搜索队列中 &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (j != 1) &#123; cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; num[i][j]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Oj-401. 奇怪的象棋游戏升级版 解题思路 任一点到（1，1）的距离 》 （1，1）点到任一点的距离 起点与终点调换 ，以（1，1）为起点，往外遍历所有地图，记录答案，结果直接输出对应坐标所存的答案 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;struct node &#123; int x, y, step;&#125;;int n, num[505][505];int dir[12][2] = &#123; 1, 2, 1, -2, -1, 2, -1, -2, 2, 1, 2, -1, -2, 1, -2, -1, 2, 2, 2, -2, -2, 2, -2, -2&#125;;int main() &#123; memset(num, -1, sizeof(num));//起点是0，避免特判，数组初始化为-1 queue&lt;node&gt; que;//建立搜索队列 que.push((node)&#123;1, 1, 0&#125;);//起点放入搜索队列中 num[1][1] = 0;//起点答案初始化一下 while (!que.empty()) &#123; node temp = que.front(); que.pop();//拿出队首元素后再弹出 for (int i = 0; i &lt; 12; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (x &lt; 1 || y &lt; 1 || x &gt; 500 || y &gt; 500 || num[x][y] != -1) &#123; continue; &#125; num[x][y] = temp.step + 1;//记录答案，然后放到搜索队列中 que.push((node)&#123;x, y, temp.step + 1&#125;); &#125; &#125; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; num[a][b] &lt;&lt; endl; &#125; return 0;&#125; ==Oj-303==. 矩阵距离一 解题思路 类似于上一题，以所有的1为起点开始往外走 涉及到输出答案为0，所以可以把数组初始化为-1，再进行去重 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;struct node &#123; int x, y, step;&#125;;int n, m, num[1005][1005];int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;char mmap[1005][1005];//char数组存真的地图int main() &#123; memset(num, -1, sizeof(num)); cin &gt;&gt; n &gt;&gt; m; queue&lt;node&gt; que; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; mmap[i][j]; if (mmap[i][j] == &#x27;1&#x27;) &#123; que.push((node)&#123;i, j, 0&#125;);//放到搜索队列中 num[i][j] = 0; &#125; &#125; &#125;//此时，所以1起点都整装待发 while (!que.empty()) &#123;//开始广搜 node temp = que.front();//每次拿出队首元素 que.pop(); for (int i = 0; i &lt; 4; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1];//求出新点的坐标，并进行判断 if (mmap[x][y] != 0 &amp;&amp; num[x][y] == -1) &#123;//先判断下有没有出界 //不为0，说明输入了数据，没出界 num[x][y] = temp.step + 1; que.push((node)&#123;x, y, num[x][y]&#125;); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (j != 1) &#123; cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; num[i][j]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Oj-305. 乳草的入侵 解题思路 广搜 起始状态：左下角 终止状态：所有能走过的都做过了，即搜索队列为空时候，所有的点都被占了 问题：如何记录答案：int ans 不断更新ans， 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y, step;&#125;;int n, m, sx, sy;int dir[8][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1&#125;;char mmap[105][105];int main() &#123; cin &gt;&gt; m &gt;&gt; n &gt;&gt; sy &gt;&gt; sx; sx = n - sx + 1;//在左下角 for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; &amp;mmap[i][1];//一次读一行，因为不需要单独判断是否为起点 &#125; queue&lt;node&gt; que; que.push((node)&#123;sx, sy, 0&#125;); mmap[sx][sy] = 0;//避免搜索重复 int ans = 0; while (!que.empty()) &#123; node temp = que.front(); ans = temp.step;//不用写max，因为最后的肯定是最后进队列的，肯定是最远的那个点 que.pop(); for (int i = 0; i &lt; 8; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (mmap[x][y] == &#x27;.&#x27;) &#123; mmap[x][y] = 0; que.push((node)&#123;x, y, temp.step + 1&#125;); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; ==Oj-529==. 龙与虫 解题思路 预设能干掉敌人终点的位置，以敌人为起点 从绿框出发，走到任意一个蓝框所需要的最短距离 注意：多组数据，地图不可以直接更改，因为还需要用到，所以额外开数组：标记终点1与去重2 一个数组完成两个功能 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y, step;&#125;;int n, m;//地图大小int dir[8][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1&#125;;//走的时候只遍历0-3；射击的时候遍历0-7char mmap[150][150];int func() &#123; int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if (!a) return 0; int mark[150][150] = &#123;0&#125;; for (int i = 0; i &lt; 8; i++) &#123; for (int j = 1; 1; j++) &#123; int x = a + dir[i][0] * j; int y = b + dir[i][1] * j; if (mmap[x][y] != &#x27;O&#x27;) break; mark[x][y] = 1;//标记为1，说明可以射到敌人 &#125; &#125; mark[a][b] = 1;//敌人自己这个点本来就可以设到，设为1 if (mark[c][d] == 1) &#123;//如果开始的点直接就可以打到敌人 cout &lt;&lt; 0 &lt;&lt; endl; return 1; &#125; queue&lt;node&gt; que; que.push((node)&#123;c, d, 0&#125;); mark[c][d] = 2;//标记2，说明走过了 while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (mark[x][y] == 1) &#123;//说明能射到敌人 cout &lt;&lt; temp.step + 1 &lt;&lt; endl; return 1; &#125; if (mmap[x][y] == &#x27;O&#x27; &amp;&amp; mark[x][y] != 2) &#123;//如果是可以走的点：可以走，且没走过 que.push((node)&#123;x, y, temp.step + 1&#125;); mark[x][y] = 2;//标记为2，防止重复访问 &#125; &#125; &#125; cout &lt;&lt; &quot;Impossible!&quot; &lt;&lt; endl; return 1;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; &amp;mmap[i][1]; &#125; while (func()) &#123;&#125; return 0;&#125; ==oj-81==. 小明回家 按位存储状态 ==Oj-527==. 飞跃原野 终点在于如何去重：三位check数组 根据不同的能量分别去重 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y, step, d;&#125;;int n, m, d, mark[105][105][105];int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;;char mmap[105][105];int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; d; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; &amp;mmap[i][1]; &#125; queue&lt;node&gt; que; que.push((node)&#123;1, 1, 0, d&#125;); for (int i = 0; i &lt;= d; i++) &#123; mark[1][1][i] = 1; &#125; while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; for (int j = 2; j &lt;= temp.d; j++) &#123; int x = temp.x + dir[i][0] * j; int y = temp.y + dir[i][1] * j; if (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m) &#123; break; &#125; if (x == n &amp;&amp; y == m) &#123; cout &lt;&lt; temp.step + 1 &lt;&lt; endl; return 0; &#125; if (mmap[x][y] == &#x27;P&#x27; &amp;&amp; mark[x][y][temp.d - j] == 0) &#123; que.push((node)&#123;x, y, temp.step + 1, temp.d - j&#125;); mark[x][y][temp.d - j] = 1; &#125; &#125; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (x == n &amp;&amp; y == m) &#123; cout &lt;&lt; temp.step + 1 &lt;&lt; endl; return 0; &#125; if (mmap[x][y] == &#x27;P&#x27; &amp;&amp; mark[x][y][temp.d] == 0) &#123; que.push((node)&#123;x, y, temp.step + 1, temp.d&#125;); mark[x][y][temp.d] = 1; &#125; &#125; &#125; cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl; return 0;&#125; ==Oj-528==. 关系网络 解题思路 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int now, step;&#125;;int n, x, y, check[105], arr[105][105];int main() &#123; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; arr[i][j]; &#125; &#125; queue&lt;node&gt; que; que.push((node)&#123;x, 0&#125;); check[x] = 1; while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 1; i &lt;= n; i++) &#123; if (arr[temp.now][i] == 1 &amp;&amp; check[i] == 0) &#123; if (i == y) &#123; cout &lt;&lt; temp.step &lt;&lt; endl; return 0; &#125; que.push((node)&#123;i, temp.step + 1&#125;); check[i] = 1; &#125; &#125; &#125; cout &lt;&lt; 0 &lt;&lt; endl; return 0;&#125; Oj-538. 图的遍历 解题思路 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int n, arr[25][25], check[25];void func(int now) &#123; if (now != 1) &#123; cout &lt;&lt; &quot;-&quot;; &#125; cout &lt;&lt; now; check[now] = 1; for (int i = 1; i &lt;= n; i++) &#123; if (check[i] == 0 &amp;&amp; arr[now][i] == 1) &#123; func(i); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cin &gt;&gt; arr[i][j]; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (check[i] == 0) &#123; func(i); &#125; &#125; cout &lt;&lt; endl; return 0;&#125; ==Oj-402==. 奇怪的电梯 解题思路 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int now, step;&#125;;int n, a, b, num[205], check[205];int main() &#123; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; num[i]; &#125; queue&lt;node&gt; que; que.push((node)&#123;a, 0&#125;); check[a] = 1; while (!que.empty()) &#123; node temp = que.front(); que.pop(); int up = temp.now + num[temp.now], down = temp.now - num[temp.now]; if (up == b || down == b) &#123; cout &lt;&lt; temp.step + 1 &lt;&lt; endl; return 0; &#125; if (up &lt;= n &amp;&amp; check[up] == 0) &#123; que.push((node)&#123;up, temp.step + 1&#125;); check[up] = 1; &#125; if (down &gt;= 1 &amp;&amp; check[down] == 0) &#123; que.push((node)&#123;down, temp.step + 1&#125;); check[down] = 1; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125; ==Oj-530==. 警察找车 解题思路 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;struct node &#123; int x, y;&#125;;int n, m, cnt;int dir[4][2] = &#123;-1, 0, 1, 0, 0, -1, 0, 1&#125;;char mmap[55][55];int main() &#123; queue&lt;node&gt; que; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; mmap[i][j]; if (mmap[i][j] == &#x27;*&#x27;) &#123; que.push((node)&#123;i, j&#125;); mmap[i][j] = &#x27;.&#x27;; &#125; &#125; &#125; cin &gt;&gt; cnt; while (cnt--) &#123; string str; cin &gt;&gt; str; int dir_num, check[55][55] = &#123;0&#125;, qsize = que.size(); if (str == &quot;NORTH&quot;) &#123; dir_num = 0; &#125; else if (str == &quot;SOUTH&quot;) &#123; dir_num = 1; &#125; else if (str == &quot;WEST&quot;) &#123; dir_num = 2; &#125; else &#123; dir_num = 3; &#125; while (qsize--) &#123; node temp = que.front(); que.pop(); for (int i = 1; 1; i++) &#123; int x = temp.x + dir[dir_num][0] * i; int y = temp.y + dir[dir_num][1] * i; if (mmap[x][y] != &#x27;.&#x27;) &#123; break; &#125; if (check[x][y] == 0) &#123; que.push((node)&#123;x, y&#125;); check[x][y] = 1; &#125; &#125; &#125; &#125; while (!que.empty()) &#123; node temp = que.front(); que.pop(); mmap[temp.x][temp.y] = &#x27;*&#x27;; &#125; for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; &amp;mmap[i][1] &lt;&lt; endl; &#125; return 0;&#125; ==Oj-531==. 奇怪的电视 解题思路 按位与状态 int 有32位，可以存32个不同的状态 1表示按下去，0表示释放 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int status, step;&#125;;int n, num2[22] = &#123;1&#125;, check[2200000], num[25];void init() &#123; for (int i = 1; i &lt;= 20; i++) &#123; num2[i] = num2[i - 1] * 2; &#125;&#125;int main() &#123; init(); cin &gt;&gt; n; int start = 0; for (int i = 1; i &lt;= n; i++) &#123; int t; cin &gt;&gt; t; if (t == 1) &#123; start += num2[i]; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; int t; cin &gt;&gt; t; for (int j = 1; j &lt;= t; j++) &#123; int t2; cin &gt;&gt; t2; num[i] += num2[t2]; &#125; &#125; queue&lt;node&gt; que; que.push((node)&#123;start, 0&#125;); check[start] = 1; while (!que.empty()) &#123; node temp = que.front(); que.pop(); if (temp.status == 8) &#123; cout &lt;&lt; temp.step &lt;&lt; endl; return 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; if ((temp.status &amp; num2[i]) == 0) &#123; int t = temp.status; t &amp;= ~num[i]; t |= num2[i]; if (check[t] == 0) &#123; que.push((node)&#123;t, temp.step + 1&#125;); check[t] = 1; &#125; &#125; &#125; &#125; cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125; ==Oj-537==. 门票问题 解题思路 同236 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int l, c, cnt, ynum, fnum;char num[30], ans[30];void p() &#123; for (int i = 0; i &lt; l; i++) &#123; cout &lt;&lt; ans[i]; &#125; cout &lt;&lt; endl;&#125;int func(int s, int left, int deep) &#123; if (deep == l) &#123; if (ynum &gt;= 1 &amp;&amp; fnum &gt;= 2) &#123; p(); cnt++; if (cnt == 25000) &#123; return 1; &#125; &#125; return 0; &#125; for (int i = s; i &lt; c; i++) &#123; ans[deep] = num[i]; int f = 0; if (num[i] == &#x27;a&#x27; || num[i] == &#x27;e&#x27; || num[i] == &#x27;i&#x27; || num[i] == &#x27;o&#x27; || num[i] == &#x27;u&#x27;) &#123; ynum++; f = 1; &#125; else &#123; fnum++; &#125; if (func(i + 1, left - 1, deep + 1) == 1) &#123; return 1; &#125; if (f == 0) &#123; fnum--; &#125; else &#123; ynum--; &#125; &#125; return 0;&#125;int main() &#123; cin &gt;&gt; l &gt;&gt; c; for (int i = 0; i &lt; c; i++) &#123; cin &gt;&gt; num[i]; &#125; sort(num, num + c); func(0, l, 0); return 0;&#125; ==Oj-540==. 生日购物 解题思路 同235 代码1 ==Oj-541==. 相遇问题 解题思路 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;int n, m, arr[2][20][20], ans[2][100000], cnt[2];void func(int pnum, int now, int cost) &#123; if (now == n) &#123; ans[pnum][cnt[pnum]++] = cost; return ; &#125; for (int i = now + 1; i &lt;= n; i++) &#123; if (arr[pnum][now][i] != 0) &#123; func(pnum, i, cost + arr[pnum][now][i]); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) &#123; int a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; arr[0][a][b] = arr[0][b][a] = c; arr[1][a][b] = arr[1][b][a] = d; &#125; func(0, 1, 0); func(1, 1, 0); int fin = 2100000000; for (int i = 0; i &lt; cnt[0]; i++) &#123; if (fin &lt; ans[0][i]) &#123; continue; &#125; for (int j = 0; j &lt; cnt[1]; j++) &#123; if (ans[0][i] == ans[1][j]) &#123; fin = ans[0][i]; &#125; &#125; &#125; if (fin == 2100000000) &#123; cout &lt;&lt; &quot;IMPOSSIBLE&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; fin &lt;&lt; endl; &#125; return 0;&#125; ==Oj-542==. 奶酪 解题思路 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int t, n, h, r, s[1005], scnt, e[1005], arr[1005][1005], check[1005], ball[1005][3];int func(int now) &#123; if (e[now] == 1) &#123; return 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (arr[now][i] &amp;&amp; check[i] == 0) &#123; check[i] = 1; if (func(i)) &#123; return 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; cin &gt;&gt; t; while (t--) &#123; scnt = 0; memset(e, 0, sizeof(e)); memset(arr, 0, sizeof(arr)); memset(check, 0, sizeof(check)); cin &gt;&gt; n &gt;&gt; h &gt;&gt; r; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; ball[i][0] &gt;&gt; ball[i][1] &gt;&gt; ball[i][2]; if (ball[i][2] &lt;= r) &#123; s[scnt++] = i; &#125; if (ball[i][2] + r &gt;= h) &#123; e[i] = 1; &#125; for (int j = 1; j &lt; i; j++) &#123; int x0 = ball[i][0] - ball[j][0]; int y0 = ball[i][1] - ball[j][1]; int z0 = ball[i][2] - ball[j][2]; if (sqrt(x0 * x0 + y0 * y0 + z0 * z0) &lt;= 2 * r) &#123; arr[i][j] = arr[j][i] = 1; &#125; &#125; &#125; int f = 0; for (int i = 0; i &lt; scnt; i++) &#123; if (check[s[i]] == 0) &#123; check[s[i]] = 1; if (func(s[i])) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; f = 1; break; &#125; &#125; &#125; if (f == 0) &#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; LeetCode.417 太平洋大西洋水流问题 给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。 提示： 输出坐标的顺序不重要m 和 n 都小于150 示例： 给定下面的 5x5 矩阵: 太平洋 ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) * ~ 3 2 3 (4) (4) * ~ 2 4 (5) 3 1 * ~ (6) (7) 1 4 5 * ~ (5) 1 1 2 4 * * * * * * 大西洋 返回: [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元). 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pacific-atlantic-water-flow著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123;public: struct node &#123; int x, y; &#125;; int n, m, check[155][155] = &#123;0&#125;; int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;; vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;vector&lt;int&gt; &gt; ans; if (matrix.size() == 0) &#123; return ans; &#125; n = matrix.size(), m = matrix[0].size(); queue&lt;node&gt; que; for (int i = 0; i &lt; m; i++) &#123; que.push((node)&#123;0, i&#125;); check[0][i] = 1; &#125; for (int i = 1; i &lt; n; i++) &#123; que.push((node)&#123;i, 0&#125;); check[i][0] = 1; &#125; while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (x &lt; 0 || y &lt; 0 || x == n || y == m || check[x][y] == 1 || matrix[temp.x][temp.y] &gt; matrix[x][y]) &#123; continue; &#125; que.push((node)&#123;x, y&#125;); check[x][y] = 1; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; que.push((node)&#123;i, m - 1&#125;); check[i][m - 1] += 2; &#125; for (int i = 0; i &lt; m - 1; i++) &#123; que.push((node)&#123;n - 1, i&#125;); check[n - 1][i] += 2; &#125; while (!que.empty()) &#123; node temp = que.front(); que.pop(); if (check[temp.x][temp.y] == 3) &#123; ans.push_back((vector&lt;int&gt;)&#123;temp.x, temp.y&#125;); &#125; for (int i = 0; i &lt; 4; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (x &lt; 0 || y &lt; 0 || x == n || y == m || (check[x][y] &amp; 2) || matrix[temp.x][temp.y] &gt; matrix[x][y]) &#123; continue; &#125; que.push((node)&#123;x, y&#125;); check[x][y] += 2; &#125; &#125; return ans; &#125;&#125;; ==LeetCode.529== 扫雷游戏让我们一起来玩扫雷游戏！ 给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。 现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板： 如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。如果在此次点击中，若无更多方块可被揭露，则返回面板。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minesweeper著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: struct node &#123; int x, y; &#125;; int n, m; int dir[8][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1&#125;; int func(int x, int y, vector&lt;vector&lt;char&gt;&gt; &amp;mmap) &#123; int t = 0; for (int i = 0; i &lt; 8; i++) &#123; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (xx &lt; 0 || yy &lt; 0 || xx == n || yy == m) &#123; continue; &#125; t += (mmap[xx][yy] == &#x27;M&#x27;); &#125; return t; &#125; vector&lt;vector&lt;char&gt;&gt; updateBoard(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;int&gt;&amp; click) &#123; if (board[click[0]][click[1]] == &#x27;M&#x27;) &#123; board[click[0]][click[1]] = &#x27;X&#x27;; return board; &#125; n = board.size(), m = board[0].size(); queue&lt;node&gt; que; if (func(click[0], click[1], board) == 0) &#123; board[click[0]][click[1]] = &#x27;B&#x27;; que.push((node)&#123;click[0], click[1]&#125;); &#125; else &#123; board[click[0]][click[1]] = func(click[0], click[1], board) + &#x27;0&#x27;; return board; &#125; while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 8; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (x &lt; 0 || y &lt; 0 || x == n || y == m || board[x][y] != &#x27;E&#x27;) &#123; continue; &#125; int t = func(x, y, board); if (t != 0) &#123; board[x][y] = t + &#x27;0&#x27;; &#125; else &#123; board[x][y] = &#x27;B&#x27;; que.push((node)&#123;x, y&#125;); &#125; &#125; &#125; return board; &#125;&#125;; LeetCode.934 最短的桥在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。） 现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。 返回必须翻转的 0 的最小数目。（可以保证答案至少是 1。） 示例 1： 输入：[[0,1],[1,0]]输出：1示例 2： 输入：[[0,1,0],[0,0,0],[0,0,1]]输出：2示例 3： 输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]输出：1 提示： 1 &lt;= A.length = A[0].length &lt;= 100A[i][j] == 0 或 A[i][j] == 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shortest-bridge著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: struct node &#123; int x, y, step; &#125;; int n, m; int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;; queue&lt;node&gt; que; void func(int x, int y, vector&lt;vector&lt;int&gt;&gt; &amp;mmap) &#123; for (int i = 0; i &lt; 4; i++) &#123; int xx = x + dir[i][0]; int yy = y + dir[i][1]; if (xx &lt; 0 || yy &lt; 0 || xx == n || yy == m) &#123; continue; &#125; if (mmap[xx][yy] == 1) &#123; mmap[xx][yy] = 2; que.push((node)&#123;xx, yy, 0&#125;); func(xx, yy, mmap); &#125; &#125; &#125; int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; n = A.size(), m = A[0].size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (A[i][j] == 1) &#123; A[i][j] = 2; que.push((node)&#123;i, j, 0&#125;); func(i, j, A); break; &#125; &#125; if (!que.empty()) &#123; break; &#125; &#125; while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (x &lt; 0 || y &lt; 0 || x == n || y == m) &#123; continue; &#125; if (A[x][y] == 1) &#123; return temp.step; &#125; if (A[x][y] == 0) &#123; A[x][y] = 2; que.push((node)&#123;x, y, temp.step + 1&#125;); &#125; &#125; &#125; return -1; &#125;&#125;; ==LeetCode.967== 连续差相同的数字=返回所有长度为 N 且满足其每两个连续位上的数字之间的差的绝对值为 K 的非负整数。 请注意，除了数字 0 本身之外，答案中的每个数字都不能有前导零。例如，01 因为有一个前导零，所以是无效的；但 0 是有效的。 你可以按任何顺序返回答案。 示例 1： 输入：N = 3, K = 7输出：[181,292,707,818,929]解释：注意，070 不是一个有效的数字，因为它有前导零。示例 2： 输入：N = 2, K = 1输出：[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98] 提示： 1 &lt;= N &lt;= 90 &lt;= K &lt;= 9 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/numbers-with-same-consecutive-differences著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 代码12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; ans; void func(int now, int left, int k) &#123; if (left == 0) &#123; ans.push_back(now); return ; &#125; if (now % 10 + k &lt; 10) &#123; func(now * 10 + now % 10 + k, left - 1, k); &#125; if (k != 0 &amp;&amp; now % 10 - k &gt;= 0) &#123; func(now * 10 + now % 10 - k, left - 1, k); &#125; &#125; vector&lt;int&gt; numsSameConsecDiff(int n, int k) &#123; for (int i = 1; i &lt; 10; i++) &#123; func(i, n - 1, k); &#125; return ans; &#125;&#125;; ==LeetCode.752==打开转盘锁你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。 示例 1: 输入：deadends = [“0201”,”0101”,”0102”,”1212”,”2002”], target = “0202”输出：6解释：可能的移动序列为 “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”。注意 “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” 这样的序列是不能解锁的，因为当拨动到 “0102” 时这个锁就会被锁定。示例 2: 输入: deadends = [“8888”], target = “0009”输出：1解释：把最后一位反向旋转一次即可 “0000” -&gt; “0009”。示例 3: 输入: deadends = [“8887”,”8889”,”8878”,”8898”,”8788”,”8988”,”7888”,”9888”], target = “8888”输出：-1解释：无法旋转到目标数字且不被锁定。示例 4: 输入: deadends = [“0000”], target = “8888”输出：-1 提示： 死亡列表 deadends 的长度范围为 [1, 500]。目标数字 target 不会在 deadends 之中。每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 ‘0000’ 到 ‘9999’ 中产生。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/open-the-lock著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: struct node &#123; string status; int step; &#125;; unordered_map&lt;string, int&gt; m; int openLock(vector&lt;string&gt;&amp; deadends, string target) &#123; for (int i = 0; i &lt; deadends.size(); i++) &#123; m[deadends[i]] = 1; &#125; if (target == &quot;0000&quot;) &#123; return 0; &#125; if (m[&quot;0000&quot;] == 1) &#123; return -1; &#125; queue&lt;node&gt; que; que.push((node)&#123;&quot;0000&quot;, 0&#125;); m[&quot;0000&quot;] = 1; while (!que.empty()) &#123; node temp = que.front(); que.pop(); for (int i = 0; i &lt; 4; i++) &#123; string t = temp.status; t[i]++; if (t[i] &gt; &#x27;9&#x27;) &#123; t[i] = &#x27;0&#x27;; &#125; if (t == target) &#123; return temp.step + 1; &#125; if (m[t] == 0) &#123; m[t] = 1; que.push((node)&#123;t, temp.step + 1&#125;); &#125; t = temp.status; t[i]--; if (t[i] &lt; &#x27;0&#x27;) &#123; t[i] = &#x27;9&#x27;; &#125; if (t == target) &#123; return temp.step + 1; &#125; if (m[t] == 0) &#123; m[t] = 1; que.push((node)&#123;t, temp.step + 1&#125;); &#125; &#125; &#125; return -1; &#125;&#125;; ==LeetCode-864==. 获取所有钥匙的最短路径给定一个二维网格 grid。 “.” 代表一个空房间， “#” 代表一堵墙， “@” 是起点，（”a”, “b”, …）代表钥匙，（”A”, “B”, …）代表锁。 我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。 假设 K 为钥匙/锁的个数，且满足 1 &lt;= K &lt;= 6，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。 返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。 示例 1： 输入：[“@.a.#”,”###.#”,”b.A.B”]输出：8示例 2： 输入：[“@..aA”,”..B#.”,”….b”]输出：6 提示： 1 &lt;= grid.length &lt;= 301 &lt;= grid[0].length &lt;= 30grid[i][j] 只含有 ‘.’, ‘#’, ‘@’, ‘a’-‘f’ 以及 ‘A’-‘F’钥匙的数目范围是 [1, 6]，每个钥匙都对应一个不同的字母，正好打开一个对应的锁。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shortest-path-to-get-all-keys著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: struct node &#123; int x, y, status, step; &#125;; int n, m, check[35][35][200], key_cnt = 0, end_status; int dir[4][2] = &#123;0, 1, 1, 0, 0, -1, -1, 0&#125;; int bit2[10] = &#123;1, 2, 4, 8, 16, 32, 64, 128&#125;; int shortestPathAllKeys(vector&lt;string&gt;&amp; grid) &#123; vector&lt;string&gt; &amp;mmap = grid; n = grid.size(), m = grid[0].size(); queue&lt;node&gt; que; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (mmap[i][j] == &#x27;@&#x27;) &#123; que.push((node)&#123;i, j, 0, 0&#125;); check[i][j][0] = 1; mmap[i][j] = &#x27;.&#x27;; &#125; if (mmap[i][j] &gt;= &#x27;a&#x27; &amp;&amp; mmap[i][j] &lt;= &#x27;f&#x27;) &#123; key_cnt++; &#125; &#125; &#125; end_status = bit2[key_cnt] - 1; while (!que.empty()) &#123; node temp = que.front(); que.pop(); if (temp.status == end_status) &#123; return temp.step; &#125; for (int i = 0; i &lt; 4; i++) &#123; int x = temp.x + dir[i][0]; int y = temp.y + dir[i][1]; if (x &lt; 0 || y &lt; 0 || x == n || y == m || check[x][y][temp.status] == 1) &#123; continue; &#125; if (mmap[x][y] == &#x27;.&#x27;) &#123; check[x][y][temp.status] = 1; que.push((node)&#123;x, y, temp.status, temp.step + 1&#125;); &#125; else if (mmap[x][y] &gt;= &#x27;a&#x27; &amp;&amp; mmap[x][y] &lt;= &#x27;f&#x27;) &#123; check[x][y][temp.status] = 1; check[x][y][temp.status | bit2[mmap[x][y] - &#x27;a&#x27;]] = 1; que.push((node)&#123;x, y, temp.status | bit2[mmap[x][y] - &#x27;a&#x27;], temp.step + 1&#125;); &#125; else if (mmap[x][y] &gt;= &#x27;A&#x27; &amp;&amp; mmap[x][y] &lt;= &#x27;F&#x27; &amp;&amp; (temp.status &amp; bit2[mmap[x][y] - &#x27;A&#x27;])) &#123; check[x][y][temp.status] = 1; que.push((node)&#123;x, y, temp.status, temp.step + 1&#125;); &#125; &#125; &#125; return -1; &#125;&#125;; Oj-539. 速算游戏 解题思路 代码1 ==LeetCode127==. 单词接龙解题思路 代码1","categories":[],"tags":[]},{"title":"基础数据结构","slug":"基础数据结构","date":"2021-03-09T07:13:28.765Z","updated":"2021-03-09T14:59:54.677Z","comments":true,"path":"2021/03/09/基础数据结构/","link":"","permalink":"http://example.com/2021/03/09/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"数据结构 = 结构定义+结构操作定义一种性质,并且维护这种性质的结构就叫数据结构. 常见的时间复杂度 realloc malloc 和 canlloc的区别 三个函数的申明分别是:void* realloc(void* ptr, unsigned newsize);void* malloc(unsigned size);void* calloc(size_t numElements, size_t sizeOfElement);都在stdlib.h函数库内 它们的返回值都是请求系统分配的地址,如果请求失败就返回NULL malloc用于申请一段新的地址,参数size为需要内存空间的长度,如:char* p;p=(char*)malloc(20); calloc与malloc相似,参数sizeOfElement为申请地址的单位元素长度,numElements为元素个数,如:char* p;p=(char*)calloc(20,sizeof(char));这个例子与上一个效果相同 realloc是给一个已经分配了地址的指针重新分配空间,参数ptr为原有的空间地址,newsize是重新申请的地址长度real realloc如果申请成功,会拷贝原数据的,并且进行清空 如:char* p;p=(char*)malloc(sizeof(char)20);p=(char)realloc(p,sizeof(char)*40); 注意，这里的空间长度都是以字节为单位。 C语言的标准内存分配函数：malloc，calloc，realloc，free等。malloc与calloc的区别为1块与n块的区别：malloc调用形式为(类型*)malloc(size)：在内存的动态存储区中分配一块长度为“size”字节的连续区域，返回该区域的首地址。calloc调用形式为(类型*)calloc(n，size)：在内存的动态存储区中分配n块长度为“size”字节的连续区域，返回首地址。realloc调用形式为(类型*)realloc(*ptr，size)：将ptr内存大小增大到size。 free的调用形式为free(void*ptr)：释放ptr所指向的一块内存空间。C++中为new/delete函数。 线性表基础顺序表的构造、插入、扩容首先我们要学习的是插入操作，如果顺序表是空的，我们需要往顺序表中插入元素后才能进行其它的操作。 顺序表插入操作需要实现的函数如下： 函数 功能 insert(loc, value) 将 value 插入到顺序表中下标为loc的位置 顺序表插入操作的实现方法如下： 判断插入位置是否合法。 判断顺序表是否已满。 将目标位置及之后的元素后移一位。 将待插入的元素值插入到目标位置。 在新元素要插入到顺序表中时，如果顺序表已经满了，我们就需要利用顺序表的扩容操作来为它开辟一块更大的内存空间。 顺序表扩容操作需要实现的函数如下： 函数 功能 expand() 扩大顺序表的容量 顺序表扩容操作的实现方法如下： 将原来的元素存储到临时存储空间。 扩大原来的存储空间。 将临时存储空间里的数据元素复制到新的存储空间里。 释放临时的存储空间。 ==需要先把内容复制到临时存储空间中，所以时间复杂度为O(n)== 扩容 每次扩容，都是将容量修改为之前的2倍； 扩容时，要重新开辟一块空间，并且将原有的数据拷贝进去，再讲原有的空间删除 12data = new Type[size]; //新开辟一个空间delete[] old_data; //删除原有的空间 malloc calloc 在堆区申请空间后并清空为0 realloc 重新申请空间，如果申请不到，会返回0，造成地址泄露 都返回新申请空间的首地址单元 链表 插入 1、找到链表中需要插入的位置 2、令待插入结点的next指针指向待插入位置 3、令插入位置之前的结点的next指针指向待插入结点 遍历 output() 输出整个链表 1、定义一个用于遍历的变量； 2、输入遍历变量所在结点的值，并且更新变量的值为下一个结点； 3、重复操作，直到遍历完所有节点 删除》。 链表的原地反转 原地头插法 O（1） 见代码reverse 如何实现双向链表 单向循环链表课后习题 双指针,快慢指针 双向链表 注意: null空节点无法添加前驱,所以删除以及插入的时候需要注意 插入时, 在0个节点处插入,前驱无法添加 所以当是空地址时,不需要添加前驱: 添加特判 队列 先进先出FIFO 需要一片连续的存储空间来当==队列==的容器 出队: 队首元素 head + 1 入队: tail + 1, tail后移一位,新的元素就插入在新的tail指针处 队列-假溢出 无法插入第10个元素,但实际上队列并没有满. 前面还有三个空位置 如何解决? 将tail指针移到队伍最前面 ​ 取模运算: (tail + 1 ) % length 循环队列 针对假溢出问题产生的新的队列 如何判断循环队列已经满?如何判空? ​ 增加额外字段count(因为tail不一定&gt;head) 队列的代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/************************************************************************* &gt; File Name: 4.queue.cpp &gt; Author: &gt; Mail: &gt; Created Time: Wed 17 Feb 2021 10:07:19 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Queue &#123; int *data;//一片连续的存储空间 int head, tail; int length;&#125; Queue;Queue *init(int n) &#123; Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;length = n; q-&gt;head = q-&gt;tail = 0; return q;&#125;int empty(Queue *q) &#123; return q-&gt;head == q-&gt;tail;//如果对手指针和队尾指针重合,即为空&#125;int front(Queue *q) &#123; return q-&gt;data[q-&gt;head];&#125;int push(Queue *q, int val) &#123; if (q == NULL) return 0; if (q-&gt;tail == q-&gt;length) return 0;//判断队列满 q-&gt;data[q-&gt;tail++] = val; //q-&gt;tail += 1; return 1;&#125;int pop(Queue *q) &#123; if (q == NULL) return 0; if (empty(q)) return 0; q-&gt;head += 1; return 1;&#125;void output(Queue *q) &#123; if (q == NULL) return ; printf(&quot;Queue : [&quot;); for (int i = q-&gt;head, j = 0; i &lt; q-&gt;tail; i++, j++) &#123; j &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, q-&gt;data[i]); &#125; printf(&quot;]\\n&quot;); return;&#125;void clear(Queue *q) &#123; if (q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 20 Queue *q = init(MAX_OP); for (int i = 0; i &lt; MAX_OP; i++) &#123; int op, val; op = rand() % 4; val = rand() % 100; switch (op) &#123; case 0: case 1: case 2: &#123; printf(&quot;push %d to the queue = %d\\n&quot;, val, push(q, val)); &#125; break; case 3: &#123; if (!empty(q)) &#123; printf(&quot;pop %d from the queue = &quot;, front(q)); printf(&quot;%d\\n&quot;, pop(q)); &#125; &#125; break; &#125; output(q), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(q); return 0;&#125; 循环队列的实现 上述2.中的代码会出现假溢出的问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/************************************************************************* &gt; File Name: 4.queue.cpp &gt; Author: &gt; Mail: &gt; Created Time: Wed 17 Feb 2021 10:07:19 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Queue &#123; int *data;//一片连续的存储空间 int head, tail, count; int length;&#125; Queue;Queue *init(int n) &#123; Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;length = n; q-&gt;head = q-&gt;tail = 0; q-&gt;count = 0; return q;&#125;int empty(Queue *q) &#123; return q-&gt;count == 0;//通过count判空&#125;int front(Queue *q) &#123; return q-&gt;data[q-&gt;head];&#125;int push(Queue *q, int val) &#123; if (q == NULL) return 0; if (q-&gt;count == q-&gt;length) return 0;//判断队列满 q-&gt;data[q-&gt;tail++] = val; if (q-&gt;tail == q-&gt;length) q-&gt;tail = 0;//实现循环 //q-&gt;tail += 1; q-&gt;count += 1; return 1;&#125;int pop(Queue *q) &#123; if (q == NULL) return 0; if (empty(q)) return 0; q-&gt;head += 1; if (q-&gt;head == q-&gt;length) q-&gt;head = 0; q-&gt;count -= 1; return 1;&#125;void output(Queue *q) &#123; if (q == NULL) return ; printf(&quot;Queue : [&quot;); for (int i = q-&gt;head, j = 0; j &lt; q-&gt;count; j++) &#123; j &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, q-&gt;data[(i+j) % q-&gt;length]); &#125; printf(&quot;]\\n&quot;); return;&#125;void clear(Queue *q) &#123; if (q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 20 Queue *q = init(MAX_OP); for (int i = 0; i &lt; MAX_OP; i++) &#123; int op, val; op = rand() % 4; val = rand() % 100; switch (op) &#123; case 0: case 1: case 2: &#123; printf(&quot;push %d to the queue = %d\\n&quot;, val, push(q, val)); &#125; break; case 3: &#123; if (!empty(q)) &#123; printf(&quot;pop %d from the queue = &quot;, front(q)); printf(&quot;%d\\n&quot;, pop(q)); &#125; &#125; break; &#125; output(q), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(q); return 0;&#125; 循环队列的扩容使用realloc扩容,会出现问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/************************************************************************* &gt; File Name: 4.queue.cpp &gt; Author: &gt; Mail: &gt; Created Time: Wed 17 Feb 2021 10:07:19 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define COLOR(a,b) &quot;\\033[&quot; #b &quot;m&quot; a &quot;\\033[0m&quot;#define GREEN(a) COLOR(a, 32)typedef struct Queue &#123; int *data;//一片连续的存储空间 int head, tail, count; int length;&#125; Queue;Queue *init(int n) &#123; Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;length = n; q-&gt;head = q-&gt;tail = 0; q-&gt;count = 0; return q;&#125;int empty(Queue *q) &#123; return q-&gt;count == 0;//通过count判空&#125;int front(Queue *q) &#123; return q-&gt;data[q-&gt;head];&#125;int expand(Queue *q) &#123; int extr_size = q-&gt;length;//等于原来的容量 int *temp;//临时记录扩容返回的地址 while (extr_size) &#123; temp = (int *)realloc(q-&gt;data, sizeof(int) * (q-&gt;length + extr_size)); if (temp) break; extr_size &gt;&gt;= 1;// 到了这一行,说明扩容失败, 除以2 适当降低要求 &#125; if (temp == NULL) return 0;//说明扩容失败 q-&gt;data = temp;//到这一行说明扩容成功 q-&gt;length += extr_size; printf(GREEN(&quot;expand successfully! the new size = %d\\n&quot;), q-&gt;length); return 1;&#125;int push(Queue *q, int val) &#123; if (q == NULL) return 0; if (q-&gt;count == q-&gt;length) &#123; if (!expand(q)) return 0; &#125;//判断队列满 q-&gt;data[q-&gt;tail++] = val; if (q-&gt;tail == q-&gt;length) q-&gt;tail = 0;//实现循环 //q-&gt;tail += 1; q-&gt;count += 1; return 1;&#125;int pop(Queue *q) &#123; if (q == NULL) return 0; if (empty(q)) return 0; q-&gt;head += 1; if (q-&gt;head == q-&gt;length) q-&gt;head = 0; q-&gt;count -= 1; return 1;&#125;void output(Queue *q) &#123; if (q == NULL) return ; printf(&quot;Queue : [&quot;); for (int i = q-&gt;head, j = 0; j &lt; q-&gt;count; j++) &#123; j &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, q-&gt;data[(i+j) % q-&gt;length]); &#125; printf(&quot;]\\n&quot;); return;&#125;void clear(Queue *q) &#123; if (q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 30 Queue *q = init(1); for (int i = 0; i &lt; MAX_OP; i++) &#123; int op, val; op = rand() % 4; val = rand() % 100; switch (op) &#123; case 0: case 1: case 2: &#123; printf(&quot;push %d to the queue = %d\\n&quot;, val, push(q, val)); &#125; break; case 3: &#123; if (!empty(q)) &#123; printf(&quot;pop %d from the queue = &quot;, front(q)); printf(&quot;%d\\n&quot;, pop(q)); &#125; &#125; break; &#125; output(q), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(q); return 0;&#125; 队列中间会出现很多0, realloc拷贝值的时候,会按照存储数据的值拷贝 所以循环队列有可能会出现问题 使用malloc进行扩容操作 需要手动进行值的拷贝 栈结构定义与结构操作 top 栈顶指针: 记录整个栈最上面元素的位置 出栈 : 栈顶指针向下走一步,指向新的元素 栈顶指针-1即可 栈可以解决==完全包含问题== 系统栈也是栈, 但是默认大小只有8Mb 练习题 oj 263 265 266 267 268 入栈: 栈顶指针top+1,然后将新元素插入到当前top指针的位置 代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/************************************************************************* &gt; File Name: 5.stack.cpp &gt; Author: &gt; Mail: &gt; Created Time: Mon 22 Feb 2021 04:48:35 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Stack &#123; int *data; int size, top;&#125; Stack;Stack *init_stack(int n) &#123; Stack *s = (Stack *)malloc(sizeof(Stack)); s-&gt;data = (int *)malloc(sizeof(int) * n); s-&gt;size = n; s-&gt;top = -1;//初始化时候,下标为-1,因为栈从0开始 return s;&#125;int empty(Stack *s) &#123; return s-&gt;top == -1;&#125;int expand(Stack *s) &#123; int extr_size = s-&gt;size; int *temp; /*while (extr_size) &#123; temp = (int *)malloc(sizeof(int) * (s-&gt;size + extr_size)); if (temp) break; extr_size&gt;&gt;=1; &#125; if (temp == NULL) return 0; for (int i = 0; i &lt; s-&gt;size; i++) &#123; temp[i] = s-&gt;data[i]; &#125; free(s-&gt;data); s-&gt;data = temp; s-&gt;size = s-&gt;size + extr_size; */ while (extr_size) &#123; temp = (int *)realloc(s-&gt;data, sizeof(int) * (s-&gt;size + extr_size)); if (temp) break; extr_size &gt;&gt;= 1; &#125; if (temp == NULL) return 0; s-&gt;data = temp;//别忘了更新新的数据地址 s-&gt;size += extr_size; printf(&quot;successfully expand. the new size is %d\\n&quot;, s-&gt;size); return 1;//最后也别忘了&#125;int top(Stack *s) &#123; return s-&gt;data[s-&gt;top];&#125;int push(Stack *s, int val) &#123; if (s == NULL) return 0; if (s-&gt;top == s-&gt;size - 1) &#123; if (!expand(s)) return 0;//只有扩容失败,才返回0; &#125; //s-&gt;top += 1; //s-&gt;data[s-&gt;top] = val; s-&gt;data[++(s-&gt;top)] = val; return 1;&#125;int pop(Stack *s) &#123; if (s == NULL) return 0; if (empty(s)) return 0;//栈为空,也无法出栈 s-&gt;top -= 1; return 1;&#125;void output(Stack *s) &#123; if (s == NULL) return ; printf(&quot;Stack : [&quot;); for (int i = 0; i &lt;= s-&gt;top; i++) &#123; i &amp;&amp; printf(&quot;,&quot;); printf(&quot;%d&quot;, s-&gt;data[i]); &#125; printf(&quot;]\\n&quot;);&#125;void clear(Stack *s) &#123; if (s == NULL) return ; free(s-&gt;data); free(s); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 40 Stack *s = init_stack(1); for (int i = 0; i &lt; MAX_OP; i++) &#123; int op, val; op = rand() % 4; val = rand() % 100; switch (op) &#123; case 0: case 1: case 2: &#123; printf(&quot;push %d to the stack = %d\\n&quot;, val, push(s, val)); &#125; break; case 3: &#123; printf(&quot;pop %d from the Stack = &quot;, top(s)); printf(&quot;%d\\n&quot;, pop(s)); &#125; break; &#125; output(s), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(s); return 0;&#125; 链栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/************************************************************************* &gt; File Name: 6.LinkStack.cpp &gt; Author: &gt; Mail: &gt; Created Time: Mon 22 Feb 2021 06:23:09 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct StackNode&#123; int data; struct StackNode *next;&#125; StackNode;typedef struct LinkStack &#123; StackNode *top; int length;&#125; LinkStack;void clear_node(StackNode *);StackNode *init_node(int val) &#123; StackNode *p = (StackNode *)malloc(sizeof(StackNode)); p-&gt;data = val; p-&gt;next = NULL; return p;&#125;LinkStack *init_stack() &#123; LinkStack *l = (LinkStack *)malloc(sizeof(LinkStack)); l-&gt;top = NULL; l-&gt;length = 0; return l;&#125;int empty(LinkStack *l) &#123; return l-&gt;top == NULL;&#125;int Stack_top(LinkStack *l) &#123; if (empty(l)) return -1; return l-&gt;top-&gt;data;&#125;int push(LinkStack *l, int val) &#123; if (l == NULL) return 0; StackNode *node = init_node(val); //l-&gt;top-&gt;next = node; node-&gt;next = l-&gt;top; l-&gt;top = node; l-&gt;length += 1; return 1;&#125;int pop(LinkStack *l) &#123; if (l == NULL) return 0; if (empty(l)) return 0; StackNode *p = l-&gt;top; l-&gt;top = p-&gt;next; clear_node(p); l-&gt;length -= 1; return 1;&#125;void output(LinkStack *l) &#123; if (l == NULL) return ; printf(&quot;LinkStack(%d) : [&quot;, l-&gt;length); for (StackNode *p = l-&gt;top; p; p = p-&gt;next) &#123; p != l-&gt;top &amp;&amp; printf(&quot;,&quot;);//当p不等于l-&gt;top时, printf(&quot;%d&quot;, p-&gt;data); &#125; printf(&quot;]\\n&quot;);&#125;void clear_node(StackNode *node) &#123; if (node == NULL) return ; free(node); return ;&#125;void clear(LinkStack *l) &#123; if (l == NULL) return ; StackNode *p = l-&gt;top, *q; while (p) &#123; q = p-&gt;next; clear_node(p); p = q; &#125; free(l); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 20 LinkStack *s = init_stack(); for (int i = 0; i &lt; MAX_OP; i++) &#123; int op, val; op = rand() % 4; val = rand() % 100; switch (op) &#123; case 0: case 1: case 2: &#123; printf(&quot;push %d to the LinkStack = %d\\n&quot;, val, push(s, val)); &#125; break; case 3: &#123; printf(&quot;pop %d from the LinkStack = &quot;, Stack_top(s)); printf(&quot;%d\\n&quot;, pop(s)); &#125; break; &#125; output(s), printf(&quot;\\n&quot;); &#125; #undef MAX_OP clear(s); return 0;&#125; 树树的含义：节点和边 全集是子节点的并集 树也可以解决具有完全包含关系的问题 树的遍历需要借助栈 树的结构定义 链表向树的转化：树比链表==多了==几个next指针 树的深度，高度和度 度：当前节点底下有几个子节点 ==二叉树==二叉树能将一个不确定的n叉树转化成二叉树的表现形式 如何将一个n叉树转化为二叉树？ ==“左孩子右兄弟”表示法== ![image-20210222225522151](https://cdn.jsdelivr.net/gh/lizimu1013/imgbed@main/C_learning/image-20210222225522151.pn g) n0 = n2 + 1; 二叉树-遍历 前序遍历：1–2-4-5–3-6 中序遍历：4-2-5–1–3-6 后序遍历：4-5-2–6-3–1 二叉树的中国表示与国际表示 完全二叉树 二叉树的==广义表== 作业 二叉排序树(二叉查找树) 对于任何一个根节点, 当前根节点的值要大于左子树的值,小于右子树的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/************************************************************************* &gt; File Name: 7.binary_tree.cpp &gt; Author: &gt; Mail: &gt; Created Time: Tue 23 Feb 2021 12:08:31 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Node &#123; int data; struct Node *lchild, *rchild;&#125; Node;typedef struct Tree &#123; Node *root; int length;&#125; Tree;Node *getNewNode(int val) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;data = val; p-&gt;lchild = p-&gt;rchild = NULL; return p;&#125;Tree *getNewTree() &#123; Tree *tree = (Tree *)malloc(sizeof(Tree)); tree-&gt;root = NULL; tree-&gt;length = 0; return tree;&#125;//插入完一个数后,返回根节点的地址Node *insert_node(Node *root, int val, int *flag) &#123; if (root == NULL) &#123; *flag = 1; return getNewNode(val); &#125; if (root-&gt;data == val) return root; if (root-&gt;data &gt; val) root-&gt;lchild = insert_node(root-&gt;lchild, val, flag); else root-&gt;rchild = insert_node(root-&gt;rchild, val, flag); return root;&#125;void insert(Tree *tree, int val) &#123; if (tree == NULL) return ; int flag = 0;//定义一个标记量, 因为并不是每次插入都能成功 tree-&gt;root = insert_node(tree-&gt;root, val, &amp;flag); tree-&gt;length += flag; return ;&#125;void pre_order_node(Node *root) &#123; if (root == NULL) return ; printf(&quot;%d &quot;, root-&gt;data); pre_order_node(root-&gt;lchild); pre_order_node(root-&gt;rchild); return ;&#125;void pre_order(Tree *tree) &#123; if (tree == NULL) return ; printf(&quot;pre_order : &quot;); pre_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;void in_order_node(Node *root) &#123; if (root == NULL) return ; in_order_node(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); in_order_node(root-&gt;rchild); return ;//中序遍历, 先遍历左子树&#125;void in_order(Tree *tree) &#123; if (tree == NULL) return ; printf(&quot;in_order : &quot;); in_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;void post_order_node(Node *root) &#123; if (root == NULL) return ; post_order_node(root-&gt;lchild); post_order_node(root-&gt;rchild); printf(&quot;%d &quot;, root-&gt;data); return ;//后序遍历&#125;void post_order(Tree *tree) &#123; if (tree == NULL) return ; printf(&quot;post_order : &quot;); post_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;void output_node(Node *root) &#123; if (root == NULL) return ; printf(&quot;%d&quot;, root-&gt;data); if (root-&gt;lchild == NULL &amp;&amp; root-&gt;rchild == NULL) return; printf(&quot;(&quot;); output_node(root-&gt;lchild); printf(&quot;,&quot;); output_node(root-&gt;rchild); printf(&quot;)&quot;); return ;&#125;void output(Tree *tree) &#123; if (tree == NULL) return ; printf(&quot;tree(%d) : &quot;, tree-&gt;length); output_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;void clear_node(Node *node) &#123; if (node == NULL) return ; clear_node(node-&gt;lchild); clear_node(node-&gt;rchild); free(node); return ;&#125;void clear(Tree *tree) &#123; if (tree == NULL) return ; clear_node(tree-&gt;root);//调用递归,沿着根节点向下回收 free(tree); return ;&#125;int main() &#123; srand(time(0)); Tree *tree = getNewTree(); #define MAX_OP 10 for (int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; insert(tree, val); output(tree);//以广义表的形式输出; &#125; pre_order(tree); in_order(tree); post_order(tree); #undef MAX_OP clear(tree); return 0;&#125; 对于排序二叉树而言,中序遍历是从小到大有序排列的 广义表转二叉树(利用栈) 遇到 ( , ＋1操作, 遇到 ) , -1操作 使用flag标记逗号 ​ 当遇到( , 将上一个点入栈 ​ 加下来如果不是,也不是括号,则将B封装成一个节点 ​ 当遇到, 标记一下, 下一个遇到的元素是上一个元素的右孩子 ​ 当遇到一个), 建立关系,弹出栈顶元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186/************************************************************************* &gt; File Name: 8.table_to_tree.cpp &gt; Author: &gt; Mail: &gt; Created Time: Tue 23 Feb 2021 04:55:07 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Node &#123; char data; struct Node *lchild, *rchild;&#125; Node;typedef struct Tree &#123; Node *root; int length;&#125; Tree;typedef struct Stack &#123; Node **data;//栈中存放的是node *(地址); int top, size;&#125; Stack;Node *getNewNode(char val) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;data = val; p-&gt;lchild = p-&gt;rchild = NULL; return p;&#125;Tree *getNewTree() &#123; Tree *tree = (Tree *)malloc(sizeof(Tree)); tree-&gt;root = NULL; tree-&gt;length = 0; return tree;&#125;Stack *init_stack(int n) &#123; Stack *s = (Stack *)malloc(sizeof(Stack)); s-&gt;data = (Node **)malloc(sizeof(Node *) * n); s-&gt;top = -1; s-&gt;size = n; return s;&#125;Node *top(Stack *s) &#123; return s-&gt;data[s-&gt;top];&#125;int empty(Stack *s) &#123; return s-&gt;top == -1;&#125;int push(Stack *s, Node *val) &#123; if (s == NULL) return 0; if (s-&gt;top == s-&gt;size - 1) return 0; s-&gt;data[++(s-&gt;top)] = val; return 1;&#125;int pop(Stack *s) &#123; if (s == NULL) return 0; if (empty(s)) return 0; s-&gt;top -= 1; return 1;&#125;void clear_stack(Stack *s) &#123; if (s == NULL) return ; free(s-&gt;data); free(s); return ;&#125;void clear_node(Node *root) &#123; if (root == NULL) return ; clear_node(root-&gt;lchild); clear_node(root-&gt;rchild); free(root); return ;&#125;void clear_tree(Tree *tree) &#123; if (tree == NULL) return ; clear_node(tree-&gt;root); free(tree); return ;&#125;void pre_order_node(Node *root) &#123; if (root == NULL) return ; printf(&quot;%c &quot;, root-&gt;data); pre_order_node(root-&gt;lchild); pre_order_node(root-&gt;rchild); return ;&#125;void pre_order(Tree *tree) &#123; if (tree == NULL) return ; printf(&quot;pre_order(%d) : &quot;, tree-&gt;length); pre_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;void in_order_node(Node *root) &#123; if (root == NULL) return ; in_order_node(root-&gt;lchild); printf(&quot;%c &quot;, root-&gt;data); in_order_node(root-&gt;rchild); return ;&#125;void in_order(Tree *tree) &#123; if (tree == NULL) return ; printf(&quot;in_order(%d) : &quot;, tree-&gt;length); in_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;void post_order_node(Node *root) &#123; if (root == NULL) return ; post_order_node(root-&gt;lchild); post_order_node(root-&gt;rchild); printf(&quot;%c &quot;, root-&gt;data); return ;&#125;void post_order(Tree *tree) &#123; if (tree == NULL) return ; printf(&quot;post_order(%d) : &quot;, tree-&gt;length); post_order_node(tree-&gt;root); printf(&quot;\\n&quot;); return ;&#125;Node *build(const char *str, int *node_num) &#123; Stack *s = init_stack(strlen(str)); int flag = 0; Node *temp = NULL, *p = NULL; while (str[0]) &#123; switch (str[0]) &#123; case &#x27;(&#x27;: &#123; push(s, temp); flag = 0; &#125; break; case &#x27;)&#x27;: &#123; p = top(s); pop(s); &#125; break; case &#x27;,&#x27;: &#123; flag = 1; &#125; break; case &#x27; &#x27;: break; default://说明遇到需要构建节点的元素 temp = getNewNode(str[0]); if (!empty(s) &amp;&amp; flag == 0) &#123; top(s)-&gt;lchild = temp; &#125; else if (!empty(s) &amp;&amp; flag == 1) &#123; top(s)-&gt;rchild = temp; &#125; ++(*node_num); break; &#125; ++str; &#125; clear_stack(s); if (temp &amp;&amp; !p) p = temp;//如果temp不为空,并且p为空//即只有一个元素的广义表 return p;&#125;int main() &#123; char str[1000] = &#123;0&#125;; int node_num = 0; scanf(&quot;%[^\\n]s&quot;, str); getchar(); Tree *tree = getNewTree(); tree-&gt;root = build(str, &amp;node_num);//将node_num作为传出参数; tree-&gt;length = node_num; pre_order(tree); in_order(tree); post_order(tree); return 0;&#125; 排序与查找稳定排序: 插入 冒泡 归并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/************************************************************************* &gt; File Name: 9.stable_sort.cpp &gt; Author: &gt; Mail: &gt; Created Time: Tue 23 Feb 2021 09:46:01 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;#define TEST(arr, n, func, args...) &#123;\\ int *num = (int *)malloc(sizeof(int) * n);\\ memcpy(num, arr, sizeof(int) * n);\\ output(num, n);\\ printf(&quot;%s= &quot;, #func);\\ func(args);\\ output(num, n);\\ free(num);\\&#125;//插入排序void insert_sort(int *num, int n) &#123; for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; num[j] &lt; num[j - 1]; j--) &#123; swap(num[j], num[j - 1]); &#125; &#125;&#125;void bubble_sort(int *num, int n) &#123; int times = 1;//用times来进行优化 for (int i = 1; i &lt; n &amp;&amp; times; i++) &#123; times = 0; for (int j = 0; j &lt; n - i; j++) &#123; /* if (num[j] &gt; num[j + 1]) &#123; swap(num[j], num[j + 1]); &#125;减少缩进,增加代码可读性*/ if (num[j] &lt;= num[j + 1]) continue; swap(num[j], num[j + 1]); times++; &#125; &#125; return ;&#125;//用递归实现分治递归void merge_sort(int *num, int l, int r) &#123; //从l到r这个位置进行归并排序 if (r - l &lt;= 1) &#123; //即当前区间内存在两个以内的元素,可以排序 if (r - l == 1 &amp;&amp; num[r] &lt; num[l]) &#123; //说明区间就两个元素,并且后面比前面小 swap(num[r], num[l]); &#125; return ; &#125; //开始二路归并 nlogn int mid = (l + r) &gt;&gt; 1; merge_sort(num, l, mid); merge_sort(num, mid + 1, r); //mid左右两边已经是有序的了 //开始复制到temp数组里面 int *temp = (int *)malloc(sizeof(int) * (r - l + 1)); int p1 = l, p2 = mid + 1, k = 0; while (p1 &lt;= mid || p2 &lt;= r) &#123; //说明左右两端数组至少有一个是还有元素的 if (p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) &#123; temp[k++] = num[p1++];//说明p1的值小一点 &#125; else &#123; temp[k++] = num[p2++]; &#125; &#125; //进行拷贝操作,将temp拷贝到num+l位置下 memcpy(num + l, temp, sizeof(int) * (r - l + 1)); free(temp); return ;&#125;void randint(int *arr, int n) &#123; while (n--) arr[n] = rand() % 100; return ;&#125;void output(int *arr, int n) &#123; printf(&quot;[&quot;); for (int i = 0; i &lt; n; i++) &#123; i &amp;&amp; printf(&quot; &quot;); printf(&quot;%d&quot;, arr[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int main() &#123; srand(time(0)); #define MAX_N 20 int arr[MAX_N]; randint(arr, MAX_N); TEST(arr, MAX_N, insert_sort, num, MAX_N); TEST(arr, MAX_N, bubble_sort, num, MAX_N); TEST(arr, MAX_N, merge_sort, num, 0, MAX_N - 1); #undef MAX_N return 0;&#125; 插入排序 时间复杂度: O(n^2^) 冒泡排序 时间复杂度: O(n^2^) 减少缩进,增加代码可读性 归并排序 核心思想：分治时间复杂度：nlogn m1+m2+n1+n2 = m + n = k; 一共有logk层 两个指针p1和p2, 谁小谁就先拷贝到原队列中, 然后指针++ 每一层都操作了k个元素, 一共有logk层, 所以时间复杂度为 O(nlogn) 可以采用递归 归并排序是外部排序: 假如有8G的数据,但是内存只有2G,这时候可以利用归并排序,将数据分为4份, 分别是2G, 最后再分别进行拷贝 ………………………………………..不稳定排序: 选择 快速排序 内部排序: 需要将待排序一次性加载到内存中 外部排序: 与内部排序相反(归并排序) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/************************************************************************* &gt; File Name: 10.unstable_sort.cpp &gt; Author: &gt; Mail: &gt; Created Time: Wed 24 Feb 2021 02:44:43 PM CST ************************************************************************/#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;#define TEST(arr, n, func, args...) &#123;\\ int *num = (int *)malloc(sizeof(int) * n);\\ memcpy(num, arr, sizeof(int) * n);\\ output(num, n);\\ printf(&quot;%s= &quot;, #func);\\ func(args);\\ output(num, n);\\ free(num);\\&#125;void select_sort(int *num, int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; int ind = i; for (int j = i + 1; j &lt; n; j++) &#123; if (num[ind] &gt; num[j]) ind = j; &#125; swap(num[i], num[ind]); &#125; return ;&#125;/*void quick_sort(int *num, int l, int r) &#123; //对于num数组.从l到r之间的元素进行排序 if (l &gt; r) return ;//递归的边界条件 int x = l, y = r, z = num[x];//z为基准值 while (x &lt; y) &#123; while (x &lt; y &amp;&amp; num[y] &gt; z) y--;//找到第一个小于基准值的值 if (x &lt; y) num[x++] = num[y]; while (x &lt; y &amp;&amp; num[x] &lt; z) x++; if (x &lt; y) num[y--] = num[x]; &#125; num[x] = z;//此时头尾指针重合,放置基准值 quick_sort(num, l, x - 1);//分别从l到基准值再分别进行快速排序 quick_sort(num, x + 1, r); return ;&#125;*///用单边递归对快排进行优化void quick_sort(int *num, int l, int r) &#123; while (l &lt; r) &#123; int x = l, y = r, z = num[(l + r) &gt;&gt; 1];//基准值可以使用任何一个值 do &#123; while (num[x] &lt; z) x++; while (num[y] &gt; z) y--; if (x &lt;= y) &#123; swap(num[x], num[y]); x++, y--; &#125; &#125; while (x &lt;= y); quick_sort(num, l, y);//对左侧快排 单边递归 l = x;//右侧循环 &#125;//单边递归进行优化 return ;&#125;void randint(int *arr, int n) &#123; while (n--) arr[n] = rand() % 100; return ;&#125;void output(int *arr, int n) &#123; printf(&quot;[&quot;); for (int i = 0; i &lt; n; i++) &#123; i &amp;&amp; printf(&quot; &quot;); printf(&quot;%d&quot;, arr[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int main() &#123; srand(time(0)); #define MAX_N 20 int arr[MAX_N]; randint(arr, MAX_N); TEST(arr, MAX_N, select_sort, num, MAX_N); TEST(arr, MAX_N, quick_sort, num, 0,MAX_N - 1); #undef MAX_N return 0;&#125; 选择排序 第一次交换: 3 与 10 进行交换 交换之后, 已排序区元素数 + 1, 待排序区元素数 - 1; 选择/冒泡/插入排序的时间复杂度都是O(n^2^); 选择排序更节省一点时间, 因为每一轮交换的次数只有一次 快速排序 时间复杂度 O(nlogn) 但很有可能退化成O(n^2^); 以待排序区间的第一个值作为基准值 先去移动尾指针, 从后往前找, 找到第一个&lt;=基准值的值, 进行一次partition排序后, 数据会基本有序: 基准值前面的值都&lt;=基准值, 基准值后面的值都&gt;= 基准值 对快排进行优化, 无监督的快排 单边递归 基准值的优化, 可以使用任意值 有监督 &gt; 无监督 取消监督是否x&lt;y : while改成do while 查找算法与哈希表二分查找与三分查找 二分查找 时间复杂度 O(logn) 二分查找的特殊情况 111111111000000000000000找最后一个1 12345678while(L ! = R) &#123; int mid = (L + R + 1) / 2;//避免死循环 if (n[mid] == 1) &#123; L = mid; &#125; else &#123; R = mid - 1; &#125;&#125; 000000000001111111找第一个1 12345678while (L != R) &#123; int mid = (L + R) / 2; if (n[mid] == 0) &#123; L = mid + 1; &#125; else &#123; R = mid; &#125;&#125; 如果全是00000000000, 可以设置一个虚拟位 -1 这样最后l和r都会指向-1 二分查找的代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/************************************************************************* &gt; File Name: 11.binary_search.cpp &gt; Author: &gt; Mail: &gt; Created Time: Wed 24 Feb 2021 05:22:26 PM CST ************************************************************************/#include &lt;stdio.h&gt;#define P(func) &#123;\\ printf(&quot;%s = %d\\n&quot;, #func, func);\\&#125;int binary_search(int *arr, int n, int x) &#123; int head = 0, tail = n - 1, mid; while (head &lt;= tail) &#123; mid = (head + tail) &gt;&gt; 1; if (arr[mid] == x) return mid; if (arr[mid] &lt; x) head = mid + 1; else tail = mid - 1; &#125; return -1;&#125;//111110000000int binary_search1(int *arr, int n, int x) &#123; int head = -1, tail = n - 1, mid;//head指向虚拟位 while (head &lt; tail) &#123; mid = (head + tail + 1) &gt;&gt; 1; if (arr[mid] == x) head = mid; else tail = mid - 1; &#125; return head == -1 ? -1 : head;&#125;//000000001111int binary_search2(int *arr, int n, int x) &#123; int head = 0, tail = n, mid;//tail指向虚拟位 while (head &lt; tail) &#123; mid = (head + tail) &gt;&gt; 1; if (arr[mid] == x) tail = mid; else head = mid + 1; &#125; return head == n ? -1 :head;&#125;int main() &#123; int arr1[10] = &#123;1, 3, 5, 7, 9, 11, 13, 17, 19, 21&#125;; int arr2[10] = &#123;1, 1, 1, 1, 0, 0, 0, 0, 0, 0&#125;; int arr3[10] = &#123;0, 0, 0, 0, 1, 1, 1, 1, 1, 1&#125;; P(binary_search(arr1, 10, 7)); P(binary_search1(arr2, 10, 1)); P(binary_search2(arr3, 10, 1)); return 0;&#125; 三分查找 解决凹凸函数的极值点的问题 ………………………………………..哈希表 数组: 的下标一定是一个整型值, 通过下标访问的内容可以是任意类型.(整形到任意类型的映射) O(1) 哈希表(哈希结构) : ==哈希函数==: 将任意类型映射成一个整型值, 这样就可以通过数组的方式进行存储与访问 ==冲突处理==: 解决映射时候产生的冲突问题, 哈希结构中的冲突不可避免, 只要是哈希结构就一定会产生冲突 拉链法: 建立一个链表 开放定值法: 7的位置冲突, 往后找有没有空着的位置, 找到位置8(效率低) 二次探测法 再哈希法: 如果冲突 使用第二个哈希函数 建立公共溢出区 将16存入位置7, 此时如果再存入7, 会产生冲突, 此时采用开放定值法, 将7存入位置8 查找时, 先看查找到的值是不是需要的值, 如果不是, 说明之前是冲突的, 根据相应的冲突处理探测下一个位置是否是需要的值 代码演示 哈希函数 : BKDR 冲突处理: 拉链法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/************************************************************************* &gt; File Name: 12.hash_table.cpp &gt; Author: &gt; Mail: &gt; Created Time: Thu 25 Feb 2021 03:00:06 PM CST//字符串的哈希结构************************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;typedef struct Node &#123; char *str; struct Node *next;&#125; Node;typedef struct HashTable &#123; Node **data;//数据区存入的是Node * int size;&#125; HashTable;Node *init_node(char *str, Node *head) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;str = strdup(str);//原封拷贝一份str, 并将地址传给节点的str //当用完开辟之后的str后, 会自动释放 p-&gt;next = head;//采用头插法 return p;&#125; //初始化链表节点HashTable *init_hashtable(int n) &#123; HashTable *h = (HashTable *)malloc(sizeof(HashTable)); h-&gt;size = (n &lt;&lt; 1);//初始化hash表的size容量 利用率50% h-&gt;data = (Node **)calloc(h-&gt;size, sizeof(Node *));//hash表的每一个元素是链表第一个节点的首地址 return h;&#125;int BKDRHash(char *str) &#123; int seed = 31, hash = 0; for (int i = 0; str[i]; i++) hash = hash * seed + str[i]; return hash &amp; 0x7fffffff;//将有可能为负数的hash映射成正数&#125;int insert(HashTable *h, char *str) &#123; int hash = BKDRHash(str); int ind = hash % h-&gt;size;//原hash区间是整个整形 h-&gt;data[ind] = init_node(str, h-&gt;data[ind]);//封装成链表的节点 return 1;&#125;int search(HashTable *h, char *str) &#123; int hash = BKDRHash(str); int ind = hash % h-&gt;size; Node *p = h-&gt;data[ind];//ind位置上第一个链表节点的位置 while (p &amp;&amp; strcmp(p-&gt;str, str)) p = p-&gt;next; return p != NULL;&#125;void clear_node(Node *node) &#123; if (node == NULL) return ; Node *p = node, *q; while (p) &#123; q = p-&gt;next; free(p-&gt;str);//和strdup配合使用 free(p); p = q; &#125; return ;&#125;void clear(HashTable *h) &#123; if (h == NULL) return ; for (int i = 0; i &lt; h-&gt;size; i++) &#123; clear_node(h-&gt;data[i]); &#125; free(h-&gt;data); free(h); return ;&#125;int main() &#123; int op; #define MAX_N 100 char str[MAX_N + 5] = &#123;0&#125;; HashTable *h = init_hashtable(MAX_N); while (~scanf(&quot;%d%s&quot;, &amp;op, str)) &#123; switch (op) &#123; case 0: printf(&quot;insert %s to HashTable\\n&quot;, str); insert(h, str); break; case 1: printf(&quot;search %s from the HashTable result = %d\\n&quot;, str, search(h, str)); break; &#125; &#125; #undef MAX_N clear(h); return 0;&#125; 课后习题 堆与优先队列(本质都是一种结构)完全二叉树 用一个数组存储完全二叉树 堆 数据结构的本质: 定义一种性质, 并且维护这种性质的结构 堆的本质 : 完全二叉树 堆不等同于二叉排序树 大顶堆 : 根节点的值大于左右两个子节点的值 小顶堆 : 根节点的值永远比左右孩子小 堆的插入-尾部插入调整 O(logN) 插入结束之后, 需要进行调整, 维护 堆 的性质 从堆尾, 自下向上进行调整 13插入后, 13 比 根节点 大, 但因为这是大顶堆, 所以需要进行调整 13 和 7 进行交换 13 和 11 进行交换 13 在和 12 进行交换, 作为堆的根节点 数组插入并调整的时间复杂度 O(N) 堆的插入并调整时间复杂度O(logN) N个元素, 那就是Nlog(N) 堆的删除-头部弹出调整 二叉树的根节点弹出后就没了, 需要重新选择一个新的根节点 从堆的最后一个位置拿一个值, 当做堆顶元素 需要维护堆的平衡 : 从堆顶向下进行调整 7的右孩子11大于7本身, 所以进行互换 堆排序 O(NlogN) 与 优先队列 堆顶元素肯定为最大值 / 最小值 头部弹出之后, 经过调整, 新的堆顶元素仍然是最大值 将堆顶元素与堆尾元素交换(数组的头元素放到数组最后) 堆的length - 1, 对于剩下的元素用堆的平衡进行调整, 这是堆顶元素为剩下元素的最大值 重复操作 经过n-1轮 从小到大排序 : 大顶堆 从大到小排序 : 小顶堆 为什么又叫优先队列? 删除: 从堆顶弹出 ; 插入: 从堆尾插入 性质类似于队列queue 而且每次从头部弹出的元素, 肯定是最大值 / 最小值(优先) 所以堆的实现可以利用二叉树 或者 队列 课后习题 大顶堆 / 优先队列 的代码演示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/************************************************************************* &gt; File Name: 13.priority_queue.cpp &gt; Author: &gt; Mail: &gt; Created Time: Thu 25 Feb 2021 08:17:53 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;typedef struct priority_queue &#123; int *data; int cnt, size;&#125; priority_queue;//实现大顶堆priority_queue *init(int n) &#123; priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue)); q-&gt;data = (int *)malloc(sizeof(int) * (n + 1));//根节点编号为1,0号空着, 才能有某些性质 q-&gt;cnt = 0; q-&gt;size = n; return q;&#125;int empty(priority_queue *q) &#123; return q-&gt;cnt == 0;&#125;int top(priority_queue *q) &#123; return q-&gt;data[1];&#125;int push(priority_queue *q, int val) &#123; if (q == NULL) return 0; if (q-&gt;cnt == q-&gt;size) return 0; //q-&gt;cnt += 1; q-&gt;data[++(q-&gt;cnt)] = val; int ind = q-&gt;cnt;//当任意一个三元组不发生调整, 则已经平衡 while (ind &gt;&gt; 1 &amp;&amp; q-&gt;data[ind] &gt; q-&gt;data[ind &gt;&gt; 1]) &#123;//ind&gt;&gt;1除2即为ind的根节点 swap(q-&gt;data[ind], q-&gt;data[ind &gt;&gt; 1]); ind &gt;&gt;= 1; &#125; return 1;&#125; int pop(priority_queue *q) &#123; if (q == NULL) return 0; if (empty(q)) return 0; q-&gt;data[1] = q-&gt;data[q-&gt;cnt];//覆盖原来的堆顶元素 q-&gt;cnt -= 1;//下面开始自上向下进行调整 int ind = 1; while ((ind &lt;&lt; 1) &lt;= q-&gt;cnt) &#123; int temp = ind, l = ind &lt;&lt; 1, r = ind &lt;&lt; 1 | 1;//按位或, 在最后一位加上1 if (q-&gt;data[l] &gt; q-&gt;data[temp]) temp = l; if (r &lt;= q-&gt;cnt &amp;&amp; q-&gt;data[r] &gt; q-&gt;data[temp]) temp = r; if (temp == ind) break; swap(q-&gt;data[ind], q-&gt;data[temp]); ind = temp; &#125;//当堆还有元素时 return 1;&#125;void clear(priority_queue *q) &#123; if (q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;int main() &#123; srand(time(0)); #define MAX_OP 20 priority_queue *q = init(MAX_OP); for (int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; push(q, val); printf(&quot;insert %d to the priority_queue!\\n&quot;, val); &#125; for (int i = 0; i &lt; MAX_OP; i++) &#123; printf(&quot;%d &quot;, top(q)); pop(q); &#125; printf(&quot;\\n&quot;); #undef MAX_OP clear(q); return 0;&#125; 线性建堆 法 O(N) 可求得 假如有n层堆, 那在建立过程中总的调整次数为上面划横线的地方 度为0的节点个数 : 2^n^个 度为2的节点个数 : 2^n^ - 1个 叶子节点(最后一行节点)占了总结点数的一半还多一个 可以利用n*2^n^的值对整个调整的次数进行估算 全部节点个数N ≈ 2 * 2^n^ ; &gt; 算出n=logN / 2 代入 n * 2^n^ ; 总调整次数(NlogN-1) / 2 线性建堆法 每个节点调整的次数 (错位相减法) 总的节点的最多调整次数为 2^n+2^-2n-4 自上向下调整 最后一层节点个数 2^n+1^ 总节点 : N≈ 2^n+2^ ; 所以N≈ 2^n+2^个节点调整次数为2^n+2^-2n-4 O(N)级别的调整时间复杂度 自下向上调整法 堆排序 O(NlogN) 大顶堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/************************************************************************* &gt; File Name: 14.heap_sort.cpp &gt; Author: &gt; Mail: &gt; Created Time: Sun 28 Feb 2021 04:50:35 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;void downUpdata(int *arr, int n, int ind) &#123; while ((ind &lt;&lt; 1) &lt;= n) &#123; int temp = ind, l = ind &lt;&lt; 1, r = ind &lt;&lt; 1 | 1; if (arr[l] &gt; arr[temp]) temp = l; if (r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) temp = r; if (temp == ind) break; swap(arr[ind], arr[temp]); ind = temp; &#125; return ;&#125;void heap_sort(int *arr, int n) &#123; arr -= 1;//堆顶元素从1开始存 (arr[1]中存堆顶元素) arr[0]访问到的地址现在需要arr[1]进行访问 //从倒数第二层, 自上向下进行调整 for (int i = n &gt;&gt; 1; i &gt;= 1; i--) &#123; downUpdata(arr, n, i);//删除元素也是向下进行调整, 从第i层开始调整 &#125; for (int i = n; i &gt; 1; i--) &#123; swap(arr[i], arr[1]);//堆尾与堆顶元素交换 downUpdata(arr, i - 1, 1); &#125; return ;&#125;void output(int *arr, int n) &#123; printf(&quot;[&quot;); for (int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int main() &#123; srand(time(0)); #define MAX_N 20 int *arr = (int *)malloc(sizeof(int) * (MAX_N + 1)); for (int i = 0; i &lt; MAX_N; i++) &#123; arr[i] = rand() % 100; &#125; output(arr, MAX_N); heap_sort(arr, MAX_N); output(arr, MAX_N); free(arr); #undef MAX_N return 0;&#125; 森林与并查集连通性问题 即使不主动将8和9连同, 8和9就已经是联通关系了 集就是集合 判断两个数是否在一个集合中 森林与并查集本质是相同的 quick-find判断是否连通,直接看颜色是否一样 并查集: 将两个集合合并, 并且判断两个元素是否在同一个集合中 一棵树的根节点就是这棵树的全集 quick-find算法 合并操作的时间复杂度 : O(n) 连通判断 / 查找 的时间复杂度 : O(1) ==合并操作== : 借助数组 先将数组每个元素都存成自己的数 将前面的元素的颜色 改成 后面的一个元素的颜色(实际中无所谓), 将4号的颜色改成3号的颜色 将所有颜色标记为3的颜色都改成8这个元素的颜色 每次合并, 都要遍历一遍数组 quick-find算法的优缺点 : quick-union算法(快速合并) 核心思路 : 找代表元素 最开始每个元素的代表元素都是自己 4号元素与8号连通 : 4号元素所在集合的代表元素与8号元素所在集合的代表元素进行连通 默认还是将前面的集合改成后面的集合 随堂小练习 quick-union中, 最后一步, 1 和 5 连接 : 1的代表元素是2, 不是本身; 2的代表元素是4, 4的代表元素还是4, 是本身; 所以将 4 的代表元素改成5 quick-union算法总结 连通 与 合并 的最坏情况都为 O(n) 即当退化成为了一个链表的情况下 优化后 两个操作的时间复杂度 都为O(logN) , 即最好的情况 前面的元素成为后面的元素的一个子节点 ==为什么会产生 退化 ?== 见上面的问题思考; ==如何解决退化?== 按照节点数量和树的高度都能解决退化问题, 将时间复杂度稳定在logN, 但是按照==树的节点数==进行合并效率更高. 与==树高==没有关系理由见下 假设有两棵树, EAB以A树作为子树, 相当于A挂在B树的下面, 那么B树所有的节点查找次数都会多一次, 增量是LA (下图第一个蓝框应该是LA) EAB表示以平均查找次数, LA表示A树的所有查找次数, A表示A的所有节点个数 AB哪个数节点少, 就作为子树, 那么平均查找次数会少一点 weighted-quick-union算法 根据上述的分析, 基于quick-union算法的优化 按秩合并 : 谁的根节点多, 谁就当做根节点 合并与查找的时间复杂度都为O(logN) 随堂练习2 weighted-quick-union-with-path-compression路径压缩 weighted-quck-union 趋于扁平化 可以继续进行优化==(路径压缩)==. 0号节点鹤立鸡群; 0号节点的代表元素是1还是0无所谓. 所以可以将0号节点直接挂在3号节点下面 合并与查找的时间复杂度都趋于O(1) 总结 leetcode习题 代码演示quick-find……..656ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/************************************************************************* &gt; File Name: 15.quick_find.cpp 搭配海贼oj-71 &gt; Author: &gt; Mail: &gt; Created Time: Thu 04 Mar 2021 01:28:38 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct UnionSet&#123; int *color; int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;color = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for (int i = 1; i &lt;= n; i++) &#123; u-&gt;color[i] = i; &#125; return u;&#125;int find(UnionSet *u, int x) &#123; return u-&gt;color[x];&#125;int merge(UnionSet *u, int a, int b) &#123; if (find(u, a) == find(u, b)) return 0; int color_a = u-&gt;color[a]; for (int i = 1; i &lt;= u-&gt;n; i++) &#123; if (u-&gt;color[i] - color_a) continue;// (u-&gt;color[i] != color_A) u-&gt;color[i] = u-&gt;color[b]; &#125; return 1;&#125;void clear(UnionSet *u) &#123; if (u == NULL) return ; free(u-&gt;color); free(u); return ;&#125;int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); UnionSet *u = init(n); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); switch (a) &#123; case 1: merge(u, b, c); break; case 2: printf(&quot;%s\\n&quot;, find(u, b) == find(u, c) ? &quot;Yes&quot; : &quot;No&quot;); break; &#125; &#125; clear(u); return 0;&#125; quick-union……….1916ms1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/************************************************************************* &gt; File Name: 16.quick_union.cpp &gt; Author: &gt; Mail: &gt; Created Time: Thu 04 Mar 2021 01:28:38 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct UnionSet&#123; int *father; int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;father = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for (int i = 1; i &lt;= n; i++) &#123; u-&gt;father[i] = i; &#125; return u;&#125;int find(UnionSet *u, int x) &#123; if (u-&gt;father[x] == x) return x; return find(u, u-&gt;father[x]);&#125;int merge(UnionSet *u, int a, int b) &#123; int fa = find(u, a), fb = find(u, b);//找到a,b的代表元素 if (fa == fb) return 0; u-&gt;father[fa] = fb; return 1;&#125;void clear(UnionSet *u) &#123; if (u == NULL) return ; free(u-&gt;father); free(u); return ;&#125;int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); UnionSet *u = init(n); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); switch (a) &#123; case 1: merge(u, b, c); break; case 2: printf(&quot;%s\\n&quot;, find(u, b) == find(u, c) ? &quot;Yes&quot; : &quot;No&quot;); break; &#125; &#125; clear(u); return 0;&#125; 时间长, 说明产生了退化 weighted-quick-union………..132ms12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/************************************************************************* &gt; File Name: 16.quick_union.cpp &gt; Author: &gt; Mail: &gt; Created Time: Thu 04 Mar 2021 01:28:38 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;typedef struct UnionSet&#123; int *father; int *size;//利用size进行按秩合并 int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;father = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;size = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for (int i = 1; i &lt;= n; i++) &#123; u-&gt;father[i] = i; u-&gt;size[i] = 1; &#125; return u;&#125;int find(UnionSet *u, int x) &#123; if (u-&gt;father[x] == x) return x; return find(u, u-&gt;father[x]);&#125;int merge(UnionSet *u, int a, int b) &#123; int fa = find(u, a), fb = find(u, b);//找到a,b的代表元素 if (fa == fb) return 0; if (u-&gt;size[fa] &lt; u-&gt;size[fb]) swap(fa, fb);//fa永远记录节点个数最大的值 u-&gt;father[fb] = fa;//fb当做fa的子树 u-&gt;size[fa] += u-&gt;size[fb]; return 1;&#125;void clear(UnionSet *u) &#123; if (u == NULL) return ; free(u-&gt;father); free(u-&gt;size); free(u); return ;&#125;int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); UnionSet *u = init(n); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); switch (a) &#123; case 1: merge(u, b, c); break; case 2: printf(&quot;%s\\n&quot;, find(u, b) == find(u, c) ? &quot;Yes&quot; : &quot;No&quot;); break; &#125; &#125; clear(u); return 0;&#125; 路径压缩 只需要这样改 实际中, 可以上来就进行路径压缩操作, 不需要按秩合并优化; 时间差不多, 但节约一半的空间大小12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/************************************************************************* &gt; File Name: 17.quick_union_直接进行路径压缩.cpp &gt; Author: &gt; Mail: &gt; Created Time: Thu 04 Mar 2021 01:28:38 PM CST ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;typedef struct UnionSet&#123; int *father; //int *size; int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;father = (int *)malloc(sizeof(int) * (n + 1)); //u-&gt;size = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for (int i = 1; i &lt;= n; i++) &#123; u-&gt;father[i] = i; //u-&gt;size[i] = 1; &#125; return u;&#125;int find(UnionSet *u, int x) &#123; return u-&gt;father[x] = (u-&gt;father[x] == x ? x : find(u, u-&gt;father[x]));//代码合并 /*if (u-&gt;father[x] == x) return x; //return find(u, u-&gt;father[x]); return u-&gt;father[x] = find(u, u-&gt;father[x]);//路径压缩*/&#125;int merge(UnionSet *u, int a, int b) &#123; int fa = find(u, a), fb = find(u, b);//找到a,b的代表元素 if (fa == fb) return 0; //if (u-&gt;size[fa] &lt; u-&gt;size[fb]) swap(fa, fb);//fa永远记录节点个数最大的值 u-&gt;father[fb] = fa;//fb当做fa的子树 //u-&gt;size[fa] += u-&gt;size[fb]; return 1;&#125;void clear(UnionSet *u) &#123; if (u == NULL) return ; free(u-&gt;father); //free(u-&gt;size); free(u); return ;&#125;int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); UnionSet *u = init(n); for (int i = 0; i &lt; m; i++) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); switch (a) &#123; case 1: merge(u, b, c); break; case 2: printf(&quot;%s\\n&quot;, find(u, b) == find(u, c) ? &quot;Yes&quot; : &quot;No&quot;); break; &#125; &#125; clear(u); return 0;&#125;","categories":[],"tags":[]},{"title":"test23","slug":"test2","date":"2020-03-09T10:31:29.000Z","updated":"2021-02-09T10:31:29.000Z","comments":true,"path":"2020/03/09/test2/","link":"","permalink":"http://example.com/2020/03/09/test2/","excerpt":"","text":"wdadjaiw wd wad wad dwawa a daw aw dwa d wa da wa","categories":[],"tags":[{"name":"123","slug":"123","permalink":"http://example.com/tags/123/"}]}],"categories":[],"tags":[{"name":"123","slug":"123","permalink":"http://example.com/tags/123/"}]}